package org.apache.batik.ext.awt.image.codec.tiff;
class TIFFFaxDecoder {
    private int bitPointer;
    private int bytePointer;
    private byte[] data;
    private int w;
    private int h;
    private int fillOrder;
    private int changingElemSize = 0;
    private int[] prevChangingElems;
    private int[] currChangingElems;
    private int lastChangingElement = 0;
    private int compression = 2;
    private int uncompressedMode = 0;
    private int fillBits = 0;
    private int oneD;
    static int[] table1 = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };
    static int[] table2 = { 0, 128, 192, 224, 240, 248, 252, 254, 255 };
    static byte[] flipTable = { 0, -128, 64, -64, 32, -96, 96, -32, 16, -112,
    80,
    -48,
    48,
    -80,
    112,
    -16,
    8,
    -120,
    72,
    -56,
    40,
    -88,
    104,
    -24,
    24,
    -104,
    88,
    -40,
    56,
    -72,
    120,
    -8,
    4,
    -124,
    68,
    -60,
    36,
    -92,
    100,
    -28,
    20,
    -108,
    84,
    -44,
    52,
    -76,
    116,
    -12,
    12,
    -116,
    76,
    -52,
    44,
    -84,
    108,
    -20,
    28,
    -100,
    92,
    -36,
    60,
    -68,
    124,
    -4,
    2,
    -126,
    66,
    -62,
    34,
    -94,
    98,
    -30,
    18,
    -110,
    82,
    -46,
    50,
    -78,
    114,
    -14,
    10,
    -118,
    74,
    -54,
    42,
    -86,
    106,
    -22,
    26,
    -102,
    90,
    -38,
    58,
    -70,
    122,
    -6,
    6,
    -122,
    70,
    -58,
    38,
    -90,
    102,
    -26,
    22,
    -106,
    86,
    -42,
    54,
    -74,
    118,
    -10,
    14,
    -114,
    78,
    -50,
    46,
    -82,
    110,
    -18,
    30,
    -98,
    94,
    -34,
    62,
    -66,
    126,
    -2,
    1,
    -127,
    65,
    -63,
    33,
    -95,
    97,
    -31,
    17,
    -111,
    81,
    -47,
    49,
    -79,
    113,
    -15,
    9,
    -119,
    73,
    -55,
    41,
    -87,
    105,
    -23,
    25,
    -103,
    89,
    -39,
    57,
    -71,
    121,
    -7,
    5,
    -123,
    69,
    -59,
    37,
    -91,
    101,
    -27,
    21,
    -107,
    85,
    -43,
    53,
    -75,
    117,
    -11,
    13,
    -115,
    77,
    -51,
    45,
    -83,
    109,
    -19,
    29,
    -99,
    93,
    -35,
    61,
    -67,
    125,
    -3,
    3,
    -125,
    67,
    -61,
    35,
    -93,
    99,
    -29,
    19,
    -109,
    83,
    -45,
    51,
    -77,
    115,
    -13,
    11,
    -117,
    75,
    -53,
    43,
    -85,
    107,
    -21,
    27,
    -101,
    91,
    -37,
    59,
    -69,
    123,
    -5,
    7,
    -121,
    71,
    -57,
    39,
    -89,
    103,
    -25,
    23,
    -105,
    87,
    -41,
    55,
    -73,
    119,
    -9,
    15,
    -113,
    79,
    -49,
    47,
    -81,
    111,
    -17,
    31,
    -97,
    95,
    -33,
    63,
    -65,
    127,
    -1 };
    static short[] white = { 6430, 6400, 6400, 6400, 3225, 3225, 3225, 3225,
    944,
    944,
    944,
    944,
    976,
    976,
    976,
    976,
    1456,
    1456,
    1456,
    1456,
    1488,
    1488,
    1488,
    1488,
    718,
    718,
    718,
    718,
    718,
    718,
    718,
    718,
    750,
    750,
    750,
    750,
    750,
    750,
    750,
    750,
    1520,
    1520,
    1520,
    1520,
    1552,
    1552,
    1552,
    1552,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    654,
    654,
    654,
    654,
    654,
    654,
    654,
    654,
    1072,
    1072,
    1072,
    1072,
    1104,
    1104,
    1104,
    1104,
    1136,
    1136,
    1136,
    1136,
    1168,
    1168,
    1168,
    1168,
    1200,
    1200,
    1200,
    1200,
    1232,
    1232,
    1232,
    1232,
    622,
    622,
    622,
    622,
    622,
    622,
    622,
    622,
    1008,
    1008,
    1008,
    1008,
    1040,
    1040,
    1040,
    1040,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    1712,
    1712,
    1712,
    1712,
    1744,
    1744,
    1744,
    1744,
    846,
    846,
    846,
    846,
    846,
    846,
    846,
    846,
    1264,
    1264,
    1264,
    1264,
    1296,
    1296,
    1296,
    1296,
    1328,
    1328,
    1328,
    1328,
    1360,
    1360,
    1360,
    1360,
    1392,
    1392,
    1392,
    1392,
    1424,
    1424,
    1424,
    1424,
    686,
    686,
    686,
    686,
    686,
    686,
    686,
    686,
    910,
    910,
    910,
    910,
    910,
    910,
    910,
    910,
    1968,
    1968,
    1968,
    1968,
    2000,
    2000,
    2000,
    2000,
    2032,
    2032,
    2032,
    2032,
    16,
    16,
    16,
    16,
    10257,
    10257,
    10257,
    10257,
    12305,
    12305,
    12305,
    12305,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    878,
    878,
    878,
    878,
    878,
    878,
    878,
    878,
    1904,
    1904,
    1904,
    1904,
    1936,
    1936,
    1936,
    1936,
    -18413,
    -18413,
    -16365,
    -16365,
    -14317,
    -14317,
    -10221,
    -10221,
    590,
    590,
    590,
    590,
    590,
    590,
    590,
    590,
    782,
    782,
    782,
    782,
    782,
    782,
    782,
    782,
    1584,
    1584,
    1584,
    1584,
    1616,
    1616,
    1616,
    1616,
    1648,
    1648,
    1648,
    1648,
    1680,
    1680,
    1680,
    1680,
    814,
    814,
    814,
    814,
    814,
    814,
    814,
    814,
    1776,
    1776,
    1776,
    1776,
    1808,
    1808,
    1808,
    1808,
    1840,
    1840,
    1840,
    1840,
    1872,
    1872,
    1872,
    1872,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    14353,
    14353,
    14353,
    14353,
    16401,
    16401,
    16401,
    16401,
    22547,
    22547,
    24595,
    24595,
    20497,
    20497,
    20497,
    20497,
    18449,
    18449,
    18449,
    18449,
    26643,
    26643,
    28691,
    28691,
    30739,
    30739,
    -32749,
    -32749,
    -30701,
    -30701,
    -28653,
    -28653,
    -26605,
    -26605,
    -24557,
    -24557,
    -22509,
    -22509,
    -20461,
    -20461,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232 };
    static short[] additionalMakeup = { 28679, 28679, 31752, (short) 32777,
    (short)
      33801,
    (short)
      34825,
    (short)
      35849,
    (short)
      36873,
    (short)
      29703,
    (short)
      29703,
    (short)
      30727,
    (short)
      30727,
    (short)
      37897,
    (short)
      38921,
    (short)
      39945,
    (short)
      40969 };
    static short[] initBlack = { 3226, 6412, 200, 168, 38, 38, 134, 134, 100,
    100,
    100,
    100,
    68,
    68,
    68,
    68 };
    static short[] twoBitBlack = { 292, 260, 226, 226 };
    static short[] black = { 62, 62, 30, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    588,
    588,
    588,
    588,
    588,
    588,
    588,
    588,
    1680,
    1680,
    20499,
    22547,
    24595,
    26643,
    1776,
    1776,
    1808,
    1808,
    -24557,
    -22509,
    -20461,
    -18413,
    1904,
    1904,
    1936,
    1936,
    -16365,
    -14317,
    782,
    782,
    782,
    782,
    814,
    814,
    814,
    814,
    -12269,
    -10221,
    10257,
    10257,
    12305,
    12305,
    14353,
    14353,
    16403,
    18451,
    1712,
    1712,
    1744,
    1744,
    28691,
    30739,
    -32749,
    -30701,
    -28653,
    -26605,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    750,
    750,
    750,
    750,
    1616,
    1616,
    1648,
    1648,
    1424,
    1424,
    1456,
    1456,
    1488,
    1488,
    1520,
    1520,
    1840,
    1840,
    1872,
    1872,
    1968,
    1968,
    8209,
    8209,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    1552,
    1552,
    1584,
    1584,
    2000,
    2000,
    2032,
    2032,
    976,
    976,
    1008,
    1008,
    1040,
    1040,
    1072,
    1072,
    1296,
    1296,
    1328,
    1328,
    718,
    718,
    718,
    718,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    4113,
    4113,
    6161,
    6161,
    848,
    848,
    880,
    880,
    912,
    912,
    944,
    944,
    622,
    622,
    622,
    622,
    654,
    654,
    654,
    654,
    1104,
    1104,
    1136,
    1136,
    1168,
    1168,
    1200,
    1200,
    1232,
    1232,
    1264,
    1264,
    686,
    686,
    686,
    686,
    1360,
    1360,
    1392,
    1392,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390 };
    static byte[] twoDCodes = { 80, 88, 23, 71, 30, 30, 62, 62, 4, 4, 4, 4,
    4,
    4,
    4,
    4,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41 };
    public TIFFFaxDecoder(int fillOrder, int w, int h) { super();
                                                         this.fillOrder =
                                                           fillOrder;
                                                         this.w = w;
                                                         this.h = h;
                                                         this.bitPointer =
                                                           0;
                                                         this.bytePointer =
                                                           0;
                                                         this.prevChangingElems =
                                                           (new int[w]);
                                                         this.currChangingElems =
                                                           (new int[w]);
    }
    public void decode1D(byte[] buffer, byte[] compData, int startX,
                         int height) { this.data = compData;
                                       int lineOffset = 0;
                                       int scanlineStride =
                                         (w +
                                            7) /
                                         8;
                                       bitPointer = 0;
                                       bytePointer = 0;
                                       for (int i = 0; i <
                                                         height;
                                            i++) { decodeNextScanline(
                                                     buffer,
                                                     lineOffset,
                                                     startX);
                                                   lineOffset +=
                                                     scanlineStride;
                                       } }
    public void decodeNextScanline(byte[] buffer, int lineOffset,
                                   int bitOffset) { int bits =
                                                      0;
                                                    int code =
                                                      0;
                                                    int isT =
                                                      0;
                                                    int current;
                                                    int entry;
                                                    int twoBits;
                                                    boolean isWhite =
                                                      true;
                                                    changingElemSize =
                                                      0;
                                                    while (bitOffset <
                                                             w) {
                                                        while (isWhite) {
                                                            current =
                                                              nextNBits(
                                                                10);
                                                            entry =
                                                              white[current];
                                                            isT =
                                                              entry &
                                                                1;
                                                            bits =
                                                              entry >>>
                                                                1 &
                                                                15;
                                                            if (bits ==
                                                                  12) {
                                                                twoBits =
                                                                  nextLesserThan8Bits(
                                                                    2);
                                                                current =
                                                                  current <<
                                                                    2 &
                                                                    12 |
                                                                    twoBits;
                                                                entry =
                                                                  additionalMakeup[current];
                                                                bits =
                                                                  entry >>>
                                                                    1 &
                                                                    7;
                                                                code =
                                                                  entry >>>
                                                                    4 &
                                                                    4095;
                                                                bitOffset +=
                                                                  code;
                                                                updatePointer(
                                                                  4 -
                                                                    bits);
                                                            }
                                                            else
                                                                if (bits ==
                                                                      0) {
                                                                    throw new java.lang.Error(
                                                                      "TIFFFaxDecoder0");
                                                                }
                                                                else
                                                                    if (bits ==
                                                                          15) {
                                                                        throw new java.lang.Error(
                                                                          "TIFFFaxDecoder1");
                                                                    }
                                                                    else {
                                                                        code =
                                                                          entry >>>
                                                                            5 &
                                                                            2047;
                                                                        bitOffset +=
                                                                          code;
                                                                        updatePointer(
                                                                          10 -
                                                                            bits);
                                                                        if (isT ==
                                                                              0) {
                                                                            isWhite =
                                                                              false;
                                                                            currChangingElems[changingElemSize++] =
                                                                              bitOffset;
                                                                        }
                                                                    }
                                                        }
                                                        if (bitOffset ==
                                                              w) {
                                                            if (compression ==
                                                                  2) {
                                                                advancePointer(
                                                                  );
                                                            }
                                                            break;
                                                        }
                                                        while (!isWhite) {
                                                            current =
                                                              nextLesserThan8Bits(
                                                                4);
                                                            entry =
                                                              initBlack[current];
                                                            isT =
                                                              entry &
                                                                1;
                                                            bits =
                                                              entry >>>
                                                                1 &
                                                                15;
                                                            code =
                                                              entry >>>
                                                                5 &
                                                                2047;
                                                            if (code ==
                                                                  100) {
                                                                current =
                                                                  nextNBits(
                                                                    9);
                                                                entry =
                                                                  black[current];
                                                                isT =
                                                                  entry &
                                                                    1;
                                                                bits =
                                                                  entry >>>
                                                                    1 &
                                                                    15;
                                                                code =
                                                                  entry >>>
                                                                    5 &
                                                                    2047;
                                                                if (bits ==
                                                                      12) {
                                                                    updatePointer(
                                                                      5);
                                                                    current =
                                                                      nextLesserThan8Bits(
                                                                        4);
                                                                    entry =
                                                                      additionalMakeup[current];
                                                                    bits =
                                                                      entry >>>
                                                                        1 &
                                                                        7;
                                                                    code =
                                                                      entry >>>
                                                                        4 &
                                                                        4095;
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      4 -
                                                                        bits);
                                                                }
                                                                else
                                                                    if (bits ==
                                                                          15) {
                                                                        throw new java.lang.Error(
                                                                          "TIFFFaxDecoder2");
                                                                    }
                                                                    else {
                                                                        setToBlack(
                                                                          buffer,
                                                                          lineOffset,
                                                                          bitOffset,
                                                                          code);
                                                                        bitOffset +=
                                                                          code;
                                                                        updatePointer(
                                                                          9 -
                                                                            bits);
                                                                        if (isT ==
                                                                              0) {
                                                                            isWhite =
                                                                              true;
                                                                            currChangingElems[changingElemSize++] =
                                                                              bitOffset;
                                                                        }
                                                                    }
                                                            }
                                                            else
                                                                if (code ==
                                                                      200) {
                                                                    current =
                                                                      nextLesserThan8Bits(
                                                                        2);
                                                                    entry =
                                                                      twoBitBlack[current];
                                                                    code =
                                                                      entry >>>
                                                                        5 &
                                                                        2047;
                                                                    bits =
                                                                      entry >>>
                                                                        1 &
                                                                        15;
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      2 -
                                                                        bits);
                                                                    isWhite =
                                                                      true;
                                                                    currChangingElems[changingElemSize++] =
                                                                      bitOffset;
                                                                }
                                                                else {
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      4 -
                                                                        bits);
                                                                    isWhite =
                                                                      true;
                                                                    currChangingElems[changingElemSize++] =
                                                                      bitOffset;
                                                                }
                                                        }
                                                        if (bitOffset ==
                                                              w) {
                                                            if (compression ==
                                                                  2) {
                                                                advancePointer(
                                                                  );
                                                            }
                                                            break;
                                                        }
                                                    }
                                                    currChangingElems[changingElemSize++] =
                                                      bitOffset;
    }
    public void decode2D(byte[] buffer, byte[] compData,
                         int startX,
                         int height,
                         long tiffT4Options) {
        this.
          data =
          compData;
        compression =
          3;
        bitPointer =
          0;
        bytePointer =
          0;
        int scanlineStride =
          (w +
             7) /
          8;
        int a0;
        int a1;
        int b1;
        int b2;
        int[] b =
          new int[2];
        int entry;
        int code;
        int bits;
        boolean isWhite;
        int currIndex =
          0;
        int[] temp;
        oneD =
          (int)
            (tiffT4Options &
               1);
        uncompressedMode =
          (int)
            ((tiffT4Options &
                2) >>
               1);
        fillBits =
          (int)
            ((tiffT4Options &
                4) >>
               2);
        if (readEOL(
              ) !=
              1) {
            throw new java.lang.Error(
              "TIFFFaxDecoder3");
        }
        int lineOffset =
          0;
        int bitOffset;
        decodeNextScanline(
          buffer,
          lineOffset,
          startX);
        lineOffset +=
          scanlineStride;
        for (int lines =
               1;
             lines <
               height;
             lines++) {
            if (readEOL(
                  ) ==
                  0) {
                temp =
                  prevChangingElems;
                prevChangingElems =
                  currChangingElems;
                currChangingElems =
                  temp;
                currIndex =
                  0;
                a0 =
                  -1;
                isWhite =
                  true;
                bitOffset =
                  startX;
                lastChangingElement =
                  0;
                while (bitOffset <
                         w) {
                    getNextChangingElement(
                      a0,
                      isWhite,
                      b);
                    b1 =
                      b[0];
                    b2 =
                      b[1];
                    entry =
                      nextLesserThan8Bits(
                        7);
                    entry =
                      (int)
                        (twoDCodes[entry] &
                           255);
                    code =
                      (entry &
                         120) >>>
                        3;
                    bits =
                      entry &
                        7;
                    if (code ==
                          0) {
                        if (!isWhite) {
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              b2 -
                                bitOffset);
                        }
                        bitOffset =
                          (a0 =
                             b2);
                        updatePointer(
                          7 -
                            bits);
                    }
                    else
                        if (code ==
                              1) {
                            updatePointer(
                              7 -
                                bits);
                            int number;
                            if (isWhite) {
                                number =
                                  decodeWhiteCodeWord(
                                    );
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                                number =
                                  decodeBlackCodeWord(
                                    );
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  number);
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                            }
                            else {
                                number =
                                  decodeBlackCodeWord(
                                    );
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  number);
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                                number =
                                  decodeWhiteCodeWord(
                                    );
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                            }
                            a0 =
                              bitOffset;
                        }
                        else
                            if (code <=
                                  8) {
                                a1 =
                                  b1 +
                                    (code -
                                       5);
                                currChangingElems[currIndex++] =
                                  a1;
                                if (!isWhite) {
                                    setToBlack(
                                      buffer,
                                      lineOffset,
                                      bitOffset,
                                      a1 -
                                        bitOffset);
                                }
                                bitOffset =
                                  (a0 =
                                     a1);
                                isWhite =
                                  !isWhite;
                                updatePointer(
                                  7 -
                                    bits);
                            }
                            else {
                                throw new java.lang.Error(
                                  "TIFFFaxDecoder4");
                            }
                }
                currChangingElems[currIndex++] =
                  bitOffset;
                changingElemSize =
                  currIndex;
            }
            else {
                decodeNextScanline(
                  buffer,
                  lineOffset,
                  startX);
            }
            lineOffset +=
              scanlineStride;
        }
    }
    public synchronized void decodeT6(byte[] buffer,
                                      byte[] compData,
                                      int startX,
                                      int height,
                                      long tiffT6Options) {
        this.
          data =
          compData;
        compression =
          4;
        bitPointer =
          0;
        bytePointer =
          0;
        int scanlineStride =
          (w +
             7) /
          8;
        int a0;
        int a1;
        int b1;
        int b2;
        int entry;
        int code;
        int bits;
        boolean isWhite;
        int currIndex;
        int[] temp;
        int[] b =
          new int[2];
        uncompressedMode =
          (int)
            ((tiffT6Options &
                2) >>
               1);
        int[] cce =
          currChangingElems;
        changingElemSize =
          0;
        cce[changingElemSize++] =
          w;
        cce[changingElemSize++] =
          w;
        int lineOffset =
          0;
        int bitOffset;
        for (int lines =
               0;
             lines <
               height;
             lines++) {
            a0 =
              -1;
            isWhite =
              true;
            temp =
              prevChangingElems;
            prevChangingElems =
              currChangingElems;
            cce =
              (currChangingElems =
                 temp);
            currIndex =
              0;
            bitOffset =
              startX;
            lastChangingElement =
              0;
            while (bitOffset <
                     w) {
                getNextChangingElement(
                  a0,
                  isWhite,
                  b);
                b1 =
                  b[0];
                b2 =
                  b[1];
                entry =
                  nextLesserThan8Bits(
                    7);
                entry =
                  (int)
                    (twoDCodes[entry] &
                       255);
                code =
                  (entry &
                     120) >>>
                    3;
                bits =
                  entry &
                    7;
                if (code ==
                      0) {
                    if (!isWhite) {
                        setToBlack(
                          buffer,
                          lineOffset,
                          bitOffset,
                          b2 -
                            bitOffset);
                    }
                    bitOffset =
                      (a0 =
                         b2);
                    updatePointer(
                      7 -
                        bits);
                }
                else
                    if (code ==
                          1) {
                        updatePointer(
                          7 -
                            bits);
                        int number;
                        if (isWhite) {
                            number =
                              decodeWhiteCodeWord(
                                );
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                            number =
                              decodeBlackCodeWord(
                                );
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              number);
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                        }
                        else {
                            number =
                              decodeBlackCodeWord(
                                );
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              number);
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                            number =
                              decodeWhiteCodeWord(
                                );
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                        }
                        a0 =
                          bitOffset;
                    }
                    else
                        if (code <=
                              8) {
                            a1 =
                              b1 +
                                (code -
                                   5);
                            cce[currIndex++] =
                              a1;
                            if (!isWhite) {
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  a1 -
                                    bitOffset);
                            }
                            bitOffset =
                              (a0 =
                                 a1);
                            isWhite =
                              !isWhite;
                            updatePointer(
                              7 -
                                bits);
                        }
                        else
                            if (code ==
                                  11) {
                                if (nextLesserThan8Bits(
                                      3) !=
                                      7) {
                                    throw new java.lang.Error(
                                      "TIFFFaxDecoder5");
                                }
                                int zeros =
                                  0;
                                boolean exit =
                                  false;
                                while (!exit) {
                                    while (nextLesserThan8Bits(
                                             1) !=
                                             1) {
                                        zeros++;
                                    }
                                    if (zeros >
                                          5) {
                                        zeros =
                                          zeros -
                                            6;
                                        if (!isWhite &&
                                              zeros >
                                              0) {
                                            cce[currIndex++] =
                                              bitOffset;
                                        }
                                        bitOffset +=
                                          zeros;
                                        if (zeros >
                                              0) {
                                            isWhite =
                                              true;
                                        }
                                        if (nextLesserThan8Bits(
                                              1) ==
                                              0) {
                                            if (!isWhite) {
                                                cce[currIndex++] =
                                                  bitOffset;
                                            }
                                            isWhite =
                                              true;
                                        }
                                        else {
                                            if (isWhite) {
                                                cce[currIndex++] =
                                                  bitOffset;
                                            }
                                            isWhite =
                                              false;
                                        }
                                        exit =
                                          true;
                                    }
                                    if (zeros ==
                                          5) {
                                        if (!isWhite) {
                                            cce[currIndex++] =
                                              bitOffset;
                                        }
                                        bitOffset +=
                                          zeros;
                                        isWhite =
                                          true;
                                    }
                                    else {
                                        bitOffset +=
                                          zeros;
                                        cce[currIndex++] =
                                          bitOffset;
                                        setToBlack(
                                          buffer,
                                          lineOffset,
                                          bitOffset,
                                          1);
                                        ++bitOffset;
                                        isWhite =
                                          false;
                                    }
                                }
                            }
                            else {
                                throw new java.lang.Error(
                                  "TIFFFaxDecoder5");
                            }
            }
            cce[currIndex++] =
              bitOffset;
            changingElemSize =
              currIndex;
            lineOffset +=
              scanlineStride;
        }
    }
    private void setToBlack(byte[] buffer,
                            int lineOffset,
                            int bitOffset,
                            int numBits) {
        int bitNum =
          8 *
          lineOffset +
          bitOffset;
        int lastBit =
          bitNum +
          numBits;
        int byteNum =
          bitNum >>
          3;
        int shift =
          bitNum &
          7;
        if (shift >
              0) {
            int maskVal =
              1 <<
              7 -
              shift;
            byte val =
              buffer[byteNum];
            while (maskVal >
                     0 &&
                     bitNum <
                     lastBit) {
                val |=
                  maskVal;
                maskVal >>=
                  1;
                ++bitNum;
            }
            buffer[byteNum] =
              val;
        }
        byteNum =
          bitNum >>
            3;
        while (bitNum <
                 lastBit -
                 7) {
            buffer[byteNum++] =
              (byte)
                255;
            bitNum +=
              8;
        }
        while (bitNum <
                 lastBit) {
            byteNum =
              bitNum >>
                3;
            buffer[byteNum] |=
              1 <<
                7 -
                (bitNum &
                   7);
            ++bitNum;
        }
    }
    private int decodeWhiteCodeWord() { int current;
                                        int entry;
                                        int bits;
                                        int isT;
                                        int twoBits;
                                        int code =
                                          -1;
                                        int runLength =
                                          0;
                                        boolean isWhite =
                                          true;
                                        while (isWhite) {
                                            current =
                                              nextNBits(
                                                10);
                                            entry =
                                              white[current];
                                            isT =
                                              entry &
                                                1;
                                            bits =
                                              entry >>>
                                                1 &
                                                15;
                                            if (bits ==
                                                  12) {
                                                twoBits =
                                                  nextLesserThan8Bits(
                                                    2);
                                                current =
                                                  current <<
                                                    2 &
                                                    12 |
                                                    twoBits;
                                                entry =
                                                  additionalMakeup[current];
                                                bits =
                                                  entry >>>
                                                    1 &
                                                    7;
                                                code =
                                                  entry >>>
                                                    4 &
                                                    4095;
                                                runLength +=
                                                  code;
                                                updatePointer(
                                                  4 -
                                                    bits);
                                            }
                                            else
                                                if (bits ==
                                                      0) {
                                                    throw new java.lang.Error(
                                                      "TIFFFaxDecoder0");
                                                }
                                                else
                                                    if (bits ==
                                                          15) {
                                                        throw new java.lang.Error(
                                                          "TIFFFaxDecoder1");
                                                    }
                                                    else {
                                                        code =
                                                          entry >>>
                                                            5 &
                                                            2047;
                                                        runLength +=
                                                          code;
                                                        updatePointer(
                                                          10 -
                                                            bits);
                                                        if (isT ==
                                                              0) {
                                                            isWhite =
                                                              false;
                                                        }
                                                    }
                                        }
                                        return runLength;
    }
    private int decodeBlackCodeWord() { int current;
                                        int entry;
                                        int bits;
                                        int isT;
                                        int code =
                                          -1;
                                        int runLength =
                                          0;
                                        boolean isWhite =
                                          false;
                                        while (!isWhite) {
                                            current =
                                              nextLesserThan8Bits(
                                                4);
                                            entry =
                                              initBlack[current];
                                            isT =
                                              entry &
                                                1;
                                            bits =
                                              entry >>>
                                                1 &
                                                15;
                                            code =
                                              entry >>>
                                                5 &
                                                2047;
                                            if (code ==
                                                  100) {
                                                current =
                                                  nextNBits(
                                                    9);
                                                entry =
                                                  black[current];
                                                isT =
                                                  entry &
                                                    1;
                                                bits =
                                                  entry >>>
                                                    1 &
                                                    15;
                                                code =
                                                  entry >>>
                                                    5 &
                                                    2047;
                                                if (bits ==
                                                      12) {
                                                    updatePointer(
                                                      5);
                                                    current =
                                                      nextLesserThan8Bits(
                                                        4);
                                                    entry =
                                                      additionalMakeup[current];
                                                    bits =
                                                      entry >>>
                                                        1 &
                                                        7;
                                                    code =
                                                      entry >>>
                                                        4 &
                                                        4095;
                                                    runLength +=
                                                      code;
                                                    updatePointer(
                                                      4 -
                                                        bits);
                                                }
                                                else
                                                    if (bits ==
                                                          15) {
                                                        throw new java.lang.Error(
                                                          "TIFFFaxDecoder2");
                                                    }
                                                    else {
                                                        runLength +=
                                                          code;
                                                        updatePointer(
                                                          9 -
                                                            bits);
                                                        if (isT ==
                                                              0) {
                                                            isWhite =
                                                              true;
                                                        }
                                                    }
                                            }
                                            else
                                                if (code ==
                                                      200) {
                                                    current =
                                                      nextLesserThan8Bits(
                                                        2);
                                                    entry =
                                                      twoBitBlack[current];
                                                    code =
                                                      entry >>>
                                                        5 &
                                                        2047;
                                                    runLength +=
                                                      code;
                                                    bits =
                                                      entry >>>
                                                        1 &
                                                        15;
                                                    updatePointer(
                                                      2 -
                                                        bits);
                                                    isWhite =
                                                      true;
                                                }
                                                else {
                                                    runLength +=
                                                      code;
                                                    updatePointer(
                                                      4 -
                                                        bits);
                                                    isWhite =
                                                      true;
                                                }
                                        }
                                        return runLength;
    }
    private int readEOL() { if (fillBits ==
                                  0) { if (nextNBits(
                                             12) !=
                                             1) {
                                           throw new java.lang.Error(
                                             "TIFFFaxDecoder6");
                                       } }
                            else
                                if (fillBits ==
                                      1) {
                                    int bitsLeft =
                                      8 -
                                      bitPointer;
                                    if (nextNBits(
                                          bitsLeft) !=
                                          0) {
                                        throw new java.lang.Error(
                                          "TIFFFaxDecoder8");
                                    }
                                    if (bitsLeft <
                                          4) {
                                        if (nextNBits(
                                              8) !=
                                              0) {
                                            throw new java.lang.Error(
                                              "TIFFFaxDecoder8");
                                        }
                                    }
                                    int n;
                                    while ((n =
                                              nextNBits(
                                                8)) !=
                                             1) {
                                        if (n !=
                                              0) {
                                            throw new java.lang.Error(
                                              "TIFFFaxDecoder8");
                                        }
                                    }
                                }
                            if (oneD == 0) {
                                return 1;
                            }
                            else {
                                return nextLesserThan8Bits(
                                         1);
                            } }
    private void getNextChangingElement(int a0,
                                        boolean isWhite,
                                        int[] ret) {
        int[] pce =
          this.
            prevChangingElems;
        int ces =
          this.
            changingElemSize;
        int start =
          lastChangingElement >
          0
          ? lastChangingElement -
          1
          : 0;
        if (isWhite) {
            start &=
              ~1;
        }
        else {
            start |=
              1;
        }
        int i =
          start;
        for (;
             i <
               ces;
             i +=
               2) {
            int temp =
              pce[i];
            if (temp >
                  a0) {
                lastChangingElement =
                  i;
                ret[0] =
                  temp;
                break;
            }
        }
        if (i +
              1 <
              ces) {
            ret[1] =
              pce[i +
                    1];
        }
    }
    private int nextNBits(int bitsToGet) {
        byte b;
        byte next;
        byte next2next;
        int l =
          data.
            length -
          1;
        int bp =
          this.
            bytePointer;
        if (fillOrder ==
              1) {
            b =
              data[bp];
            if (bp ==
                  l) {
                next =
                  0;
                next2next =
                  0;
            }
            else
                if (bp +
                      1 ==
                      l) {
                    next =
                      data[bp +
                             1];
                    next2next =
                      0;
                }
                else {
                    next =
                      data[bp +
                             1];
                    next2next =
                      data[bp +
                             2];
                }
        }
        else
            if (fillOrder ==
                  2) {
                b =
                  flipTable[data[bp] &
                              255];
                if (bp ==
                      l) {
                    next =
                      0;
                    next2next =
                      0;
                }
                else
                    if (bp +
                          1 ==
                          l) {
                        next =
                          flipTable[data[bp +
                                           1] &
                                      255];
                        next2next =
                          0;
                    }
                    else {
                        next =
                          flipTable[data[bp +
                                           1] &
                                      255];
                        next2next =
                          flipTable[data[bp +
                                           2] &
                                      255];
                    }
            }
            else {
                throw new java.lang.Error(
                  "TIFFFaxDecoder7");
            }
        int bitsLeft =
          8 -
          bitPointer;
        int bitsFromNextByte =
          bitsToGet -
          bitsLeft;
        int bitsFromNext2NextByte =
          0;
        if (bitsFromNextByte >
              8) {
            bitsFromNext2NextByte =
              bitsFromNextByte -
                8;
            bitsFromNextByte =
              8;
        }
        bytePointer++;
        int i1 =
          (b &
             table1[bitsLeft]) <<
          bitsToGet -
          bitsLeft;
        int i2 =
          (next &
             table2[bitsFromNextByte]) >>>
          8 -
          bitsFromNextByte;
        int i3 =
          0;
        if (bitsFromNext2NextByte !=
              0) {
            i2 <<=
              bitsFromNext2NextByte;
            i3 =
              (next2next &
                 table2[bitsFromNext2NextByte]) >>>
                8 -
                bitsFromNext2NextByte;
            i2 |=
              i3;
            bytePointer++;
            bitPointer =
              bitsFromNext2NextByte;
        }
        else {
            if (bitsFromNextByte ==
                  8) {
                bitPointer =
                  0;
                bytePointer++;
            }
            else {
                bitPointer =
                  bitsFromNextByte;
            }
        }
        int i =
          i1 |
          i2;
        return i;
    }
    private int nextLesserThan8Bits(int bitsToGet) {
        byte b;
        byte next;
        int l =
          data.
            length -
          1;
        int bp =
          this.
            bytePointer;
        if (fillOrder ==
              1) {
            b =
              data[bp];
            if (bp ==
                  l) {
                next =
                  0;
            }
            else {
                next =
                  data[bp +
                         1];
            }
        }
        else
            if (fillOrder ==
                  2) {
                b =
                  flipTable[data[bp] &
                              255];
                if (bp ==
                      l) {
                    next =
                      0;
                }
                else {
                    next =
                      flipTable[data[bp +
                                       1] &
                                  255];
                }
            }
            else {
                throw new java.lang.Error(
                  "TIFFFaxDecoder7");
            }
        int bitsLeft =
          8 -
          bitPointer;
        int bitsFromNextByte =
          bitsToGet -
          bitsLeft;
        int shift =
          bitsLeft -
          bitsToGet;
        int i1;
        int i2;
        if (shift >=
              0) {
            i1 =
              (b &
                 table1[bitsLeft]) >>>
                shift;
            bitPointer +=
              bitsToGet;
            if (bitPointer ==
                  8) {
                bitPointer =
                  0;
                bytePointer++;
            }
        }
        else {
            i1 =
              (b &
                 table1[bitsLeft]) <<
                -shift;
            i2 =
              (next &
                 table2[bitsFromNextByte]) >>>
                8 -
                bitsFromNextByte;
            i1 |=
              i2;
            bytePointer++;
            bitPointer =
              bitsFromNextByte;
        }
        return i1;
    }
    private void updatePointer(int bitsToMoveBack) {
        int i =
          bitPointer -
          bitsToMoveBack;
        if (i <
              0) {
            bytePointer--;
            bitPointer =
              8 +
                i;
        }
        else {
            bitPointer =
              i;
        }
    }
    private boolean advancePointer() { if (bitPointer !=
                                             0) {
                                           bytePointer++;
                                           bitPointer =
                                             0;
                                       }
                                       return true;
    }
    public static final java.lang.String jlc$CompilerVersion$jl7 =
      "2.7.0";
    public static final long jlc$SourceLastModified$jl7 =
      1471188907000L;
    public static final java.lang.String jlc$ClassType$jl7 =
      ("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" +
       "zeC+pzcw14pu5Jd4dfHfAccRtFNlPAAA");
    public static final java.lang.String jlc$CompilerVersion$jl5 =
      "2.7.0";
    public static final long jlc$SourceLastModified$jl5 =
      1471188907000L;
    public static final java.lang.String jlc$ClassType$jl5 =
      ("H4sIAAAAAAAAAL18CbDsWHle37fM8pjlzQAz44EZhpk3hqHHT+qWevMQ4251" +
       "S+pFSy/qRQ5+aF9aLam1tNQiYwOOAzFVAyEDJhWYKjvYjh0WOzGVVLCTSZzE" +
       "JrYp4/JeCdhUyiYhpCBlOzYkJkfqvuu798597w10lU6rdbbv+89//v8/kk5/" +
       "/Ku5i76Xy7uOtdYsJ7iqxMFV0ypdDdau4l/t9Eqs4PmKjFmC74/AtWvS4z9/" +
       "719+8/365XO52/jcKwXbdgIhMBzbHyi+Y60UuZe7d/9qy1IWfpC73DOFlQCF" +
       "gWFBPcMPnunlXnGgapC70tuFAAEIEIAAZRCg+n4pUOluxQ4XWFpDsAN/mfuh" +
       "3E4vd5srpfCC3OsPN+IKnrDYNsNmDEALd6S/x4BUVjn2co/tcd9wvo7wB/PQ" +
       "8z/+g5f/+fncvXzuXsMepnAkACIAnfC5uxbKQlQ8vy7Liszn7rMVRR4qniFY" +
       "RpLh5nP3+4ZmC0HoKXtCSi+GruJlfe5L7i4p5eaFUuB4e/RUQ7Hk3V8XVUvQ" +
       "ANcH9rluGOLpdUDwkgGAeaogKbtVLswNWw5yrztaY4/jlS4oAKrevlAC3dnr" +
       "6oItgAu5+zdjZwm2Bg0Dz7A1UPSiE4JegtzDJzaaytoVpLmgKdeC3ENHy7Gb" +
       "LFDqzkwQaZUg9+qjxbKWwCg9fGSUDozPV+k3P/d2m7TPZZhlRbJS/HeASo8e" +
       "qTRQVMVTbEnZVLzrTb0PCQ/88nvO5XKg8KuPFN6U+Zd/5+vf//SjL/7apsxr" +
       "jinDiKYiBdekj4n3fP612FO18ymMO1zHN9LBP8Q8U392m/NM7IKZ98Bei2nm" +
       "1d3MFwf/afaOn1O+ci53qZ27TXKscAH06D7JWbiGpXiEYiueEChyO3enYstY" +
       "lt/O3Q7Oe4atbK4yquorQTt3wcou3eZkv4GIVNBEKqLbwblhq87uuSsEenYe" +
       "u7nt5yI4vmt7nn0HuTmkOwsFEiTBNmwHYj0n5e9Dih2IQLY6JAKtn0O+E3pA" +
       "BSHH0yAB6IGubDPSmSlEAWQswPBDkgMGDAoMVYVGbRzHhbippNe8q6nSud/Z" +
       "7uKU/eVoZwcMzGuPmgULzCjSsUDZa9LzYaP19U9e+/Vze9NkK7cgVwUIrm4Q" +
       "XM0QZCYVILiaIbiaIbiaIrh6GEFuZyfr+FUpko02gLGcA6sA7OVdTw3f2nnb" +
       "ex4/D9TQjS6AgUiLQiebbWzfjrQzaykBZc69+OHoneMfhs/lzh22vyl6cOlS" +
       "Wp1NreaedbxydN4d1+697/7yX37qQ886+zPwkEHfGobra6YT+/GjcvYcSZGB" +
       "qdxv/k2PCZ++9svPXjmXuwCsBbCQgQA0GhifR4/2cWiCP7NrLFMuFwFh1fEW" +
       "gpVm7Vq4S4HuOdH+lUwB7snO7wMyfsVW7c99z2YGbL7T3Fe6afqqjcKkg3aE" +
       "RWaM/9bQ/egffO6/I5m4d+32vQc84VAJnjlgK9LG7s2swn37OjDyFAWU+68f" +
       "Zv/hB7/67h/IFACUeOK4Dq+kKQZsBBhCIOYf/bXlH37xCx/7nXP7ShMAZxmK" +
       "liHFeyTT67lLp5AEvX33Ph5gaywwAVOtucLZC0c2VEMQLSXV0v9775OFT//P" +
       "5y5v9MACV3bV6OmXbmD/+nc1cu/49R/8P49mzexIqa/bl9l+sY0BfeV+y3XP" +
       "E9Ypjvidv/3IP/pV4aPAFAPz5xuJklm085kMzoNKT50S73jGAozGausjoGfv" +
       "/+L8I1/+xMb+H3UoRwor73n+x7519bnnzx3wuk9c5/gO1tl43kyN7t6MyLfA" +
       "Zwccf5Me6UikFzaW935sa/4f27P/rhsDOq8/DVbWBf5nn3r2M//02XdvaNx/" +
       "2Om0QEz1id/7f79x9cN//NljLNp5EFCkP5AsybBCGdY3ZenVFFwm2VyW90ya" +
       "vM4/aDoOC/lARHdNev/vfO3u8df+zdezfg+HhAdnCiW4GyndkyaPpaQfPGon" +
       "ScHXQTn0RfpvX7Ze/CZokQctSsAr+IwHDGx8aF5tS1+8/Y/+3a888LbPn8+d" +
       "w3OXLEeQcSEzUbk7gW1QfB1Y/Nh9y/dv5kZ0B0guZ1Rz15HfTKmHsl8Pn65k" +
       "eBrR7Ru4h77BWOK7vvRX1wkhs8vH6N2R+jz08Y88jH3fV7L6+wYyrf1ofL0r" +
       "A9Hvft3izy3+4tzjt/3Hc7nb+dxlaRtajwUrTM0OD8JJfzfeBuH3ofzDoeEm" +
       "DnpmzwG89qjiH+j2qGneVzhwnpZOzy8dscZ3pVJ+Izhesw1IXnPUGu/kspN2" +
       "VuX1WXolTd6wa/xudz1jBeZN1jIa5C6JRsA6WcC8p+GXs3pvTpPOZkjfcuLw" +
       "N28cXP8EcOkptYvrFeI6UE4BNrhBYA+B47VbYK89Adj0LMAuyEIgAN1+8mTd" +
       "zqzwxh6+8NNPfO6HX3jiT7KpeIfhAw2oe9ox0fyBOl/7+Be/8tt3P/LJzNlf" +
       "EAV/owtHl0HXr3IOLV4yvHftCSHj/Bgg80sbGWy+g5x0i8Gl6BkyiCobAOVQ" +
       "8gw3AIujlr0yPMdegDZ2Y9jvRDcbjYCzcdqcl8FwpXq0Z6h2toFjpiBp8rbd" +
       "sdeOH/tz6ekbAzBXDVuwdnXgNkuxtc1KIdPLa26818W5Tb3s96uDrXNOzQNY" +
       "sDm2kvr53bxNnGs4V/cWyyAzvg6sl3vTybpGZUO+b8x+9V3/4+HR9+lvu4EA" +
       "93VHVPFokz9LffyzxHdLHziXO79n2q5bSR+u9Mxhg3bJU8DS3x4dMmuPbOSf" +
       "yW8j/DR5MhPxKc41PiUvSZMQjJaUinozMqcUfzbOHbEqsxu0Kq8GxyNbq/LI" +
       "CVblHWexKjvRcUbund8GOO8+Exz9ODjvuUE4D4Pj0S2cR0+A89xZ4NwJ1utW" +
       "FsEcB+t9NwjrSXA8voX1+AmwPngWWJclHczr1BJZymIIYuzj0H3oBtFdAccT" +
       "W3RPnIDuI2dBd5/rKSvsAEI/K//Ww93dC5Y/9Ka3zfet22rBdX3IX2kiWFj6" +
       "igfRYG3PGtJc8VjBVqyXyyWcpZtMFsjJ5v8ndyX606eZ/zQxN2JNk/neMP/E" +
       "9XY//blIE+d6Q57+9jbdZrXTZHWKffrEKXmfSpN/liZv3yA5pewvXGfnPnoT" +
       "Snllq5RXTlDKXzyTUkqh5x1Syj1JHID36ZuIOt+whfeGE+B95izwXmkJfnAQ" +
       "nnJg4XcA4C/dIMDHwPHUFuBTJwD892cKi9P7n2BR5m9vlhwF9is3YQuf3gJ7" +
       "+gRgnz2TLQztXWiKTIGpeBy6/3yD6FIftr0nk7vuxtMW3W+dBd0dqQNpGJvn" +
       "JUdRff4mvOzVLaqrJ6D6/TMtJUCQ0jwO0R+cHVF2g+42cHzvFhF8AqIvnIAI" +
       "RLN+9jhnL7gN0jC0cNy8/OJN4MK3uN58Aq4/PUVSXzqMqXgcpj+7CUzmFlP7" +
       "BExfPQumO1XLcEcprvTCtSOw/teNw9qxt7AWJ8D687PAuhjpxnbFc8TVg5Od" +
       "Ozc9bL6DnP7yLMuGY6JuGwshUChn95EnaKKR5e76++9YX8euAy/6uuMFJ0cC" +
       "39gKeWfnpiKBv77JSOAbWWN/nSanRAI7d5ySdylNbktz3r5BckrZu66LBP7i" +
       "JvR0tVWi5fF6unPvWfT0siDL2T1/waKEuRK6e4LYR7dz+SbQ/dAW3foEdA+c" +
       "aXIbthE0LEGaHwfrwRuEVQbNv3ML650nwHrkLLBeEURO4xRgj964vM5d3AL7" +
       "uycAu3ImqyOeBOnJm4D0xk3Rc7efACl/piEEsmpiIBLxj7HPO0+/JKyN/dgB" +
       "DvJi8WrlampPdorHd3x+zzh86YCFCHIPmpZ0ZfeRxVjx0qjtimlVsvqvBnNg" +
       "/+bQ5rWCI5MTPTNI38vds99Yz7G1Z977397/G+974ovncjud3MVVerc69g72" +
       "SIfpSxt/7+MffOQVz//xe7MnZECE47//C8hfpVSfuTGqD6dUh5nt7oEYmsoe" +
       "ainyHtujt+Us5xbYBg/IJOq367ufXkFsTutSzE/DqVoQ/GWkQsWO6Lv4vE+J" +
       "/syqRVSzDQVGrC/ESeDrQ7utsesKEfcYSPSTZnPULcNU06zhmKGUpGo9RrvD" +
       "tmSN7ea8La1JYqqtfUySuvic6dpNra2TdVkaYo7ewpYopy3ceXtYLSTFCpX4" +
       "FarYsfTusigno5EHBZVppZavIONVglrIsDO25qaw9AeGSHe1cbk2nWnEQKDp" +
       "iTl0Z4UGKxOlpu+5dE2FFIFpjvEhyyULdzj2wnXMB628LviO0FkWu7yJd+bl" +
       "RUGrtbmhtp4Vur1FSPW56cBfYPHEY4uMYyzXUWW67M6cqTx351oy6Jiu26Oo" +
       "wF3R1UZbiLr9uLkY5jFxhebR1mK48uLlYKTOFp7iQB4mixRDFniz2bdqc9vk" +
       "zKSHNycKhyUTe8R2wpkQjpyyyzirAdleBdw6H3VlYxJ2sZa24lc0VImh8Wo0" +
       "4tdYnu8uyrO1x+eLhrUsM3BhiNFNF1EKE8EXUN1ec2Ns3Fst/bjNr3uqMIjK" +
       "JsfYyqQoTxwsr008ftSGmMKELFlLhyb6rVha8HEb5edDfVFZ9AmGGC8dXhTD" +
       "acOAp2O7P17ovBP2glJVYBHbKsAoNXZJYkZjntCmuoN6f9gcOUKD67gdLmAF" +
       "q+UNCs2GW1hgUaMMxN5111GjAjTJ5+H1cKIrJAujbcSPZgWFrzLjBGOcTshb" +
       "vBXiQV8s9XkLKkiF5dw1HcY3BgVFnw0gpRFNPbzeWJhzV5MrfLs0LeHDhFhH" +
       "RjCAe2SCLbW6Y3L8OuiUHSHojmZt0W1NZgbmujMIb1DNQtDsupPyBKt3DLpX" +
       "jwPc0wodxMjT8ICAh618ra622oKP6INuvd2OwlphqveolttjBXZOuDVEXkRV" +
       "tVssjmfhECMaDDe2cIjltAIzGxTnY3LJWTqpmY1Q8EcybPRIE+Y6/f6yBw04" +
       "3OaUMKxw/GQljEzULRtJshSpJJxBXbHVz9tugiBsV/E0eIx12QmMwXijUmtL" +
       "SaXXCCMbGc2bLLU2+s4KpTo8pJC9aauUL6GjSll2R1yNp5eTsZIQImbyls0S" +
       "bbebSKE7mBc78LgPLTimMK7XIGReW6LNpS7gIwm0WRYscjJau2N1GQglqNoc" +
       "CGy/gXe4Rk3p0kvP9qJix1WtQmI0i9N4XE08bJUfSWY+T7ssx5pzI3aNpUg2" +
       "4EiuiaqBksQwIuCyrQ09JM4jtW7U6ejmNBEJtEEKfXc1a9ode9ho+x4xMPNh" +
       "PVGGbTThp32YDUZqoSbZJZHvrwiVgBmDMitKhSQcSF23h9oM5ys21+v6a8cT" +
       "na7MqXOnZtMrQQ1JxOouGjHTKvnIwEBbjSbRaFOzgYRJXYxoS/1ZZBoYgU2a" +
       "Lazl2JGpS1pr0aKpjliJhmF9UqqI9NQcB16RLBqrerNd7Ax1re3RroJ3SmWS" +
       "VgY1SDKrGhU0+yqjEkiAFvDhYlgP5v56PXe8Ae9SpYZdopBFja2JVgfDYwbC" +
       "TdfQq7N8K5aBG4umMB7HRNka63m7E5Rsvk14+jSGI2QuNVE0WK3MznpCjeh8" +
       "OQ+tIscYCGSTWa8xL5INLa856ypaa5VXS6jhBRAxoSEIjRowKUuyi1MTTWU0" +
       "f8715aJXXKDC2B7g5Rq38ph1lyKZxA6kKuZS0XzRVs0evaiqgxGwPXlI5XhZ" +
       "4EidoxNmaDjQGvCNg67FMqSCJiMxKUdjDV9Ni6N2UemshSBPgWVIFPl45IuD" +
       "ZJUIFGnG1UkzDuR8LYxXkEOO7H61YAqoNOOxtejKlajKCyFGe7IfF9fdPlf2" +
       "CmWRafaCSi1Zx6XQL2BmVIaaIyOuRF2k0ar3aBtZrReurKp5BMUKJJnodqtW" +
       "jIbwciD1uUV1lHcxqz1SErsXaWTARRNFK0wH+aHGVsat2bgrWEMb1yFhvC7U" +
       "zBBi5WheaWE4g8yTiUnX6tVKjUqEEVEql/MeXETmcSteNX2J4blWUoJWAbvu" +
       "BAzX0XGy4ov2pAKt23nLazWR+qyw6talpSzVp7bT7aBeSFcJP1r0eGM61ARi" +
       "Jq8ZPu8TNX9JMpqc7056Y2KEYk5QwZQ8CwVsaKkclPSFCr6YQQinVIlCJSKa" +
       "eQJ4S74BaWqEoySLQFjTZSi6NZAFJUy0oNfu2/3IbFSNSj/odWba1GgUAgVB" +
       "oOmiVh1itmEGZWnNTkcwFkOtpl4dt9cycNrlYeq52sCsOH10QsRNeTEhalJ7" +
       "kZ8mtajawSvNGmpwPY5r5GNl3VKgmsxArA5XaqsqVHPmBD5byq6NYiPR1sKG" +
       "xJlooS9QK5uo1CoCHOAkZFCq1RUL/MDzvT5UmqADyux7C6RPWy5Vrg6CsDBt" +
       "aER74esmWSdida1ZNSWqE/IUbeAMlmB2EcFn7tSSlz1cA04vhtX5pFBDgyKJ" +
       "hGheRh1nWoLo0K7gMqWNvGRsSLoQrWqaUPL47li3lyrTs821IRZK7KqPmhjc" +
       "bdHtABGEVqOQDAYVwrMK42oFUlUkGSChtBz2hmwBuFeLWY7CHrWQqo0eZ/g0" +
       "OnLtKbnkgasfBeM6LI3HHUNtWzSCGd6qgdRFmNcgvKPkm3qs5uMqX3YLFQOh" +
       "5n1xXdGqyrJpDWSC96KlXCdJdZRUSqhZRJBRSzcxd27Y5txaxSW3tKyWZzBk" +
       "jZsMWiZZjyXbzarMIr0JXCp1kVCMRgscK1MFRahxjUgujqYIr5b6lWEt78gD" +
       "zqSpxWJQwUVe5DzWqTiyXpqQllUUIs4IylNv3W1hViKvyai3kplJAaiL2wRR" +
       "ZHHsUebaHmoojqoRyWq+j7BTHkiZwMjqzDV6NoX0CkDGVlQt0zPBjVpLWVl2" +
       "GJUzTJPuW/hI0KrReDaTe3QpQuBZBSfpzqwdUMDymZO+LxrDuerNO11KVwW1" +
       "WyH9jtoRRXVYZctNPyhSrLG0uoK27PPN3qrlMr3A4rptVMcHDNX3yiUItVfc" +
       "aoW4/aRBQHVG52G6UBmVkeownHVIDYuXcHXSJ1tUt4hrq7UfGZMaUaJpaToc" +
       "0J3+tGf4cL8fyRaXtGZeu1QJpiRe6HEU6nFTalAj6bw+GUfTSmugrDgIEqpK" +
       "UuBiGCrBZSAgXAvmRFQrWPOwOFJYlSwXq1UkoCtsqwb8bMP2W/iwyhSIcn6M" +
       "wW61QbqDVq9YCENgKCMVWA3PqOJtmGjWfJ6BehIyjjuDUAUx6AIZragSNJur" +
       "MeWLdXdoCC7ZRol1szHuAucdCHmriA1oPgqdeZeBKvlWUZyDlQc+M8uuh9Ns" +
       "HWoysWSx8IQgK424PNHMcUco4PMihXakIPGXEMNATBdifKloVeh5hAQBvE66" +
       "VbY6pqilp6FIC8uPSbpSLMiMMazR6HpsVT22CTpS22IRhqp5tpuUMHqw8qk5" +
       "REKdxBrGHKnEhXI16UqhMLHJCbzGCRvNK2hpypT6lDQPq1LTtordmFcbeDiQ" +
       "BAyfzgYchHRczGkhsr4IxS7bNkyYmRj2qD/Mt0blVTCz/CbJgvbrktypF1wU" +
       "HagYa3d7WLMKhl7VB5WRaiJ5qTSv9Zwxu6gVTBAwsTFMlTC+s+CpsuMsnSoO" +
       "jZuKrfBDXG2A8C1cJnC9PJKb8z7foWCThkNMpVpDh25S7SE8hyJM7TboqGNH" +
       "5coaRetRPU/UtfKQX454irFQMwrhWOASfSQuHE5LVBB+om44YAfQoBQCdzBi" +
       "4/psYbWSqF+i2KLYnK3KjIpHxS6O68mY9NERROizMdB3RSeHfs/QWxSqdPsF" +
       "O8/U6Amd+CQcr6Rpvab5HKSbRh6KSqWa1p+w1aZBO625y5RHbt6qQwhM4EHB" +
       "LRZoW2txUKvoDfpyR4OnvQnd9n1Cr1ZLLbJaqSeTelEVVR6VNdbAOWrQgN3m" +
       "bNnp4UjbbKxZpBo7gTWz0I69LlcKZbSedPOtGeCtmxwL6ShWRpIe4tjwbFWE" +
       "iJFp0VN+BdY90UonujSnCTbZmazLjLVUCkUmnOFQ21/XJzQXqHJ9KFmEFyEo" +
       "XU5F2eeX0hgNCvMB0DTFISC63Zi0i2MEr4P1CRE58LDhTDAXrJrUVlNRvKaW" +
       "H4mlYBqFkhmWVlF9zkAlpdiUXFFEK9WuFdaGRo+vFvszUW8tiMAuQigcJfVa" +
       "bQ7a6JPkusVESDXUxXncbzqsVILZpKXPG2YTKQ6QQqOK+dhsypNrjCb45ZJo" +
       "UW18AqKX5bBQGjK0QPLqoo/Nq3B3wGvd+Yybx/Ox6McCbK95i2UJAm8pHOzH" +
       "9f66OiKlgcSMCpRDzBasO9dxqaGMxFrT");
    public static final java.lang.String jlc$ClassType$jl5$1 =
      ("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" +
       "Vff/AUjsqMliSgAA");
}
