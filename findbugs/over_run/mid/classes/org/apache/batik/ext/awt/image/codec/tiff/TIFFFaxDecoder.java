package org.apache.batik.ext.awt.image.codec.tiff;
class TIFFFaxDecoder {
    private int bitPointer;
    private int bytePointer;
    private byte[] data;
    private int w;
    private int h;
    private int fillOrder;
    private int changingElemSize = 0;
    private int[] prevChangingElems;
    private int[] currChangingElems;
    private int lastChangingElement = 0;
    private int compression = 2;
    private int uncompressedMode = 0;
    private int fillBits = 0;
    private int oneD;
    static int[] table1 = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };
    static int[] table2 = { 0, 128, 192, 224, 240, 248, 252, 254, 255 };
    static byte[] flipTable = { 0, -128, 64, -64, 32, -96, 96, -32, 16, -112,
    80,
    -48,
    48,
    -80,
    112,
    -16,
    8,
    -120,
    72,
    -56,
    40,
    -88,
    104,
    -24,
    24,
    -104,
    88,
    -40,
    56,
    -72,
    120,
    -8,
    4,
    -124,
    68,
    -60,
    36,
    -92,
    100,
    -28,
    20,
    -108,
    84,
    -44,
    52,
    -76,
    116,
    -12,
    12,
    -116,
    76,
    -52,
    44,
    -84,
    108,
    -20,
    28,
    -100,
    92,
    -36,
    60,
    -68,
    124,
    -4,
    2,
    -126,
    66,
    -62,
    34,
    -94,
    98,
    -30,
    18,
    -110,
    82,
    -46,
    50,
    -78,
    114,
    -14,
    10,
    -118,
    74,
    -54,
    42,
    -86,
    106,
    -22,
    26,
    -102,
    90,
    -38,
    58,
    -70,
    122,
    -6,
    6,
    -122,
    70,
    -58,
    38,
    -90,
    102,
    -26,
    22,
    -106,
    86,
    -42,
    54,
    -74,
    118,
    -10,
    14,
    -114,
    78,
    -50,
    46,
    -82,
    110,
    -18,
    30,
    -98,
    94,
    -34,
    62,
    -66,
    126,
    -2,
    1,
    -127,
    65,
    -63,
    33,
    -95,
    97,
    -31,
    17,
    -111,
    81,
    -47,
    49,
    -79,
    113,
    -15,
    9,
    -119,
    73,
    -55,
    41,
    -87,
    105,
    -23,
    25,
    -103,
    89,
    -39,
    57,
    -71,
    121,
    -7,
    5,
    -123,
    69,
    -59,
    37,
    -91,
    101,
    -27,
    21,
    -107,
    85,
    -43,
    53,
    -75,
    117,
    -11,
    13,
    -115,
    77,
    -51,
    45,
    -83,
    109,
    -19,
    29,
    -99,
    93,
    -35,
    61,
    -67,
    125,
    -3,
    3,
    -125,
    67,
    -61,
    35,
    -93,
    99,
    -29,
    19,
    -109,
    83,
    -45,
    51,
    -77,
    115,
    -13,
    11,
    -117,
    75,
    -53,
    43,
    -85,
    107,
    -21,
    27,
    -101,
    91,
    -37,
    59,
    -69,
    123,
    -5,
    7,
    -121,
    71,
    -57,
    39,
    -89,
    103,
    -25,
    23,
    -105,
    87,
    -41,
    55,
    -73,
    119,
    -9,
    15,
    -113,
    79,
    -49,
    47,
    -81,
    111,
    -17,
    31,
    -97,
    95,
    -33,
    63,
    -65,
    127,
    -1 };
    static short[] white = { 6430, 6400, 6400, 6400, 3225, 3225, 3225, 3225,
    944,
    944,
    944,
    944,
    976,
    976,
    976,
    976,
    1456,
    1456,
    1456,
    1456,
    1488,
    1488,
    1488,
    1488,
    718,
    718,
    718,
    718,
    718,
    718,
    718,
    718,
    750,
    750,
    750,
    750,
    750,
    750,
    750,
    750,
    1520,
    1520,
    1520,
    1520,
    1552,
    1552,
    1552,
    1552,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    654,
    654,
    654,
    654,
    654,
    654,
    654,
    654,
    1072,
    1072,
    1072,
    1072,
    1104,
    1104,
    1104,
    1104,
    1136,
    1136,
    1136,
    1136,
    1168,
    1168,
    1168,
    1168,
    1200,
    1200,
    1200,
    1200,
    1232,
    1232,
    1232,
    1232,
    622,
    622,
    622,
    622,
    622,
    622,
    622,
    622,
    1008,
    1008,
    1008,
    1008,
    1040,
    1040,
    1040,
    1040,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    1712,
    1712,
    1712,
    1712,
    1744,
    1744,
    1744,
    1744,
    846,
    846,
    846,
    846,
    846,
    846,
    846,
    846,
    1264,
    1264,
    1264,
    1264,
    1296,
    1296,
    1296,
    1296,
    1328,
    1328,
    1328,
    1328,
    1360,
    1360,
    1360,
    1360,
    1392,
    1392,
    1392,
    1392,
    1424,
    1424,
    1424,
    1424,
    686,
    686,
    686,
    686,
    686,
    686,
    686,
    686,
    910,
    910,
    910,
    910,
    910,
    910,
    910,
    910,
    1968,
    1968,
    1968,
    1968,
    2000,
    2000,
    2000,
    2000,
    2032,
    2032,
    2032,
    2032,
    16,
    16,
    16,
    16,
    10257,
    10257,
    10257,
    10257,
    12305,
    12305,
    12305,
    12305,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    878,
    878,
    878,
    878,
    878,
    878,
    878,
    878,
    1904,
    1904,
    1904,
    1904,
    1936,
    1936,
    1936,
    1936,
    -18413,
    -18413,
    -16365,
    -16365,
    -14317,
    -14317,
    -10221,
    -10221,
    590,
    590,
    590,
    590,
    590,
    590,
    590,
    590,
    782,
    782,
    782,
    782,
    782,
    782,
    782,
    782,
    1584,
    1584,
    1584,
    1584,
    1616,
    1616,
    1616,
    1616,
    1648,
    1648,
    1648,
    1648,
    1680,
    1680,
    1680,
    1680,
    814,
    814,
    814,
    814,
    814,
    814,
    814,
    814,
    1776,
    1776,
    1776,
    1776,
    1808,
    1808,
    1808,
    1808,
    1840,
    1840,
    1840,
    1840,
    1872,
    1872,
    1872,
    1872,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    14353,
    14353,
    14353,
    14353,
    16401,
    16401,
    16401,
    16401,
    22547,
    22547,
    24595,
    24595,
    20497,
    20497,
    20497,
    20497,
    18449,
    18449,
    18449,
    18449,
    26643,
    26643,
    28691,
    28691,
    30739,
    30739,
    -32749,
    -32749,
    -30701,
    -30701,
    -28653,
    -28653,
    -26605,
    -26605,
    -24557,
    -24557,
    -22509,
    -22509,
    -20461,
    -20461,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232 };
    static short[] additionalMakeup = { 28679, 28679, 31752, (short) 32777,
    (short)
      33801,
    (short)
      34825,
    (short)
      35849,
    (short)
      36873,
    (short)
      29703,
    (short)
      29703,
    (short)
      30727,
    (short)
      30727,
    (short)
      37897,
    (short)
      38921,
    (short)
      39945,
    (short)
      40969 };
    static short[] initBlack = { 3226, 6412, 200, 168, 38, 38, 134, 134, 100,
    100,
    100,
    100,
    68,
    68,
    68,
    68 };
    static short[] twoBitBlack = { 292, 260, 226, 226 };
    static short[] black = { 62, 62, 30, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    588,
    588,
    588,
    588,
    588,
    588,
    588,
    588,
    1680,
    1680,
    20499,
    22547,
    24595,
    26643,
    1776,
    1776,
    1808,
    1808,
    -24557,
    -22509,
    -20461,
    -18413,
    1904,
    1904,
    1936,
    1936,
    -16365,
    -14317,
    782,
    782,
    782,
    782,
    814,
    814,
    814,
    814,
    -12269,
    -10221,
    10257,
    10257,
    12305,
    12305,
    14353,
    14353,
    16403,
    18451,
    1712,
    1712,
    1744,
    1744,
    28691,
    30739,
    -32749,
    -30701,
    -28653,
    -26605,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    750,
    750,
    750,
    750,
    1616,
    1616,
    1648,
    1648,
    1424,
    1424,
    1456,
    1456,
    1488,
    1488,
    1520,
    1520,
    1840,
    1840,
    1872,
    1872,
    1968,
    1968,
    8209,
    8209,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    1552,
    1552,
    1584,
    1584,
    2000,
    2000,
    2032,
    2032,
    976,
    976,
    1008,
    1008,
    1040,
    1040,
    1072,
    1072,
    1296,
    1296,
    1328,
    1328,
    718,
    718,
    718,
    718,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    4113,
    4113,
    6161,
    6161,
    848,
    848,
    880,
    880,
    912,
    912,
    944,
    944,
    622,
    622,
    622,
    622,
    654,
    654,
    654,
    654,
    1104,
    1104,
    1136,
    1136,
    1168,
    1168,
    1200,
    1200,
    1232,
    1232,
    1264,
    1264,
    686,
    686,
    686,
    686,
    1360,
    1360,
    1392,
    1392,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390 };
    static byte[] twoDCodes = { 80, 88, 23, 71, 30, 30, 62, 62, 4, 4, 4, 4,
    4,
    4,
    4,
    4,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41 };
    public TIFFFaxDecoder(int fillOrder, int w, int h) { super();
                                                         this.fillOrder =
                                                           fillOrder;
                                                         this.w = w;
                                                         this.h = h;
                                                         this.bitPointer =
                                                           0;
                                                         this.bytePointer =
                                                           0;
                                                         this.prevChangingElems =
                                                           (new int[w]);
                                                         this.currChangingElems =
                                                           (new int[w]);
    }
    public void decode1D(byte[] buffer, byte[] compData, int startX,
                         int height) { this.data = compData;
                                       int lineOffset = 0;
                                       int scanlineStride =
                                         (w +
                                            7) /
                                         8;
                                       bitPointer = 0;
                                       bytePointer = 0;
                                       for (int i = 0; i <
                                                         height;
                                            i++) { decodeNextScanline(
                                                     buffer,
                                                     lineOffset,
                                                     startX);
                                                   lineOffset +=
                                                     scanlineStride;
                                       } }
    public void decodeNextScanline(byte[] buffer, int lineOffset,
                                   int bitOffset) { int bits =
                                                      0;
                                                    int code =
                                                      0;
                                                    int isT =
                                                      0;
                                                    int current;
                                                    int entry;
                                                    int twoBits;
                                                    boolean isWhite =
                                                      true;
                                                    changingElemSize =
                                                      0;
                                                    while (bitOffset <
                                                             w) {
                                                        while (isWhite) {
                                                            current =
                                                              nextNBits(
                                                                10);
                                                            entry =
                                                              white[current];
                                                            isT =
                                                              entry &
                                                                1;
                                                            bits =
                                                              entry >>>
                                                                1 &
                                                                15;
                                                            if (bits ==
                                                                  12) {
                                                                twoBits =
                                                                  nextLesserThan8Bits(
                                                                    2);
                                                                current =
                                                                  current <<
                                                                    2 &
                                                                    12 |
                                                                    twoBits;
                                                                entry =
                                                                  additionalMakeup[current];
                                                                bits =
                                                                  entry >>>
                                                                    1 &
                                                                    7;
                                                                code =
                                                                  entry >>>
                                                                    4 &
                                                                    4095;
                                                                bitOffset +=
                                                                  code;
                                                                updatePointer(
                                                                  4 -
                                                                    bits);
                                                            }
                                                            else
                                                                if (bits ==
                                                                      0) {
                                                                    throw new java.lang.Error(
                                                                      "TIFFFaxDecoder0");
                                                                }
                                                                else
                                                                    if (bits ==
                                                                          15) {
                                                                        throw new java.lang.Error(
                                                                          "TIFFFaxDecoder1");
                                                                    }
                                                                    else {
                                                                        code =
                                                                          entry >>>
                                                                            5 &
                                                                            2047;
                                                                        bitOffset +=
                                                                          code;
                                                                        updatePointer(
                                                                          10 -
                                                                            bits);
                                                                        if (isT ==
                                                                              0) {
                                                                            isWhite =
                                                                              false;
                                                                            currChangingElems[changingElemSize++] =
                                                                              bitOffset;
                                                                        }
                                                                    }
                                                        }
                                                        if (bitOffset ==
                                                              w) {
                                                            if (compression ==
                                                                  2) {
                                                                advancePointer(
                                                                  );
                                                            }
                                                            break;
                                                        }
                                                        while (!isWhite) {
                                                            current =
                                                              nextLesserThan8Bits(
                                                                4);
                                                            entry =
                                                              initBlack[current];
                                                            isT =
                                                              entry &
                                                                1;
                                                            bits =
                                                              entry >>>
                                                                1 &
                                                                15;
                                                            code =
                                                              entry >>>
                                                                5 &
                                                                2047;
                                                            if (code ==
                                                                  100) {
                                                                current =
                                                                  nextNBits(
                                                                    9);
                                                                entry =
                                                                  black[current];
                                                                isT =
                                                                  entry &
                                                                    1;
                                                                bits =
                                                                  entry >>>
                                                                    1 &
                                                                    15;
                                                                code =
                                                                  entry >>>
                                                                    5 &
                                                                    2047;
                                                                if (bits ==
                                                                      12) {
                                                                    updatePointer(
                                                                      5);
                                                                    current =
                                                                      nextLesserThan8Bits(
                                                                        4);
                                                                    entry =
                                                                      additionalMakeup[current];
                                                                    bits =
                                                                      entry >>>
                                                                        1 &
                                                                        7;
                                                                    code =
                                                                      entry >>>
                                                                        4 &
                                                                        4095;
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      4 -
                                                                        bits);
                                                                }
                                                                else
                                                                    if (bits ==
                                                                          15) {
                                                                        throw new java.lang.Error(
                                                                          "TIFFFaxDecoder2");
                                                                    }
                                                                    else {
                                                                        setToBlack(
                                                                          buffer,
                                                                          lineOffset,
                                                                          bitOffset,
                                                                          code);
                                                                        bitOffset +=
                                                                          code;
                                                                        updatePointer(
                                                                          9 -
                                                                            bits);
                                                                        if (isT ==
                                                                              0) {
                                                                            isWhite =
                                                                              true;
                                                                            currChangingElems[changingElemSize++] =
                                                                              bitOffset;
                                                                        }
                                                                    }
                                                            }
                                                            else
                                                                if (code ==
                                                                      200) {
                                                                    current =
                                                                      nextLesserThan8Bits(
                                                                        2);
                                                                    entry =
                                                                      twoBitBlack[current];
                                                                    code =
                                                                      entry >>>
                                                                        5 &
                                                                        2047;
                                                                    bits =
                                                                      entry >>>
                                                                        1 &
                                                                        15;
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      2 -
                                                                        bits);
                                                                    isWhite =
                                                                      true;
                                                                    currChangingElems[changingElemSize++] =
                                                                      bitOffset;
                                                                }
                                                                else {
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      4 -
                                                                        bits);
                                                                    isWhite =
                                                                      true;
                                                                    currChangingElems[changingElemSize++] =
                                                                      bitOffset;
                                                                }
                                                        }
                                                        if (bitOffset ==
                                                              w) {
                                                            if (compression ==
                                                                  2) {
                                                                advancePointer(
                                                                  );
                                                            }
                                                            break;
                                                        }
                                                    }
                                                    currChangingElems[changingElemSize++] =
                                                      bitOffset;
    }
    public void decode2D(byte[] buffer, byte[] compData,
                         int startX,
                         int height,
                         long tiffT4Options) {
        this.
          data =
          compData;
        compression =
          3;
        bitPointer =
          0;
        bytePointer =
          0;
        int scanlineStride =
          (w +
             7) /
          8;
        int a0;
        int a1;
        int b1;
        int b2;
        int[] b =
          new int[2];
        int entry;
        int code;
        int bits;
        boolean isWhite;
        int currIndex =
          0;
        int[] temp;
        oneD =
          (int)
            (tiffT4Options &
               1);
        uncompressedMode =
          (int)
            ((tiffT4Options &
                2) >>
               1);
        fillBits =
          (int)
            ((tiffT4Options &
                4) >>
               2);
        if (readEOL(
              ) !=
              1) {
            throw new java.lang.Error(
              "TIFFFaxDecoder3");
        }
        int lineOffset =
          0;
        int bitOffset;
        decodeNextScanline(
          buffer,
          lineOffset,
          startX);
        lineOffset +=
          scanlineStride;
        for (int lines =
               1;
             lines <
               height;
             lines++) {
            if (readEOL(
                  ) ==
                  0) {
                temp =
                  prevChangingElems;
                prevChangingElems =
                  currChangingElems;
                currChangingElems =
                  temp;
                currIndex =
                  0;
                a0 =
                  -1;
                isWhite =
                  true;
                bitOffset =
                  startX;
                lastChangingElement =
                  0;
                while (bitOffset <
                         w) {
                    getNextChangingElement(
                      a0,
                      isWhite,
                      b);
                    b1 =
                      b[0];
                    b2 =
                      b[1];
                    entry =
                      nextLesserThan8Bits(
                        7);
                    entry =
                      (int)
                        (twoDCodes[entry] &
                           255);
                    code =
                      (entry &
                         120) >>>
                        3;
                    bits =
                      entry &
                        7;
                    if (code ==
                          0) {
                        if (!isWhite) {
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              b2 -
                                bitOffset);
                        }
                        bitOffset =
                          (a0 =
                             b2);
                        updatePointer(
                          7 -
                            bits);
                    }
                    else
                        if (code ==
                              1) {
                            updatePointer(
                              7 -
                                bits);
                            int number;
                            if (isWhite) {
                                number =
                                  decodeWhiteCodeWord(
                                    );
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                                number =
                                  decodeBlackCodeWord(
                                    );
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  number);
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                            }
                            else {
                                number =
                                  decodeBlackCodeWord(
                                    );
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  number);
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                                number =
                                  decodeWhiteCodeWord(
                                    );
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                            }
                            a0 =
                              bitOffset;
                        }
                        else
                            if (code <=
                                  8) {
                                a1 =
                                  b1 +
                                    (code -
                                       5);
                                currChangingElems[currIndex++] =
                                  a1;
                                if (!isWhite) {
                                    setToBlack(
                                      buffer,
                                      lineOffset,
                                      bitOffset,
                                      a1 -
                                        bitOffset);
                                }
                                bitOffset =
                                  (a0 =
                                     a1);
                                isWhite =
                                  !isWhite;
                                updatePointer(
                                  7 -
                                    bits);
                            }
                            else {
                                throw new java.lang.Error(
                                  "TIFFFaxDecoder4");
                            }
                }
                currChangingElems[currIndex++] =
                  bitOffset;
                changingElemSize =
                  currIndex;
            }
            else {
                decodeNextScanline(
                  buffer,
                  lineOffset,
                  startX);
            }
            lineOffset +=
              scanlineStride;
        }
    }
    public synchronized void decodeT6(byte[] buffer,
                                      byte[] compData,
                                      int startX,
                                      int height,
                                      long tiffT6Options) {
        this.
          data =
          compData;
        compression =
          4;
        bitPointer =
          0;
        bytePointer =
          0;
        int scanlineStride =
          (w +
             7) /
          8;
        int a0;
        int a1;
        int b1;
        int b2;
        int entry;
        int code;
        int bits;
        boolean isWhite;
        int currIndex;
        int[] temp;
        int[] b =
          new int[2];
        uncompressedMode =
          (int)
            ((tiffT6Options &
                2) >>
               1);
        int[] cce =
          currChangingElems;
        changingElemSize =
          0;
        cce[changingElemSize++] =
          w;
        cce[changingElemSize++] =
          w;
        int lineOffset =
          0;
        int bitOffset;
        for (int lines =
               0;
             lines <
               height;
             lines++) {
            a0 =
              -1;
            isWhite =
              true;
            temp =
              prevChangingElems;
            prevChangingElems =
              currChangingElems;
            cce =
              (currChangingElems =
                 temp);
            currIndex =
              0;
            bitOffset =
              startX;
            lastChangingElement =
              0;
            while (bitOffset <
                     w) {
                getNextChangingElement(
                  a0,
                  isWhite,
                  b);
                b1 =
                  b[0];
                b2 =
                  b[1];
                entry =
                  nextLesserThan8Bits(
                    7);
                entry =
                  (int)
                    (twoDCodes[entry] &
                       255);
                code =
                  (entry &
                     120) >>>
                    3;
                bits =
                  entry &
                    7;
                if (code ==
                      0) {
                    if (!isWhite) {
                        setToBlack(
                          buffer,
                          lineOffset,
                          bitOffset,
                          b2 -
                            bitOffset);
                    }
                    bitOffset =
                      (a0 =
                         b2);
                    updatePointer(
                      7 -
                        bits);
                }
                else
                    if (code ==
                          1) {
                        updatePointer(
                          7 -
                            bits);
                        int number;
                        if (isWhite) {
                            number =
                              decodeWhiteCodeWord(
                                );
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                            number =
                              decodeBlackCodeWord(
                                );
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              number);
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                        }
                        else {
                            number =
                              decodeBlackCodeWord(
                                );
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              number);
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                            number =
                              decodeWhiteCodeWord(
                                );
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                        }
                        a0 =
                          bitOffset;
                    }
                    else
                        if (code <=
                              8) {
                            a1 =
                              b1 +
                                (code -
                                   5);
                            cce[currIndex++] =
                              a1;
                            if (!isWhite) {
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  a1 -
                                    bitOffset);
                            }
                            bitOffset =
                              (a0 =
                                 a1);
                            isWhite =
                              !isWhite;
                            updatePointer(
                              7 -
                                bits);
                        }
                        else
                            if (code ==
                                  11) {
                                if (nextLesserThan8Bits(
                                      3) !=
                                      7) {
                                    throw new java.lang.Error(
                                      "TIFFFaxDecoder5");
                                }
                                int zeros =
                                  0;
                                boolean exit =
                                  false;
                                while (!exit) {
                                    while (nextLesserThan8Bits(
                                             1) !=
                                             1) {
                                        zeros++;
                                    }
                                    if (zeros >
                                          5) {
                                        zeros =
                                          zeros -
                                            6;
                                        if (!isWhite &&
                                              zeros >
                                              0) {
                                            cce[currIndex++] =
                                              bitOffset;
                                        }
                                        bitOffset +=
                                          zeros;
                                        if (zeros >
                                              0) {
                                            isWhite =
                                              true;
                                        }
                                        if (nextLesserThan8Bits(
                                              1) ==
                                              0) {
                                            if (!isWhite) {
                                                cce[currIndex++] =
                                                  bitOffset;
                                            }
                                            isWhite =
                                              true;
                                        }
                                        else {
                                            if (isWhite) {
                                                cce[currIndex++] =
                                                  bitOffset;
                                            }
                                            isWhite =
                                              false;
                                        }
                                        exit =
                                          true;
                                    }
                                    if (zeros ==
                                          5) {
                                        if (!isWhite) {
                                            cce[currIndex++] =
                                              bitOffset;
                                        }
                                        bitOffset +=
                                          zeros;
                                        isWhite =
                                          true;
                                    }
                                    else {
                                        bitOffset +=
                                          zeros;
                                        cce[currIndex++] =
                                          bitOffset;
                                        setToBlack(
                                          buffer,
                                          lineOffset,
                                          bitOffset,
                                          1);
                                        ++bitOffset;
                                        isWhite =
                                          false;
                                    }
                                }
                            }
                            else {
                                throw new java.lang.Error(
                                  "TIFFFaxDecoder5");
                            }
            }
            cce[currIndex++] =
              bitOffset;
            changingElemSize =
              currIndex;
            lineOffset +=
              scanlineStride;
        }
    }
    private void setToBlack(byte[] buffer,
                            int lineOffset,
                            int bitOffset,
                            int numBits) {
        int bitNum =
          8 *
          lineOffset +
          bitOffset;
        int lastBit =
          bitNum +
          numBits;
        int byteNum =
          bitNum >>
          3;
        int shift =
          bitNum &
          7;
        if (shift >
              0) {
            int maskVal =
              1 <<
              7 -
              shift;
            byte val =
              buffer[byteNum];
            while (maskVal >
                     0 &&
                     bitNum <
                     lastBit) {
                val |=
                  maskVal;
                maskVal >>=
                  1;
                ++bitNum;
            }
            buffer[byteNum] =
              val;
        }
        byteNum =
          bitNum >>
            3;
        while (bitNum <
                 lastBit -
                 7) {
            buffer[byteNum++] =
              (byte)
                255;
            bitNum +=
              8;
        }
        while (bitNum <
                 lastBit) {
            byteNum =
              bitNum >>
                3;
            buffer[byteNum] |=
              1 <<
                7 -
                (bitNum &
                   7);
            ++bitNum;
        }
    }
    private int decodeWhiteCodeWord() { int current;
                                        int entry;
                                        int bits;
                                        int isT;
                                        int twoBits;
                                        int code =
                                          -1;
                                        int runLength =
                                          0;
                                        boolean isWhite =
                                          true;
                                        while (isWhite) {
                                            current =
                                              nextNBits(
                                                10);
                                            entry =
                                              white[current];
                                            isT =
                                              entry &
                                                1;
                                            bits =
                                              entry >>>
                                                1 &
                                                15;
                                            if (bits ==
                                                  12) {
                                                twoBits =
                                                  nextLesserThan8Bits(
                                                    2);
                                                current =
                                                  current <<
                                                    2 &
                                                    12 |
                                                    twoBits;
                                                entry =
                                                  additionalMakeup[current];
                                                bits =
                                                  entry >>>
                                                    1 &
                                                    7;
                                                code =
                                                  entry >>>
                                                    4 &
                                                    4095;
                                                runLength +=
                                                  code;
                                                updatePointer(
                                                  4 -
                                                    bits);
                                            }
                                            else
                                                if (bits ==
                                                      0) {
                                                    throw new java.lang.Error(
                                                      "TIFFFaxDecoder0");
                                                }
                                                else
                                                    if (bits ==
                                                          15) {
                                                        throw new java.lang.Error(
                                                          "TIFFFaxDecoder1");
                                                    }
                                                    else {
                                                        code =
                                                          entry >>>
                                                            5 &
                                                            2047;
                                                        runLength +=
                                                          code;
                                                        updatePointer(
                                                          10 -
                                                            bits);
                                                        if (isT ==
                                                              0) {
                                                            isWhite =
                                                              false;
                                                        }
                                                    }
                                        }
                                        return runLength;
    }
    private int decodeBlackCodeWord() { int current;
                                        int entry;
                                        int bits;
                                        int isT;
                                        int code =
                                          -1;
                                        int runLength =
                                          0;
                                        boolean isWhite =
                                          false;
                                        while (!isWhite) {
                                            current =
                                              nextLesserThan8Bits(
                                                4);
                                            entry =
                                              initBlack[current];
                                            isT =
                                              entry &
                                                1;
                                            bits =
                                              entry >>>
                                                1 &
                                                15;
                                            code =
                                              entry >>>
                                                5 &
                                                2047;
                                            if (code ==
                                                  100) {
                                                current =
                                                  nextNBits(
                                                    9);
                                                entry =
                                                  black[current];
                                                isT =
                                                  entry &
                                                    1;
                                                bits =
                                                  entry >>>
                                                    1 &
                                                    15;
                                                code =
                                                  entry >>>
                                                    5 &
                                                    2047;
                                                if (bits ==
                                                      12) {
                                                    updatePointer(
                                                      5);
                                                    current =
                                                      nextLesserThan8Bits(
                                                        4);
                                                    entry =
                                                      additionalMakeup[current];
                                                    bits =
                                                      entry >>>
                                                        1 &
                                                        7;
                                                    code =
                                                      entry >>>
                                                        4 &
                                                        4095;
                                                    runLength +=
                                                      code;
                                                    updatePointer(
                                                      4 -
                                                        bits);
                                                }
                                                else
                                                    if (bits ==
                                                          15) {
                                                        throw new java.lang.Error(
                                                          "TIFFFaxDecoder2");
                                                    }
                                                    else {
                                                        runLength +=
                                                          code;
                                                        updatePointer(
                                                          9 -
                                                            bits);
                                                        if (isT ==
                                                              0) {
                                                            isWhite =
                                                              true;
                                                        }
                                                    }
                                            }
                                            else
                                                if (code ==
                                                      200) {
                                                    current =
                                                      nextLesserThan8Bits(
                                                        2);
                                                    entry =
                                                      twoBitBlack[current];
                                                    code =
                                                      entry >>>
                                                        5 &
                                                        2047;
                                                    runLength +=
                                                      code;
                                                    bits =
                                                      entry >>>
                                                        1 &
                                                        15;
                                                    updatePointer(
                                                      2 -
                                                        bits);
                                                    isWhite =
                                                      true;
                                                }
                                                else {
                                                    runLength +=
                                                      code;
                                                    updatePointer(
                                                      4 -
                                                        bits);
                                                    isWhite =
                                                      true;
                                                }
                                        }
                                        return runLength;
    }
    private int readEOL() { if (fillBits ==
                                  0) { if (nextNBits(
                                             12) !=
                                             1) {
                                           throw new java.lang.Error(
                                             "TIFFFaxDecoder6");
                                       } }
                            else
                                if (fillBits ==
                                      1) {
                                    int bitsLeft =
                                      8 -
                                      bitPointer;
                                    if (nextNBits(
                                          bitsLeft) !=
                                          0) {
                                        throw new java.lang.Error(
                                          "TIFFFaxDecoder8");
                                    }
                                    if (bitsLeft <
                                          4) {
                                        if (nextNBits(
                                              8) !=
                                              0) {
                                            throw new java.lang.Error(
                                              "TIFFFaxDecoder8");
                                        }
                                    }
                                    int n;
                                    while ((n =
                                              nextNBits(
                                                8)) !=
                                             1) {
                                        if (n !=
                                              0) {
                                            throw new java.lang.Error(
                                              "TIFFFaxDecoder8");
                                        }
                                    }
                                }
                            if (oneD == 0) {
                                return 1;
                            }
                            else {
                                return nextLesserThan8Bits(
                                         1);
                            } }
    private void getNextChangingElement(int a0,
                                        boolean isWhite,
                                        int[] ret) {
        int[] pce =
          this.
            prevChangingElems;
        int ces =
          this.
            changingElemSize;
        int start =
          lastChangingElement >
          0
          ? lastChangingElement -
          1
          : 0;
        if (isWhite) {
            start &=
              ~1;
        }
        else {
            start |=
              1;
        }
        int i =
          start;
        for (;
             i <
               ces;
             i +=
               2) {
            int temp =
              pce[i];
            if (temp >
                  a0) {
                lastChangingElement =
                  i;
                ret[0] =
                  temp;
                break;
            }
        }
        if (i +
              1 <
              ces) {
            ret[1] =
              pce[i +
                    1];
        }
    }
    private int nextNBits(int bitsToGet) {
        byte b;
        byte next;
        byte next2next;
        int l =
          data.
            length -
          1;
        int bp =
          this.
            bytePointer;
        if (fillOrder ==
              1) {
            b =
              data[bp];
            if (bp ==
                  l) {
                next =
                  0;
                next2next =
                  0;
            }
            else
                if (bp +
                      1 ==
                      l) {
                    next =
                      data[bp +
                             1];
                    next2next =
                      0;
                }
                else {
                    next =
                      data[bp +
                             1];
                    next2next =
                      data[bp +
                             2];
                }
        }
        else
            if (fillOrder ==
                  2) {
                b =
                  flipTable[data[bp] &
                              255];
                if (bp ==
                      l) {
                    next =
                      0;
                    next2next =
                      0;
                }
                else
                    if (bp +
                          1 ==
                          l) {
                        next =
                          flipTable[data[bp +
                                           1] &
                                      255];
                        next2next =
                          0;
                    }
                    else {
                        next =
                          flipTable[data[bp +
                                           1] &
                                      255];
                        next2next =
                          flipTable[data[bp +
                                           2] &
                                      255];
                    }
            }
            else {
                throw new java.lang.Error(
                  "TIFFFaxDecoder7");
            }
        int bitsLeft =
          8 -
          bitPointer;
        int bitsFromNextByte =
          bitsToGet -
          bitsLeft;
        int bitsFromNext2NextByte =
          0;
        if (bitsFromNextByte >
              8) {
            bitsFromNext2NextByte =
              bitsFromNextByte -
                8;
            bitsFromNextByte =
              8;
        }
        bytePointer++;
        int i1 =
          (b &
             table1[bitsLeft]) <<
          bitsToGet -
          bitsLeft;
        int i2 =
          (next &
             table2[bitsFromNextByte]) >>>
          8 -
          bitsFromNextByte;
        int i3 =
          0;
        if (bitsFromNext2NextByte !=
              0) {
            i2 <<=
              bitsFromNext2NextByte;
            i3 =
              (next2next &
                 table2[bitsFromNext2NextByte]) >>>
                8 -
                bitsFromNext2NextByte;
            i2 |=
              i3;
            bytePointer++;
            bitPointer =
              bitsFromNext2NextByte;
        }
        else {
            if (bitsFromNextByte ==
                  8) {
                bitPointer =
                  0;
                bytePointer++;
            }
            else {
                bitPointer =
                  bitsFromNextByte;
            }
        }
        int i =
          i1 |
          i2;
        return i;
    }
    private int nextLesserThan8Bits(int bitsToGet) {
        byte b;
        byte next;
        int l =
          data.
            length -
          1;
        int bp =
          this.
            bytePointer;
        if (fillOrder ==
              1) {
            b =
              data[bp];
            if (bp ==
                  l) {
                next =
                  0;
            }
            else {
                next =
                  data[bp +
                         1];
            }
        }
        else
            if (fillOrder ==
                  2) {
                b =
                  flipTable[data[bp] &
                              255];
                if (bp ==
                      l) {
                    next =
                      0;
                }
                else {
                    next =
                      flipTable[data[bp +
                                       1] &
                                  255];
                }
            }
            else {
                throw new java.lang.Error(
                  "TIFFFaxDecoder7");
            }
        int bitsLeft =
          8 -
          bitPointer;
        int bitsFromNextByte =
          bitsToGet -
          bitsLeft;
        int shift =
          bitsLeft -
          bitsToGet;
        int i1;
        int i2;
        if (shift >=
              0) {
            i1 =
              (b &
                 table1[bitsLeft]) >>>
                shift;
            bitPointer +=
              bitsToGet;
            if (bitPointer ==
                  8) {
                bitPointer =
                  0;
                bytePointer++;
            }
        }
        else {
            i1 =
              (b &
                 table1[bitsLeft]) <<
                -shift;
            i2 =
              (next &
                 table2[bitsFromNextByte]) >>>
                8 -
                bitsFromNextByte;
            i1 |=
              i2;
            bytePointer++;
            bitPointer =
              bitsFromNextByte;
        }
        return i1;
    }
    private void updatePointer(int bitsToMoveBack) {
        int i =
          bitPointer -
          bitsToMoveBack;
        if (i <
              0) {
            bytePointer--;
            bitPointer =
              8 +
                i;
        }
        else {
            bitPointer =
              i;
        }
    }
    private boolean advancePointer() { if (bitPointer !=
                                             0) {
                                           bytePointer++;
                                           bitPointer =
                                             0;
                                       }
                                       return true;
    }
    public static final java.lang.String jlc$CompilerVersion$jl7 =
      "2.7.0";
    public static final long jlc$SourceLastModified$jl7 =
      1445630120000L;
    public static final java.lang.String jlc$ClassType$jl7 =
      ("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" +
       "fUuUH7jq/386FTo4IDsAAA==");
    public static final java.lang.String jlc$CompilerVersion$jl5 =
      "2.7.0";
    public static final long jlc$SourceLastModified$jl5 =
      1445630120000L;
    public static final java.lang.String jlc$ClassType$jl5 =
      ("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" +
       "GIm9eSRwFBvZdFIuwQvUtElKR9b0Mu/7");
    public static final java.lang.String jlc$ClassType$jl5$1 =
      ("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" +
       "usHS1eWDVZzxCy0ZHK7kJBlUAffOVgbtl0YGFw6U7Dh94wz66RbRnXSTwoY+" +
       "q8ThQBKddKdkGvPUAWn1xZJ+ApD9gy3p33lpSF/KElw6qeFTyLWM4lkr3Fmw" +
       "2G99lDhG2n8RpNP9BLkKaJPtJtIL1g2Q3ntz/I4gcaS57zr6WpFvXgZ/6wwZ" +
       "/GgaPL0vg2HpmAze9SJksPcO3cXqJu/Ft95owzPn6vGFgyDj9MEz+P7dNPix" +
       "MHc5UMKhu7eofZjxB14E4yzZowCbvGUsvzSMDzP4B2fEfSINPhrmXrFpzXH6" +
       "yk66HD12fTmTzwHNH38paD6zpfnMS0/zZ86I+9k0+Ml9mlkrnkLzH75YmvcB" +
       "er+xpfkbLz3Nf3ZG3OfS4DNh7lZfEeVGlz5G7bMvtmuCQejid7fUvvvSUDs0" +
       "EBVOGktvnbmupYjZO6Y/kZH812cI4N+lwb8Mc/dqSpgOTte/QXu4437+xTY1" +
       "8IsubbdAXLpuC8TNyWPnIMHGNn3xDLq/mQZfAO6UA7iy+6+VHjB8wfdcz9Fn" +
       "L822DGffI4Z/eAbD/5QGvwM6bsqQTt/p9YegTcsncP3dF6vdKOD44S3XD3+P" +
       "uP7JGVy/lgZ/HOZeHnmyeHiv4mGd/eqLYPnK9OYjgN1zW5bPvTQsD5P4n2fE" +
       "/VkafCPM3SnKy3Tj1iGGzx8wfMEXVo9sEAalHf3mQ7qB/f7rvk2z+Z6K9Jnn" +
       "7rrtvuf439vshNz75sntdO42NbKswztmD13f4vmKqmfMb9/sn/UyOt8Jc4+f" +
       "+8sUYFaQnlICO9/e5P+rMHf1PPnTLWbp+VDe3Z0w99DZeUGu7Hw418Uwd/9p" +
       "ucLcBRAeTn1rmHvlSalBShAeTnk5zF05njJ93S49H073cuBGHaQLc7dsLg4n" +
       "uQJKB0nSy7s3L4kefQVtsyU63rydev9hPc8mvve8kPIcmrU+emSjY/bVo71N" +
       "idHmu0dPSZ99rs2+81uln9p8b0KyxHW27e82Onfr5tMXWaHpxsbXnVraXlm3" +
       "tB7/zp0/f/tje/PgOzeAD/rcIWyvPfnjDg3bC7PPMaz/xX2/8Oafee7L2Rtx" +
       "/w/ZPnjsjkoAAA==");
}
