energy is: 356.328445#4931.704025#9286.992722
M D Eq: javax.servlet.jsp.el.ImplicitObjectELResolver$ScopeMap$ScopeEntry.equals(Object) is unusual  At ImplicitObjectELResolver.java:[line 580]
M V EI2: org.apache.commons.daemon.support.DaemonLoader$Context.setArguments(String[]) may expose internal representation by storing an externally mutable object into DaemonLoader$Context.args  At DaemonLoader.java:[line 420]
M V EI: org.apache.commons.daemon.support.DaemonLoader$Context.getArguments() may expose internal representation by returning DaemonLoader$Context.args  At DaemonLoader.java:[line 415]
M D RV: Return value of prepareInstance(Object) ignored, but method has no side effect  At SimpleInstanceManager.java:[line 58]
M V EI2: org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream$StackMarker.setInfos(VerificationTypeInfo[]) may expose internal representation by storing an externally mutable object into StackMapFrameCodeStream$StackMarker.infos  At StackMapFrameCodeStream.java:[line 107]
M B Nm: The class name org.apache.catalina.Executor shadows the simple name of implemented interface java.util.concurrent.Executor  In Executor.java
M M JLM: Synchronization performed on java.util.concurrent.CopyOnWriteArraySet in org.apache.tomcat.util.net.SocketWrapper.addDispatch(DispatchType)  At SocketWrapper.java:[line 132]
M M JLM: Synchronization performed on java.util.concurrent.CopyOnWriteArraySet in org.apache.tomcat.util.net.SocketWrapper.getIteratorAndClearDispatches()  At SocketWrapper.java:[line 141]
M M JLM: Synchronization performed on java.util.concurrent.CopyOnWriteArraySet in org.apache.tomcat.util.net.SocketWrapper.clearDispatches()  At SocketWrapper.java:[line 154]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.ProblemFieldBinding(FieldBinding, ReferenceBinding, char[], int) may expose internal representation by storing an externally mutable object into ProblemFieldBinding.name  At ProblemFieldBinding.java:[line 25]
M B It: org.apache.el.stream.StreamELResolverImpl$ArrayIterator.next() can't throw NoSuchElementException  At StreamELResolverImpl.java:[line 100]
M V EI2: new org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer(ISourceType[], AccessRestriction) may expose internal representation by storing an externally mutable object into NameEnvironmentAnswer.sourceTypes  At NameEnvironmentAnswer.java:[line 32]
M V EI: org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer.getSourceTypes() may expose internal representation by returning NameEnvironmentAnswer.sourceTypes  At NameEnvironmentAnswer.java:[line 65]
M V EI2: org.apache.jasper.xmlparser.XMLString.setValues(char[], int, int) may expose internal representation by storing an externally mutable object into XMLString.ch  At XMLString.java:[line 86]
M V EI2: new org.apache.catalina.tribes.group.RpcChannel$RpcCollectorKey(byte[]) may expose internal representation by storing an externally mutable object into RpcChannel$RpcCollectorKey.id  At RpcChannel.java:[line 284]
M P Bx: org.apache.catalina.ant.jmx.JMXAccessorTask.convertStringToType(String, String) invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At JMXAccessorTask.java:[line 512]
M P Bx: org.apache.catalina.ant.jmx.JMXAccessorTask.convertStringToType(String, String) invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At JMXAccessorTask.java:[line 504]
M P SBSC: org.eclipse.jdt.internal.compiler.util.HashtableOfLong.toString() concatenates strings using + in a loop  At HashtableOfLong.java:[line 98]
M P Bx: org.apache.tomcat.util.http.FastHttpDateFormat.formatDate(long, DateFormat) invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At FastHttpDateFormat.java:[line 133]
M P Bx: org.apache.tomcat.util.http.FastHttpDateFormat.internalParseDate(String, DateFormat[]) invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At FastHttpDateFormat.java:[line 197]
M C RV: Return value of java.util.concurrent.CountDownLatch.await(long, TimeUnit) ignored in org.apache.tomcat.util.net.NioEndpoint$KeyAttachment.awaitLatch(CountDownLatch, long, TimeUnit)  At NioEndpoint.java:[line 1361]
H B ES: Comparison of String parameter using == or != in org.apache.tomcat.jdbc.pool.JdbcInterceptor.compare(String, String)   At JdbcInterceptor.java:[line 138]
H I Dm: Found reliance on default encoding in org.apache.catalina.ant.BaseRedirectorHelperTask.openRedirector(): new java.io.PrintStream(OutputStream)  At BaseRedirectorHelperTask.java:[line 251]
M P Bx: org.apache.naming.factory.BeanFactory.getObjectInstance(Object, Name, Context, Hashtable) invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At BeanFactory.java:[line 243]
M P Bx: org.apache.naming.factory.BeanFactory.getObjectInstance(Object, Name, Context, Hashtable) invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At BeanFactory.java:[line 246]
M P Bx: org.apache.naming.factory.BeanFactory.getObjectInstance(Object, Name, Context, Hashtable) invokes inefficient new Short(String) constructor; use Short.valueOf(String) instead  At BeanFactory.java:[line 240]
M P Bx: org.apache.naming.factory.BeanFactory.getObjectInstance(Object, Name, Context, Hashtable) invokes inefficient new Byte(String) constructor; use Byte.valueOf(String) instead  At BeanFactory.java:[line 237]
M D Eq: org.eclipse.jdt.internal.compiler.classfmt.AnnotationMethodInfoWithAnnotations doesn't override MethodInfo.equals(Object)  At AnnotationMethodInfoWithAnnotations.java:[line 1]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.AnnotationMethodInfoWithAnnotations.getAnnotations() may expose internal representation by returning AnnotationMethodInfoWithAnnotations.annotations  At AnnotationMethodInfoWithAnnotations.java:[line 23]
H I Dm: Found reliance on default encoding in org.apache.juli.FileHandler.openWriter(): new java.io.OutputStreamWriter(OutputStream)  At FileHandler.java:[line 386]
M P Bx: org.apache.taglibs.standard.tlv.JstlFmtTLV$Handler.startElement(String, String, String, Attributes) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At JstlFmtTLV.java:[line 202]
M V EI: checkbox.CheckTest.getFruit() may expose internal representation by returning CheckTest.b  At CheckTest.java:[line 25]
M V EI2: checkbox.CheckTest.setFruit(String[]) may expose internal representation by storing an externally mutable object into CheckTest.b  At CheckTest.java:[line 29]
M B NP: org.apache.tomcat.util.buf.CharChunk.toString() may return null  At CharChunk.java:[line 453]
M V EI2: org.apache.tomcat.util.buf.CharChunk.setChars(char[], int, int) may expose internal representation by storing an externally mutable object into CharChunk.buff  At CharChunk.java:[line 131]
M V EI: org.apache.tomcat.util.buf.CharChunk.getBuffer() may expose internal representation by returning CharChunk.buff  At CharChunk.java:[line 177]
M B Se: Class org.apache.tomcat.util.buf.CharChunk defines non-transient non-serializable instance field in  In CharChunk.java
M B Se: Class org.apache.tomcat.util.buf.CharChunk defines non-transient non-serializable instance field out  In CharChunk.java
M V EI: org.apache.catalina.realm.GenericPrincipal.getRoles() may expose internal representation by returning GenericPrincipal.roles  At GenericPrincipal.java:[line 153]
H B Se: Class org.apache.catalina.realm.GenericPrincipal defines non-transient non-serializable instance field loginContext  In GenericPrincipal.java
M B Se: Class org.apache.catalina.realm.GenericPrincipal defines non-transient non-serializable instance field gssCredential  In GenericPrincipal.java
M D Eq: org.eclipse.jdt.internal.compiler.classfmt.MethodInfoWithAnnotations doesn't override MethodInfo.equals(Object)  At MethodInfoWithAnnotations.java:[line 1]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.MethodInfoWithAnnotations.getAnnotations() may expose internal representation by returning MethodInfoWithAnnotations.annotations  At MethodInfoWithAnnotations.java:[line 32]
M D UC: Useless condition: it's known that i != 9 at this point  At HttpParser.java:[line 46]
M B RR: org.apache.tomcat.util.http.parser.HttpParser.skipConstant(StringReader, String) ignores result of java.io.StringReader.skip(long)  At HttpParser.java:[line 131]
M B RR: org.apache.tomcat.util.http.parser.HttpParser.readToken(StringReader) ignores result of java.io.StringReader.skip(long)  At HttpParser.java:[line 156]
M B RR: org.apache.tomcat.util.http.parser.HttpParser.readQuotedToken(StringReader) ignores result of java.io.StringReader.skip(long)  At HttpParser.java:[line 257]
M B RR: org.apache.tomcat.util.http.parser.HttpParser.readLhex(StringReader) ignores result of java.io.StringReader.skip(long)  At HttpParser.java:[line 314]
M B BC: Equals method for org.apache.tomcat.dbcp.pool2.impl.BaseGenericObjectPool$IdentityWrapper assumes the argument is of type BaseGenericObjectPool$IdentityWrapper  At BaseGenericObjectPool.java:[line 1192]
M B Eq: org.eclipse.jdt.internal.compiler.ast.SwitchStatement$1StringSwitchCase defines compareTo(Object) and uses Object.equals()  At SwitchStatement.java:[lines 169-176]
M V EI: javax.el.MethodInfo.getParamTypes() may expose internal representation by returning MethodInfo.paramTypes  At MethodInfo.java:[line 42]
M V EI2: new javax.el.MethodInfo(String, Class, Class[]) may expose internal representation by storing an externally mutable object into MethodInfo.paramTypes  At MethodInfo.java:[line 30]
M V EI2: new org.eclipse.jdt.internal.compiler.classfmt.ClassFileStruct(byte[], int[], int) may expose internal representation by storing an externally mutable object into ClassFileStruct.reference  At ClassFileStruct.java:[line 18]
M V EI2: new org.eclipse.jdt.internal.compiler.classfmt.ClassFileStruct(byte[], int[], int) may expose internal representation by storing an externally mutable object into ClassFileStruct.constantPoolOffsets  At ClassFileStruct.java:[line 19]
M P SBSC: org.eclipse.jdt.internal.compiler.util.HashtableOfObjectToInt.toString() concatenates strings using + in a loop  At HashtableOfObjectToInt.java:[line 152]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding(char[], TypeBinding[], int) may expose internal representation by storing an externally mutable object into ProblemMethodBinding.selector  At ProblemMethodBinding.java:[line 23]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding(char[], TypeBinding[], ReferenceBinding, int) may expose internal representation by storing an externally mutable object into ProblemMethodBinding.selector  At ProblemMethodBinding.java:[line 29]
H I Dm: Found reliance on default encoding in new org.apache.jasper.compiler.AntCompiler$SystemLogHandler(PrintStream): new org.apache.jasper.compiler.AntCompiler$SystemLogHandler(OutputStream)  At AntCompiler.java:[line 317]
H I Dm: Found reliance on default encoding in org.apache.jasper.compiler.AntCompiler$SystemLogHandler.setThread(): new java.io.PrintStream(OutputStream)  At AntCompiler.java:[line 353]
H I Dm: Found reliance on default encoding in org.apache.jasper.compiler.AntCompiler$SystemLogHandler.unsetThread(): java.io.ByteArrayOutputStream.toString()  At AntCompiler.java:[line 367]
M P SBSC: org.eclipse.jdt.internal.compiler.util.SimpleSet.toString() concatenates strings using + in a loop  At SimpleSet.java:[line 138]
M B Eq: org.eclipse.jdt.internal.compiler.impl.CompilerStats defines compareTo(Object) and uses Object.equals()  At CompilerStats.java:[lines 39-42]
M P Bx: javax.servlet.jsp.jstl.core.LoopTagSupport$1Status.getBegin() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At LoopTagSupport.java:[line 389]
M P Bx: javax.servlet.jsp.jstl.core.LoopTagSupport$1Status.getEnd() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At LoopTagSupport.java:[line 397]
M P Bx: javax.servlet.jsp.jstl.core.LoopTagSupport$1Status.getStep() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At LoopTagSupport.java:[line 405]
M V EI2: new org.apache.catalina.tribes.ByteMessage(byte[]) may expose internal representation by storing an externally mutable object into ByteMessage.message  At ByteMessage.java:[line 58]
M V EI: org.apache.catalina.tribes.ByteMessage.getMessage() may expose internal representation by returning ByteMessage.message  At ByteMessage.java:[line 66]
M V EI2: org.apache.catalina.tribes.ByteMessage.setMessage(byte[]) may expose internal representation by storing an externally mutable object into ByteMessage.message  At ByteMessage.java:[line 74]
M B CNT: Rough value of Math.PI found: 3.14  At Clock2.java:[line 141]
M M UG: org.apache.taglibs.standard.tag.common.sql.DataSourceWrapper.getLogWriter() is unsynchronized, org.apache.taglibs.standard.tag.common.sql.DataSourceWrapper.setLogWriter(PrintWriter) is synchronized  At DataSourceWrapper.java:[line 132]
M B Se: Class chat.ChatServlet defines non-transient non-serializable instance field connections  In ChatServlet.java
H I Dm: Found reliance on default encoding in chat.ChatServlet.read(CometEvent, HttpServletRequest, HttpServletResponse): new String(byte[], int, int)  At ChatServlet.java:[line 166]
M D Eq: org.apache.catalina.mbeans.JmxRemoteLifecycleListener$SslRmiServerBindSocketFactory doesn't override javax.rmi.ssl.SslRMIServerSocketFactory.equals(Object)  At JmxRemoteLifecycleListener.java:[line 1]
M P Bx: org.apache.tomcat.websocket.AsyncChannelWrapperSecure$LongToIntegerFuture.get() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At AsyncChannelWrapperSecure.java:[line 544]
M P Bx: org.apache.tomcat.websocket.AsyncChannelWrapperSecure$LongToIntegerFuture.get(long, TimeUnit) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At AsyncChannelWrapperSecure.java:[line 556]
M M VO: Increment of volatile field org.apache.tomcat.util.net.AprEndpoint$SocketList.size in org.apache.tomcat.util.net.AprEndpoint$SocketList.add(long, int, int)  At AprEndpoint.java:[line 1265]
M M VO: Increment of volatile field org.apache.tomcat.util.net.AprEndpoint$SocketList.size in org.apache.tomcat.util.net.AprEndpoint$SocketList.remove(long)  At AprEndpoint.java:[line 1276]
M P WMI: new org.apache.tomcat.websocket.server.WsHandshakeRequest(HttpServletRequest, Map) makes inefficient use of keySet iterator instead of entrySet iterator  At WsHandshakeRequest.java:[line 82]
M V EI2: new org.apache.el.parser.ParseException(Token, int[][], String[]) may expose internal representation by storing an externally mutable object into ParseException.tokenImage  At ParseException.java:[line 38]
M V EI2: new org.apache.el.parser.ParseException(Token, int[][], String[]) may expose internal representation by storing an externally mutable object into ParseException.expectedTokenSequences  At ParseException.java:[line 37]
M P SBSC: org.apache.el.parser.ParseException.initialise(Token, int[][], String[]) concatenates strings using + in a loop  At ParseException.java:[line 117]
M B Dm: org.apache.commons.daemon.support.DaemonWrapper$Invoker.invoke() invokes System.exit(...), which shuts down the entire virtual machine  At DaemonWrapper.java:[line 227]
M D REC: Exception is caught when Exception is not thrown in org.apache.catalina.startup.PasswdUserDatabase.init()  At PasswdUserDatabase.java:[line 182]
H I Dm: Found reliance on default encoding in org.apache.catalina.startup.PasswdUserDatabase.init(): new java.io.FileReader(String)  At PasswdUserDatabase.java:[line 139]
M B Eq: org.apache.el.util.ReflectionUtil$MatchResult defines compareTo(ReflectionUtil$MatchResult) and uses Object.equals()  At ReflectionUtil.java:[lines 489-503]
H I Dm: Found reliance on default encoding in org.apache.tomcat.util.http.fileupload.ByteArrayOutputStream.toString(): new String(byte[])  At ByteArrayOutputStream.java:[line 262]
M V EI2: org.apache.taglibs.standard.tag.rt.sql.DateParamTag.setValue(Date) may expose internal representation by storing an externally mutable object into DateParamTag.value  At DateParamTag.java:[line 31]
M V EI2: new org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream$ExceptionMarker(int, char[]) may expose internal representation by storing an externally mutable object into StackMapFrameCodeStream$ExceptionMarker.constantPoolName  At StackMapFrameCodeStream.java:[line 41]
M C DMI: Invocation of hashCode on array in org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream$ExceptionMarker.hashCode()  At StackMapFrameCodeStream.java:[line 57]
H I Dm: Found reliance on default encoding in new org.apache.tomcat.util.log.CaptureLog(): new java.io.PrintStream(OutputStream)  At CaptureLog.java:[line 32]
H I Dm: Found reliance on default encoding in org.apache.tomcat.util.log.CaptureLog.getCapture(): java.io.ByteArrayOutputStream.toString()  At CaptureLog.java:[line 47]
M V EI: org.apache.catalina.tribes.transport.bio.util.LinkObject.getKey() may expose internal representation by returning LinkObject.key  At LinkObject.java:[line 89]
M V EI2: new org.apache.catalina.tribes.transport.bio.util.LinkObject(ChannelMessage, Member[], InterceptorPayload) may expose internal representation by storing an externally mutable object into LinkObject.destination  At LinkObject.java:[line 53]
M V EI: org.apache.catalina.tribes.transport.bio.util.LinkObject.getDestination() may expose internal representation by returning LinkObject.destination  At LinkObject.java:[line 101]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.InnerClassInfo.getName() may expose internal representation by returning InnerClassInfo.innerClassName  At InnerClassInfo.java:[line 89]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.InnerClassInfo.getEnclosingTypeName() may expose internal representation by returning InnerClassInfo.outerClassName  At InnerClassInfo.java:[line 58]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.InnerClassInfo.getSourceName() may expose internal representation by returning InnerClassInfo.innerName  At InnerClassInfo.java:[line 105]
M M SC: new org.eclipse.jdt.internal.compiler.ReadManager(ICompilationUnit[], int) invokes Thread.start()  At ReadManager.java:[line 71]
M B OS: org.apache.catalina.startup.WebappServiceLoader.parseConfigFile(LinkedHashSet, URL) may fail to close stream  At WebappServiceLoader.java:[line 164]
M P Bx: org.apache.taglibs.standard.tlv.JstlCoreTLV$Handler.startElement(String, String, String, Attributes) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At JstlCoreTLV.java:[line 233]
M B Se: org.apache.tomcat.websocket.server.WsWriteTimeout$EndpointComparator implements Comparator but not Serializable  At WsWriteTimeout.java:[lines 112-127]
M V EI: org.apache.catalina.tribes.group.interceptors.SimpleCoordinator.getView() may expose internal representation by returning SimpleCoordinator.view  At SimpleCoordinator.java:[line 106]
M V EI2: new org.apache.catalina.tribes.io.ReplicationStream(InputStream, ClassLoader[]) may expose internal representation by storing an externally mutable object into ReplicationStream.classLoaders  At ReplicationStream.java:[line 61]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.NumberLiteral(char[], int, int) may expose internal representation by storing an externally mutable object into NumberLiteral.source  At NumberLiteral.java:[line 19]
M V EI: org.eclipse.jdt.internal.compiler.ast.NumberLiteral.source() may expose internal representation by returning NumberLiteral.source  At NumberLiteral.java:[line 31]
H P Bx: Primitive boxed just to call toString in org.apache.catalina.servlets.CGIServlet$CGIEnvironment.setCGIEnvironment(HttpServletRequest)  At CGIServlet.java:[line 1084]
M P SBSC: org.apache.catalina.servlets.CGIServlet$CGIEnvironment.findCGI(String, String, String, String, String) concatenates strings using + in a loop  At CGIServlet.java:[line 905]
M D SF: Switch statement found in org.apache.catalina.servlets.CGIServlet$HTTPHeaderInputStream.read() where default case is missing  At CGIServlet.java:[lines 1912-1921]
M V EI: javax.servlet.HttpConstraintElement.getRolesAllowed() may expose internal representation by returning HttpConstraintElement.rolesAllowed  At HttpConstraintElement.java:[line 123]
M D Eq: org.apache.naming.ServiceRef doesn't override javax.naming.Reference.equals(Object)  At ServiceRef.java:[line 1]
M P SBSC: org.eclipse.jdt.internal.compiler.util.SimpleLookupTable.toString() concatenates strings using + in a loop  At SimpleLookupTable.java:[line 164]
M B Eq: javax.el.Util$MatchResult defines compareTo(Util$MatchResult) and uses Object.equals()  At Util.java:[lines 761-775]
M P SBSC: org.eclipse.jdt.internal.compiler.util.SimpleSetOfCharArray.toString() concatenates strings using + in a loop  At SimpleSetOfCharArray.java:[line 140]
M B SnVI: org.apache.commons.daemon.DaemonPermission is Serializable; consider declaring a serialVersionUID  At DaemonPermission.java:[lines 165-421]
M B NP: org.apache.tomcat.util.buf.ByteChunk.toString() may return null  At ByteChunk.java:[line 488]
M B CN: Class org.apache.tomcat.util.buf.ByteChunk implements Cloneable but does not define or use clone method  At ByteChunk.java:[lines 103-789]
M V EI2: org.apache.tomcat.util.buf.ByteChunk.setBytes(byte[], int, int) may expose internal representation by storing an externally mutable object into ByteChunk.buff  At ByteChunk.java:[line 177]
M V EI: org.apache.tomcat.util.buf.ByteChunk.getBuffer() may expose internal representation by returning ByteChunk.buff  At ByteChunk.java:[line 206]
M B Se: Class org.apache.tomcat.util.buf.ByteChunk defines non-transient non-serializable instance field charset  In ByteChunk.java
M B Se: Class org.apache.tomcat.util.buf.ByteChunk defines non-transient non-serializable instance field in  In ByteChunk.java
M B Se: Class org.apache.tomcat.util.buf.ByteChunk defines non-transient non-serializable instance field out  In ByteChunk.java
M B FS: Format string should use %n rather than \n in nonblocking.NumberWriter$NumberWriterListener.onWritePossible()  At NumberWriter.java:[line 131]
M X OBL: org.apache.juli.ClassLoaderLogManager.readConfiguration(ClassLoader) may fail to clean up java.io.InputStream  Obligation to clean up resource created at ClassLoaderLogManager.java:[line 479] is not discharged
M C RV: Return value of java.util.concurrent.CountDownLatch.await(long, TimeUnit) ignored in org.apache.tomcat.jdbc.pool.ConnectionPool$ConnectionFuture.get(long, TimeUnit)  At ConnectionPool.java:[line 1227]
M D RCN: Redundant nullcheck of value, which is known to be non-null in org.apache.el.util.MessageFactory.get(String, Object[])  Redundant null check at MessageFactory.java:[line 40]
M P Bx: org.apache.el.parser.AstInteger.getInteger() invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At AstInteger.java:[line 41]
M P Bx: org.apache.taglibs.standard.tlv.JstlSqlTLV$Handler.startElement(String, String, String, Attributes) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At JstlSqlTLV.java:[line 166]
H I Dm: Found reliance on default encoding in org.apache.catalina.util.URLEncoder.encode(String): new java.io.OutputStreamWriter(OutputStream)  At URLEncoder.java:[line 79]
M D NP: Load of known null value in org.apache.tomcat.util.descriptor.LocalResolver.resolveEntity(String, String, String, String)  At LocalResolver.java:[line 91]
M V EI: org.apache.catalina.tribes.UniqueId.getBytes() may expose internal representation by returning UniqueId.id  At UniqueId.java:[line 68]
M V EI2: new org.apache.catalina.tribes.UniqueId(byte[]) may expose internal representation by storing an externally mutable object into UniqueId.id  At UniqueId.java:[line 40]
M V EI2: new org.eclipse.jdt.internal.compiler.codegen.CachedIndexEntry(char[], int) may expose internal representation by storing an externally mutable object into CachedIndexEntry.signature  At CachedIndexEntry.java:[line 18]
M D Eq: org.eclipse.jdt.internal.compiler.util.Messages$MessagesProperties doesn't override java.util.Hashtable.equals(Object)  At Messages.java:[line 1]
M D SF: Switch statement found in org.apache.juli.AsyncFileHandler.publish(LogRecord) where default case is missing  At AsyncFileHandler.java:[lines 102-118]
M B RV: Exceptional return value of java.io.File.mkdirs() ignored in org.apache.catalina.storeconfig.StoreFileMover.init()  At StoreFileMover.java:[line 140]
M B RV: Exceptional return value of java.io.File.renameTo(File) ignored in org.apache.catalina.storeconfig.StoreFileMover.move()  At StoreFileMover.java:[line 157]
M V EI2: org.apache.catalina.ha.deploy.FileMessage.setData(byte[], int) may expose internal representation by storing an externally mutable object into FileMessage.data  At FileMessage.java:[line 64]
M V EI: org.apache.catalina.ha.deploy.FileMessage.getData() may expose internal representation by returning FileMessage.data  At FileMessage.java:[line 61]
M D Eq: org.eclipse.jdt.internal.compiler.classfmt.FieldInfoWithAnnotation doesn't override FieldInfo.equals(Object)  At FieldInfoWithAnnotation.java:[line 1]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.FieldInfoWithAnnotation.getAnnotations() may expose internal representation by returning FieldInfoWithAnnotation.annotations  At FieldInfoWithAnnotation.java:[line 33]
M V EI: org.eclipse.jdt.internal.compiler.codegen.BranchLabel.forwardReferences() may expose internal representation by returning BranchLabel.forwardReferences  At BranchLabel.java:[line 165]
H D RV: Return value of forwardReferenceCount() ignored, but method has no side effect  At BranchLabel.java:[line 160]
H D RV: Return value of forwardReferences() ignored, but method has no side effect  At BranchLabel.java:[line 164]
M B Nm: The method name org.apache.el.parser.TokenMgrError.LexicalError(boolean, int, int, int, String, char) doesn't start with a lower case letter  At TokenMgrError.java:[lines 109-113]
M D NP: Load of known null value in org.apache.tomcat.util.net.NioBlockingSelector$BlockPoller$2.run()  At NioBlockingSelector.java:[line 269]
M V EI2: new org.eclipse.jdt.internal.compiler.env.AccessRule(char[], int, boolean) may expose internal representation by storing an externally mutable object into AccessRule.pattern  At AccessRule.java:[line 28]
M V EI2: new org.apache.catalina.ha.context.ReplicatedContext$MultiEnumeration(Enumeration[]) may expose internal representation by storing an externally mutable object into ReplicatedContext$MultiEnumeration.e  At ReplicatedContext.java:[line 205]
M B Se: org.apache.catalina.webresources.Cache$EvictionOrder implements Comparator but not Serializable  At Cache.java:[lines 313-327]
H I Dm: Found reliance on default encoding in new org.apache.el.parser.SimpleCharStream(InputStream, String, int, int, int): new java.io.InputStreamReader(InputStream)  At SimpleCharStream.java:[line 316]
H I Dm: Found reliance on default encoding in new org.apache.el.parser.SimpleCharStream(InputStream, int, int, int): new java.io.InputStreamReader(InputStream)  At SimpleCharStream.java:[line 323]
H I Dm: Found reliance on default encoding in org.apache.el.parser.SimpleCharStream.ReInit(InputStream, String, int, int, int): new java.io.InputStreamReader(InputStream)  At SimpleCharStream.java:[line 356]
H I Dm: Found reliance on default encoding in org.apache.el.parser.SimpleCharStream.ReInit(InputStream, int, int, int): new java.io.InputStreamReader(InputStream)  At SimpleCharStream.java:[line 363]
M P SBSC: org.eclipse.jdt.internal.compiler.util.HashtableOfType.toString() concatenates strings using + in a loop  At HashtableOfType.java:[line 127]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.flow.FlowInfo.mergeNullStatus(int, int) where default case is missing  At FlowInfo.java:[lines 379-390]
M M NN: Naked notify in org.apache.catalina.tribes.transport.RxTaskPool.returnWorker(AbstractRxTask)  At RxTaskPool.java:[line 107]
M B RV: org.apache.catalina.manager.util.ReverseComparator.compare(Session, Session) negates the return value of java.util.Comparator.compare(Object, Object)  At ReverseComparator.java:[line 45]
M P Bx: org.apache.taglibs.standard.tlv.JstlXmlTLV$Handler.startElement(String, String, String, Attributes) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At JstlXmlTLV.java:[line 220]
M P SBSC: org.eclipse.jdt.internal.compiler.util.HashtableOfIntValues.toString() concatenates strings using + in a loop  At HashtableOfIntValues.java:[line 153]
H I Dm: Found reliance on default encoding in org.apache.catalina.servlets.CGIServlet$CGIRunner.run(): new java.io.InputStreamReader(InputStream)  At CGIServlet.java:[line 1655]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ElementValuePairInfo.getName() may expose internal representation by returning ElementValuePairInfo.name  At ElementValuePairInfo.java:[line 30]
M M VO: Increment of volatile field org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStats.prepareCount in org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStats.prepare(long)  At SlowQueryReport.java:[line 401]
M M VO: Increment of volatile field org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStats.nrOfInvocations in org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStats.add(long, long)  At SlowQueryReport.java:[line 416]
H M VO: Increment of volatile field org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStats.failures in org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStats.failure(long, long)  At SlowQueryReport.java:[line 423]
M V MS: Public static org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStats.getFieldNames() may expose internal representation by returning SlowQueryReport$QueryStats.FIELD_NAMES  At SlowQueryReport.java:[line 337]
M V MS: Public static org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStats.getFieldTypes() may expose internal representation by returning SlowQueryReport$QueryStats.FIELD_TYPES  At SlowQueryReport.java:[line 345]
M V MS: Public static org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStats.getFieldDescriptions() may expose internal representation by returning SlowQueryReport$QueryStats.FIELD_DESCRIPTIONS  At SlowQueryReport.java:[line 341]
M V EI: org.apache.catalina.ha.session.SessionMessageImpl.getSession() may expose internal representation by returning SessionMessageImpl.mSession  At SessionMessageImpl.java:[line 108]
M P SBSC: org.eclipse.jdt.internal.compiler.util.ObjectVector.toString() concatenates strings using + in a loop  At ObjectVector.java:[line 132]
H P Dm: org.apache.commons.daemon.support.DaemonLoader.load(String, String[]) forces garbage collection; extremely dubious except in benchmarking code  At DaemonLoader.java:[line 121]
H P Dm: org.apache.commons.daemon.support.DaemonLoader.stop() forces garbage collection; extremely dubious except in benchmarking code  At DaemonLoader.java:[line 271]
H P Dm: org.apache.commons.daemon.support.DaemonLoader.destroy() forces garbage collection; extremely dubious except in benchmarking code  At DaemonLoader.java:[line 294]
M V EI2: org.apache.taglibs.standard.tag.rt.fmt.FormatDateTag.setValue(Date) may expose internal representation by storing an externally mutable object into FormatDateTag.value  At FormatDateTag.java:[line 41]
M P SBSC: org.eclipse.jdt.internal.compiler.util.HashtableOfInt.toString() concatenates strings using + in a loop  At HashtableOfInt.java:[line 95]
M D NP: Load of known null value in org.apache.jasper.el.JasperELResolver.getValue(ELContext, Object, Object)  At JasperELResolver.java:[line 96]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ProblemBinding.readableName() may expose internal representation by returning ProblemBinding.name  At ProblemBinding.java:[line 53]
H I Dm: Found reliance on default encoding in new org.apache.tomcat.dbcp.pool2.impl.AbandonedConfig(): new java.io.PrintWriter(OutputStream)  At AbandonedConfig.java:[line 174]
M B Se: org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport$QueryStatsComparator implements Comparator but not Serializable  At SlowQueryReport.java:[lines 474-487]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding.qualifiedSourceName() may expose internal representation by returning BaseTypeBinding.simpleName  At BaseTypeBinding.java:[line 215]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding.constantPoolName() may expose internal representation by returning BaseTypeBinding.constantPoolName  At BaseTypeBinding.java:[line 147]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding.sourceName() may expose internal representation by returning BaseTypeBinding.simpleName  At BaseTypeBinding.java:[line 227]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding.readableName() may expose internal representation by returning BaseTypeBinding.simpleName  At BaseTypeBinding.java:[line 219]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding.shortReadableName() may expose internal representation by returning BaseTypeBinding.simpleName  At BaseTypeBinding.java:[line 223]
M B CN: Class javax.servlet.jsp.tagext.TagData implements Cloneable but does not define or use clone method  At TagData.java:[lines 39-147]
M V EI2: new javax.servlet.jsp.tagext.TagData(Hashtable) may expose internal representation by storing an externally mutable object into TagData.attributes  At TagData.java:[line 80]
M V EI: org.apache.tomcat.util.bcel.classfile.ArrayElementValue.getElementValuesArray() may expose internal representation by returning ArrayElementValue.evalues  At ArrayElementValue.java:[line 53]
H B DE: org.apache.naming.factory.SendMailFactory$1.run() might ignore java.lang.Exception  At SendMailFactory.java:[line 123]
M B Nm: Class org.apache.tomcat.jdbc.pool.TrapException is not derived from an Exception, even though it is named as such  At TrapException.java:[lines 34-79]
M V EI: org.apache.taglibs.standard.tag.common.sql.ResultImpl.getColumnNames() may expose internal representation by returning ResultImpl.columnNames  At ResultImpl.java:[line 168]
H B Nm: The class name org.apache.tomcat.util.threads.ThreadPoolExecutor shadows the simple name of the superclass java.util.concurrent.ThreadPoolExecutor  At ThreadPoolExecutor.java:[lines 40-209]
M B Se: Class org.apache.catalina.tribes.util.ExecutorFactory$TaskQueue defines non-transient non-serializable instance field parent  In ExecutorFactory.java
M V EI2: new org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException(RuntimeException, char[]) may expose internal representation by storing an externally mutable object into ClassFormatException.fileName  At ClassFormatException.java:[line 55]
H D DLS: Dead store to listener in nonblocking.NumberWriter.doGet(HttpServletRequest, HttpServletResponse)  At NumberWriter.java:[line 57]
M B Se: Class org.apache.tomcat.util.threads.TaskQueue defines non-transient non-serializable instance field parent  In TaskQueue.java
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.TypeConstants$CloseMethodRecord(char[][], char[], int) may expose internal representation by storing an externally mutable object into TypeConstants$CloseMethodRecord.typeName  At TypeConstants.java:[line 211]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.TypeConstants$CloseMethodRecord(char[][], char[], int) may expose internal representation by storing an externally mutable object into TypeConstants$CloseMethodRecord.selector  At TypeConstants.java:[line 212]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.MissingTypeBinding(PackageBinding, char[][], LookupEnvironment) may expose internal representation by storing an externally mutable object into MissingTypeBinding.compoundName  At MissingTypeBinding.java:[line 29]
M V EI2: new org.apache.tomcat.websocket.pojo.PojoMessageHandlerBase(Object, Method, Session, Object[], int, boolean, int, long) may expose internal representation by storing an externally mutable object into PojoMessageHandlerBase.params  At PojoMessageHandlerBase.java:[line 62]
M P SBSC: org.eclipse.jdt.internal.compiler.util.HashtableOfObject.toString() concatenates strings using + in a loop  At HashtableOfObject.java:[line 185]
M X OBL: org.apache.tomcat.util.http.fileupload.DeferredFileOutputStream.thresholdReached() may fail to clean up java.io.OutputStream on checked exception  Obligation to clean up resource created at DeferredFileOutputStream.java:[line 148] is not discharged
M V EI: org.eclipse.jdt.internal.compiler.CompilationResult.getProblems() may expose internal representation by returning CompilationResult.problems  At CompilationResult.java:[line 253]
M V EI: org.eclipse.jdt.internal.compiler.CompilationResult.getLineSeparatorPositions() may expose internal representation by returning CompilationResult.lineSeparatorPositions  At CompilationResult.java:[line 225]
M V EI: org.eclipse.jdt.internal.compiler.CompilationResult.getCUProblems() may expose internal representation by returning CompilationResult.problems  At CompilationResult.java:[line 288]
M V EI2: new org.eclipse.jdt.internal.compiler.CompilationResult(char[], int, int, int) may expose internal representation by storing an externally mutable object into CompilationResult.fileName  At CompilationResult.java:[line 90]
M V EI: org.eclipse.jdt.internal.compiler.CompilationResult.getTasks() may expose internal representation by returning CompilationResult.tasks  At CompilationResult.java:[line 310]
M V EI2: org.eclipse.jdt.internal.compiler.CompilationResult.recordPackageName(char[][]) may expose internal representation by storing an externally mutable object into CompilationResult.packageName  At CompilationResult.java:[line 367]
M V EI: org.eclipse.jdt.internal.compiler.CompilationResult.getFileName() may expose internal representation by returning CompilationResult.fileName  At CompilationResult.java:[line 221]
H I Dm: Found reliance on default encoding in new org.apache.tomcat.util.log.SystemLogHandler(PrintStream): new org.apache.tomcat.util.log.SystemLogHandler(OutputStream)  At SystemLogHandler.java:[line 44]
M D Eq: org.eclipse.jdt.internal.compiler.classfmt.MethodInfoWithParameterAnnotations doesn't override MethodInfo.equals(Object)  At MethodInfoWithParameterAnnotations.java:[line 1]
M V EI2: new org.eclipse.jdt.internal.compiler.env.EnumConstantSignature(char[], char[]) may expose internal representation by storing an externally mutable object into EnumConstantSignature.constName  At EnumConstantSignature.java:[line 28]
M V EI: org.eclipse.jdt.internal.compiler.env.EnumConstantSignature.getTypeName() may expose internal representation by returning EnumConstantSignature.typeName  At EnumConstantSignature.java:[line 35]
M V EI: org.eclipse.jdt.internal.compiler.env.EnumConstantSignature.getEnumConstantName() may expose internal representation by returning EnumConstantSignature.constName  At EnumConstantSignature.java:[line 42]
M V EI2: new org.eclipse.jdt.internal.compiler.env.EnumConstantSignature(char[], char[]) may expose internal representation by storing an externally mutable object into EnumConstantSignature.typeName  At EnumConstantSignature.java:[line 27]
M V EI2: new org.apache.catalina.mapper.Mapper$ContextVersion(String, String, int, Context, WebResourceRoot, String[]) may expose internal representation by storing an externally mutable object into Mapper$ContextVersion.welcomeResources  At Mapper.java:[line 1668]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.ProblemReferenceBinding(char[][], ReferenceBinding, int) may expose internal representation by storing an externally mutable object into ProblemReferenceBinding.compoundName  At ProblemReferenceBinding.java:[line 26]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.ImportBinding(char[][], boolean, Binding, ImportReference) may expose internal representation by storing an externally mutable object into ImportBinding.compoundName  At ImportBinding.java:[line 24]
H I Dm: Found reliance on default encoding in org.apache.tomcat.util.http.fileupload.util.Streams.asString(InputStream): java.io.ByteArrayOutputStream.toString()  At Streams.java:[line 142]
M V EI2: org.apache.jasper.compiler.Node$UninterpretedTag.setJspAttributes(Node$JspAttribute[]) may expose internal representation by storing an externally mutable object into Node$UninterpretedTag.jspAttrs  At Node.java:[line 1252]
M V EI: org.apache.jasper.compiler.Node$UninterpretedTag.getJspAttributes() may expose internal representation by returning Node$UninterpretedTag.jspAttrs  At Node.java:[line 1256]
M D SF: Switch statement found in org.apache.tomcat.util.descriptor.tld.TldRuleSet$Variable.setScope(String) where default case is missing  At TldRuleSet.java:[lines 324-332]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.PackageBinding(char[][], PackageBinding, LookupEnvironment) may expose internal representation by storing an externally mutable object into PackageBinding.compoundName  At PackageBinding.java:[line 43]
M P SBSC: org.eclipse.jdt.internal.compiler.util.HashtableOfPackage.toString() concatenates strings using + in a loop  At HashtableOfPackage.java:[line 102]
M D SF: Switch statement found in org.apache.el.parser.ELParserTokenManager.getNextToken() where default case is missing  At ELParserTokenManager.java:[lines 2001-2033]
M B Nm: The method name org.apache.el.parser.ELParserTokenManager.ReInit(SimpleCharStream) doesn't start with a lower case letter  At ELParserTokenManager.java:[lines 1918-1922]
M B Nm: The method name org.apache.el.parser.ELParserTokenManager.ReInit(SimpleCharStream, int) doesn't start with a lower case letter  At ELParserTokenManager.java:[lines 1934-1936]
M B Nm: The method name org.apache.el.parser.ELParserTokenManager.SwitchTo(int) doesn't start with a lower case letter  At ELParserTokenManager.java:[lines 1941-1945]
M V EI: org.eclipse.jdt.internal.compiler.env.ClassSignature.getTypeName() may expose internal representation by returning ClassSignature.className  At ClassSignature.java:[line 34]
M V EI2: new org.eclipse.jdt.internal.compiler.env.ClassSignature(char[]) may expose internal representation by storing an externally mutable object into ClassSignature.className  At ClassSignature.java:[line 27]
M V EI: org.eclipse.jdt.internal.compiler.ast.ImportReference.getImportName() may expose internal representation by returning ImportReference.tokens  At ImportReference.java:[line 54]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.ImportReference(char[][], long[], boolean, int) may expose internal representation by storing an externally mutable object into ImportReference.tokens  At ImportReference.java:[line 35]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.ImportReference(char[][], long[], boolean, int) may expose internal representation by storing an externally mutable object into ImportReference.sourcePositions  At ImportReference.java:[line 36]
M V EI2: new javax.servlet.jsp.tagext.TagInfo(String, String, String, String, TagLibraryInfo, TagExtraInfo, TagAttributeInfo[], String, String, String, TagVariableInfo[]) may expose internal representation by storing an externally mutable object into TagInfo.tagVariableInfo  At TagInfo.java:[line 149]
M V EI2: new javax.servlet.jsp.tagext.TagInfo(String, String, String, String, TagLibraryInfo, TagExtraInfo, TagAttributeInfo[], String, String, String, TagVariableInfo[], boolean) may expose internal representation by storing an externally mutable object into TagInfo.attributeInfo  At TagInfo.java:[line 203]
M V EI2: new javax.servlet.jsp.tagext.TagInfo(String, String, String, String, TagLibraryInfo, TagExtraInfo, TagAttributeInfo[], String, String, String, TagVariableInfo[]) may expose internal representation by storing an externally mutable object into TagInfo.attributeInfo  At TagInfo.java:[line 145]
M V EI2: new javax.servlet.jsp.tagext.TagInfo(String, String, String, String, TagLibraryInfo, TagExtraInfo, TagAttributeInfo[]) may expose internal representation by storing an externally mutable object into TagInfo.attributeInfo  At TagInfo.java:[line 91]
M V EI: javax.servlet.jsp.tagext.TagInfo.getAttributes() may expose internal representation by returning TagInfo.attributeInfo  At TagInfo.java:[line 234]
M V EI: javax.servlet.jsp.tagext.TagInfo.getTagVariableInfos() may expose internal representation by returning TagInfo.tagVariableInfo  At TagInfo.java:[line 418]
M V EI2: new javax.servlet.jsp.tagext.TagInfo(String, String, String, String, TagLibraryInfo, TagExtraInfo, TagAttributeInfo[], String, String, String, TagVariableInfo[], boolean) may expose internal representation by storing an externally mutable object into TagInfo.tagVariableInfo  At TagInfo.java:[line 207]
M B NP: org.apache.tomcat.util.buf.MessageBytes.toString() may return null  At MessageBytes.java:[line 170]
M B CN: Class org.apache.tomcat.util.buf.MessageBytes implements Cloneable but does not define or use clone method  At MessageBytes.java:[lines 37-537]
M D SF: Switch statement found in org.apache.tomcat.util.buf.MessageBytes.duplicate(MessageBytes) where default case is missing  At MessageBytes.java:[lines 446-462]
M D Eq: org.eclipse.jdt.internal.compiler.classfmt.FieldInfoWithTypeAnnotation doesn't override FieldInfo.equals(Object)  At FieldInfoWithTypeAnnotation.java:[line 1]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.FieldInfoWithTypeAnnotation.getTypeAnnotations() may expose internal representation by returning FieldInfoWithTypeAnnotation.typeAnnotations  At FieldInfoWithTypeAnnotation.java:[line 24]
M D SF: Switch statement found in org.apache.catalina.util.ManifestResource.toString() where default case is missing  At ManifestResource.java:[lines 130-133]
H M VO: Increment of volatile field org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject.borrowedCount in org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject.allocate()  At DefaultPooledObject.java:[line 194]
M B Eq: org.apache.tomcat.dbcp.pool2.impl.DefaultPooledObject defines compareTo(Object) and uses Object.equals()  At DefaultPooledObject.java:[line 38]
M D SF: Switch statement found in org.apache.catalina.util.DOMWriter.print(Node) where default case is missing  At DOMWriter.java:[lines 64-138]
M M NN: Naked notify in org.apache.tomcat.util.net.AprEndpoint$Poller.run()  At AprEndpoint.java:[line 2018]
M P WMI: org.apache.catalina.realm.JNDIRealm.getRoles(DirContext, JNDIRealm$User) makes inefficient use of keySet iterator instead of entrySet iterator  At JNDIRealm.java:[line 2006]
H I Dm: Found reliance on default encoding in org.apache.catalina.realm.JNDIRealm.getAttributeValue(String, Attributes): new String(byte[])  At JNDIRealm.java:[line 2088]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.SignatureWrapper(char[], boolean) may expose internal representation by storing an externally mutable object into SignatureWrapper.signature  At SignatureWrapper.java:[line 23]
M V EI2: new org.eclipse.jdt.internal.compiler.env.AccessRuleSet(AccessRule[], byte, String) may expose internal representation by storing an externally mutable object into AccessRuleSet.accessRules  At AccessRuleSet.java:[line 34]
M V EI: org.eclipse.jdt.internal.compiler.env.AccessRuleSet.getAccessRules() may expose internal representation by returning AccessRuleSet.accessRules  At AccessRuleSet.java:[line 62]
M B IC: Initialization of org.eclipse.jdt.internal.compiler.impl.Constant accesses class org.eclipse.jdt.internal.compiler.impl.DoubleConstant, which isn't initialized yet  At Constant.java:[line 20]
M B CN: org.apache.catalina.tribes.membership.Membership.clone() does not call super.clone()  At Membership.java:[lines 65-73]
M V EI: org.apache.catalina.tribes.membership.Membership.getMembers() may expose internal representation by returning Membership.members  At Membership.java:[line 274]
M D RCN: Redundant nullcheck of result, which is known to be non-null in javax.el.Util.findConstructor(Class, Class[], Object[])  Redundant null check at Util.java:[line 577]
M D RCN: Redundant nullcheck of result, which is known to be non-null in javax.el.Util.findMethod(Class, String, Class[], Object[])  Redundant null check at Util.java:[line 216]
M D NP: Load of known null value in javax.el.Util.findConstructor(Class, Class[], Object[])  At Util.java:[line 561]
M V EI: org.eclipse.jdt.internal.compiler.lookup.TypeBinding.getTypeAnnotations() may expose internal representation by returning TypeBinding.typeAnnotations  At TypeBinding.java:[line 1456]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.TypeBinding.setTypeAnnotations(AnnotationBinding[], boolean) may expose internal representation by storing an externally mutable object into TypeBinding.typeAnnotations  At TypeBinding.java:[line 1463]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.TypeBinding.findSuperTypeOriginatingFrom(TypeBinding) where default case is missing  At TypeBinding.java:[lines 347-422]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.TypeBinding.isTypeArgumentContainedBy(TypeBinding) where default case is missing  At TypeBinding.java:[lines 1159-1169]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.TypeBinding.setTypeAnnotations(AnnotationBinding[], boolean) where default case is missing  At TypeBinding.java:[lines 1468-1473]
H I Dm: Found reliance on default encoding in org.apache.tomcat.util.http.fileupload.MultipartStream.readHeaders(): java.io.ByteArrayOutputStream.toString()  At MultipartStream.java:[line 509]
M M UL: org.apache.tomcat.jdbc.pool.FairBlockingQueue.poll(long, TimeUnit) does not release lock on all exception paths  At FairBlockingQueue.java:[line 137]
M D ST: Write to static field org.eclipse.jdt.internal.compiler.impl.CompilerOptions.tolerateIllegalAmbiguousVarargsInvocation from instance method new org.eclipse.jdt.internal.compiler.impl.CompilerOptions(Map)  At CompilerOptions.java:[line 454]
H I Dm: Found reliance on default encoding in new org.eclipse.jdt.internal.compiler.util.GenericXMLWriter(OutputStream, String, boolean): new java.io.PrintWriter(OutputStream)  At GenericXMLWriter.java:[line 61]
M V EI2: new org.eclipse.jdt.internal.compiler.problem.DefaultProblem(char[], String, int, String[], int, int, int, int, int) may expose internal representation by storing an externally mutable object into DefaultProblem.fileName  At DefaultProblem.java:[line 46]
M V EI2: new org.eclipse.jdt.internal.compiler.problem.DefaultProblem(char[], String, int, String[], int, int, int, int, int) may expose internal representation by storing an externally mutable object into DefaultProblem.arguments  At DefaultProblem.java:[line 49]
M V EI: org.eclipse.jdt.internal.compiler.problem.DefaultProblem.getOriginatingFileName() may expose internal representation by returning DefaultProblem.fileName  At DefaultProblem.java:[line 200]
M V EI: org.eclipse.jdt.internal.compiler.problem.DefaultProblem.getArguments() may expose internal representation by returning DefaultProblem.arguments  At DefaultProblem.java:[line 115]
M V EI2: org.eclipse.jdt.internal.compiler.problem.DefaultProblem.setOriginatingFileName(char[]) may expose internal representation by storing an externally mutable object into DefaultProblem.fileName  At DefaultProblem.java:[line 249]
M P SBSC: org.eclipse.jdt.internal.compiler.problem.DefaultProblem.toString() concatenates strings using + in a loop  At DefaultProblem.java:[line 288]
M P Bx: org.apache.tomcat.util.net.AprEndpoint$Sendfile.remove(AprEndpoint$SendfileData) invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At AprEndpoint.java:[line 2222]
M P Bx: org.apache.tomcat.util.net.AprEndpoint$Sendfile.run() invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At AprEndpoint.java:[line 2270]
M M NN: Naked notify in org.apache.tomcat.util.net.AprEndpoint$Sendfile.run()  At AprEndpoint.java:[line 2379]
M M UW: Unconditional wait in org.apache.tomcat.util.net.AprEndpoint$Sendfile.run()  At AprEndpoint.java:[line 2250]
M V EI: org.apache.jasper.compiler.Node$CustomTag.getJspAttributes() may expose internal representation by returning Node$CustomTag.jspAttrs  At Node.java:[line 1558]
M V EI: org.apache.jasper.compiler.Node$CustomTag.getVariableInfos() may expose internal representation by returning Node$CustomTag.varInfos  At Node.java:[line 1638]
M V EI2: org.apache.jasper.compiler.Node$CustomTag.setJspAttributes(Node$JspAttribute[]) may expose internal representation by storing an externally mutable object into Node$CustomTag.jspAttrs  At Node.java:[line 1554]
M D SF: Switch statement found in org.apache.jasper.compiler.Node$CustomTag.setScriptingVars(List, int) where default case is missing  At Node.java:[lines 1658-1666]
M D SF: Switch statement found in org.apache.jasper.compiler.Node$CustomTag.getScriptingVars(int) where default case is missing  At Node.java:[lines 1678-1686]
M V EI2: new org.eclipse.jdt.internal.compiler.codegen.ExceptionLabel(CodeStream, TypeBinding, TypeReference, Annotation[]) may expose internal representation by storing an externally mutable object into ExceptionLabel.se7Annotations  At ExceptionLabel.java:[line 32]
M D RCN: Redundant nullcheck of strValue, which is known to be non-null in org.apache.tomcat.util.buf.UDecoder.convert(MessageBytes, boolean)  Redundant null check at UDecoder.java:[line 195]
M D SF: Switch statement found in org.apache.tomcat.util.buf.UDecoder.convert(MessageBytes, boolean) where default case is missing  At UDecoder.java:[lines 192-210]
H I Dm: Found reliance on default encoding in org.apache.tomcat.util.buf.UDecoder.URLDecode(byte[], String, boolean): new String(byte[], int, int)  At UDecoder.java:[line 388]
M X OBL: org.apache.jasper.compiler.SmapUtil$SDEInstaller.install(File) may fail to clean up java.io.OutputStream on checked exception  Obligation to clean up resource created at SmapUtil.java:[line 226] is not discharged
M V EI: org.apache.coyote.ajp.AjpMessage.getBuffer() may expose internal representation by returning AjpMessage.buf  At AjpMessage.java:[line 118]
M V EI: javax.servlet.jsp.tagext.TagLibraryInfo.getTagFiles() may expose internal representation by returning TagLibraryInfo.tagFiles  At TagLibraryInfo.java:[line 125]
M V EI: javax.servlet.jsp.tagext.TagLibraryInfo.getFunctions() may expose internal representation by returning TagLibraryInfo.functions  At TagLibraryInfo.java:[line 185]
M V EI: javax.servlet.jsp.tagext.TagLibraryInfo.getTags() may expose internal representation by returning TagLibraryInfo.tags  At TagLibraryInfo.java:[line 113]
M B Nm: The field name org.eclipse.jdt.internal.compiler.ast.OperatorExpression.OperatorSignatures doesn't start with a lower case letter  In OperatorExpression.java
M P SBSC: org.eclipse.jdt.internal.compiler.ast.OperatorExpression.generateTableTestCase() concatenates strings using + in a loop  At OperatorExpression.java:[line 164]
M D RCN: Redundant nullcheck of credentials, which is known to be non-null in org.apache.catalina.realm.JDBCRealm.authenticate(Connection, String, String)  Redundant null check at JDBCRealm.java:[line 389]
M M UL: org.apache.tomcat.jdbc.pool.MultiLockFairBlockingQueue.poll(long, TimeUnit) does not release lock on all exception paths  At MultiLockFairBlockingQueue.java:[line 149]
M V EI: org.eclipse.jdt.internal.compiler.codegen.VerificationTypeInfo.readableName() may expose internal representation by returning VerificationTypeInfo.constantPoolName  At VerificationTypeInfo.java:[line 197]
M V EI: org.eclipse.jdt.internal.compiler.codegen.VerificationTypeInfo.constantPoolName() may expose internal representation by returning VerificationTypeInfo.constantPoolName  At VerificationTypeInfo.java:[line 194]
M V EI2: new org.eclipse.jdt.internal.compiler.codegen.VerificationTypeInfo(int, int, char[]) may expose internal representation by storing an externally mutable object into VerificationTypeInfo.constantPoolName  At VerificationTypeInfo.java:[line 78]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.VerificationTypeInfo.toString() where default case is missing  At VerificationTypeInfo.java:[lines 144-170]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.VerificationTypeInfo.replaceWithElementType() where default case is missing  At VerificationTypeInfo.java:[lines 205-234]
M V EI: org.apache.jasper.compiler.Node$JspElement.getJspAttributes() may expose internal representation by returning Node$JspElement.jspAttrs  At Node.java:[line 1290]
M V EI2: org.apache.jasper.compiler.Node$JspElement.setJspAttributes(Node$JspAttribute[]) may expose internal representation by storing an externally mutable object into Node$JspElement.jspAttrs  At Node.java:[line 1286]
M P Bx: org.apache.jasper.compiler.Node$TemplateText.addSmap(int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Node.java:[line 2082]
M V EI: org.apache.tomcat.util.descriptor.web.SecurityCollection.findOmittedMethods() may expose internal representation by returning SecurityCollection.omittedMethods  At SecurityCollection.java:[line 269]
M V EI: org.apache.tomcat.util.descriptor.web.SecurityCollection.findPatterns() may expose internal representation by returning SecurityCollection.patterns  At SecurityCollection.java:[line 297]
M V EI: org.apache.tomcat.util.descriptor.web.SecurityCollection.findMethods() may expose internal representation by returning SecurityCollection.methods  At SecurityCollection.java:[line 257]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.InferenceContext.toString() where default case is missing  At InferenceContext.java:[lines 85-90]
M D ST: Write to static field org.apache.catalina.session.StandardSession.sessionContext from instance method org.apache.catalina.session.StandardSession.getSessionContext()  At StandardSession.java:[line 1175]
M B Se: The field org.apache.catalina.session.StandardSession.support is transient but isn't set by deserialization  In StandardSession.java
M B Se: The field org.apache.catalina.session.StandardSession.notes is transient but isn't set by deserialization  In StandardSession.java
M B Se: The field org.apache.catalina.session.StandardSession.listeners is transient but isn't set by deserialization  In StandardSession.java
M P Bx: org.apache.jasper.compiler.ScriptingVariabler$CustomTagCounter.visit(Node$CustomTag) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At ScriptingVariabler.java:[line 57]
M V EI: org.apache.tomcat.util.descriptor.web.FilterMap.getURLPatterns() may expose internal representation by returning FilterMap.urlPatterns  At FilterMap.java:[line 125]
M V EI: org.apache.tomcat.util.descriptor.web.FilterMap.getServletNames() may expose internal representation by returning FilterMap.servletNames  At FilterMap.java:[line 80]
M V EI2: new org.apache.catalina.tribes.group.RpcMessage(byte[], byte[], Serializable) may expose internal representation by storing an externally mutable object into RpcMessage.uuid  At RpcMessage.java:[line 41]
M V EI2: new org.apache.catalina.tribes.group.RpcMessage(byte[], byte[], Serializable) may expose internal representation by storing an externally mutable object into RpcMessage.rpcId  At RpcMessage.java:[line 40]
M X OBL: org.apache.catalina.realm.DataSourceRealm.credentials(Connection, String) may fail to clean up java.sql.Statement on checked exception  Obligation to clean up resource created at DataSourceRealm.java:[line 528] is not discharged
M X OBL: org.apache.catalina.realm.DataSourceRealm.roles(Connection, String) may fail to clean up java.sql.Statement on checked exception  Obligation to clean up resource created at DataSourceRealm.java:[line 548] is not discharged
M D REC: Exception is caught when Exception is not thrown in org.apache.jasper.compiler.JspRuntimeContext.initSecurity()  At JspRuntimeContext.java:[line 534]
M V EI: org.apache.tomcat.util.modeler.ManagedBean.getNotifications() may expose internal representation by returning ManagedBean.notifications  At ManagedBean.java:[line 189]
M V EI: org.apache.tomcat.jdbc.pool.PoolProperties.getJdbcInterceptorsAsArray() may expose internal representation by returning PoolProperties.interceptors  At PoolProperties.java:[line 497]
M B Se: Class org.apache.tomcat.jdbc.pool.PoolProperties defines non-transient non-serializable instance field validator  In PoolProperties.java
H I Dm: Found reliance on default encoding in org.apache.tomcat.jdbc.pool.PoolProperties.getProperties(String, Properties): String.getBytes()  At PoolProperties.java:[line 1183]
M V EI: org.apache.jasper.compiler.ELNode$Function.getParameters() may expose internal representation by returning ELNode$Function.parameters  At ELNode.java:[line 183]
M V EI2: org.apache.jasper.compiler.ELNode$Function.setParameters(String[]) may expose internal representation by storing an externally mutable object into ELNode$Function.parameters  At ELNode.java:[line 179]
M V EI: org.apache.catalina.tribes.io.XByteBuffer.getBytesDirect() may expose internal representation by returning XByteBuffer.buf  At XByteBuffer.java:[line 129]
M B Dm: org.apache.catalina.startup.Bootstrap.initClassLoaders() invokes System.exit(...), which shuts down the entire virtual machine  At Bootstrap.java:[line 156]
M D DLS: Dead store to url in org.apache.catalina.startup.Bootstrap.createClassLoader(String, ClassLoader)  At Bootstrap.java:[line 178]
M P WMI: org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool.clearOldest() makes inefficient use of keySet iterator instead of entrySet iterator  At GenericKeyedObjectPool.java:[line 754]
M P WMI: org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool.reuseCapacity() makes inefficient use of keySet iterator instead of entrySet iterator  At GenericKeyedObjectPool.java:[line 816]
M P WMI: org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool.hasBorrowWaiters() makes inefficient use of keySet iterator instead of entrySet iterator  At GenericKeyedObjectPool.java:[line 853]
M P WMI: org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool.getNumWaitersByKey() makes inefficient use of keySet iterator instead of entrySet iterator  At GenericKeyedObjectPool.java:[line 1379]
M P WMI: org.apache.tomcat.dbcp.pool2.impl.GenericKeyedObjectPool.listAllObjects() makes inefficient use of keySet iterator instead of entrySet iterator  At GenericKeyedObjectPool.java:[line 1409]
M V EI: org.apache.catalina.tribes.membership.MemberImpl.getHost() may expose internal representation by returning MemberImpl.host  At MemberImpl.java:[line 447]
M V EI: org.apache.catalina.tribes.membership.MemberImpl.getData(boolean, boolean) may expose internal representation by returning MemberImpl.dataPkg  At MemberImpl.java:[line 216]
M V EI: org.apache.catalina.tribes.membership.MemberImpl.getUniqueId() may expose internal representation by returning MemberImpl.uniqueId  At MemberImpl.java:[line 487]
M V EI: org.apache.catalina.tribes.membership.MemberImpl.getDomain() may expose internal representation by returning MemberImpl.domain  At MemberImpl.java:[line 502]
M V EI: org.apache.catalina.tribes.membership.MemberImpl.getPayload() may expose internal representation by returning MemberImpl.payload  At MemberImpl.java:[line 492]
M V EI2: org.apache.catalina.tribes.membership.MemberImpl.setHost(byte[]) may expose internal representation by storing an externally mutable object into MemberImpl.host  At MemberImpl.java:[line 585]
M V EI: org.apache.catalina.tribes.membership.MemberImpl.getCommand() may expose internal representation by returning MemberImpl.command  At MemberImpl.java:[line 497]
M M UG: org.apache.catalina.tribes.membership.MemberImpl.getUniqueId() is unsynchronized, org.apache.catalina.tribes.membership.MemberImpl.setUniqueId(byte[]) is synchronized  At MemberImpl.java:[line 487]
M M UG: org.apache.catalina.tribes.membership.MemberImpl.getSecurePort() is unsynchronized, org.apache.catalina.tribes.membership.MemberImpl.setSecurePort(int) is synchronized  At MemberImpl.java:[line 507]
M M UG: org.apache.catalina.tribes.membership.MemberImpl.getUdpPort() is unsynchronized, org.apache.catalina.tribes.membership.MemberImpl.setUdpPort(int) is synchronized  At MemberImpl.java:[line 512]
M M UG: org.apache.catalina.tribes.membership.MemberImpl.getPort() is unsynchronized, org.apache.catalina.tribes.membership.MemberImpl.setPort(int) is synchronized  At MemberImpl.java:[line 438]
M M UG: org.apache.catalina.tribes.membership.MemberImpl.getHost() is unsynchronized, org.apache.catalina.tribes.membership.MemberImpl.setHost(byte[]) is synchronized  At MemberImpl.java:[line 447]
M M UG: org.apache.catalina.tribes.membership.MemberImpl.getCommand() is unsynchronized, org.apache.catalina.tribes.membership.MemberImpl.setCommand(byte[]) is synchronized  At MemberImpl.java:[line 497]
M M UG: org.apache.catalina.tribes.membership.MemberImpl.getPayload() is unsynchronized, org.apache.catalina.tribes.membership.MemberImpl.setPayload(byte[]) is synchronized  At MemberImpl.java:[line 492]
M M UG: org.apache.catalina.tribes.membership.MemberImpl.getDomain() is unsynchronized, org.apache.catalina.tribes.membership.MemberImpl.setDomain(byte[]) is synchronized  At MemberImpl.java:[line 502]
M D RCN: Redundant nullcheck of methodParams, which is known to be non-null in org.apache.tomcat.util.IntrospectionUtils.findMethod(Class, String, Class[])  Redundant null check at IntrospectionUtils.java:[line 317]
M D RCN: Redundant nullcheck of methods, which is known to be non-null in org.apache.tomcat.util.IntrospectionUtils.findMethod(Class, String, Class[])  Redundant null check at IntrospectionUtils.java:[line 312]
M P Bx: org.apache.tomcat.util.IntrospectionUtils.setProperty(Object, String, String, boolean) invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At IntrospectionUtils.java:[line 91]
M P Bx: org.apache.tomcat.util.IntrospectionUtils.setProperty(Object, String, String, boolean) invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At IntrospectionUtils.java:[line 83]
M P Bx: org.apache.tomcat.util.IntrospectionUtils.convert(String, Class) invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At IntrospectionUtils.java:[line 408]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.numberOfDifferentLocals(StackMapFrame) where default case is missing  At StackMapFrame.java:[lines 155-158]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.getNumberOfLocals() where default case is missing  At StackMapFrame.java:[lines 287-290]
H P Dm: Invocation of java.net.URL.equals(Object), which blocks to do domain name resolution, in org.apache.tomcat.util.descriptor.tld.TldResourcePath.equals(Object)  At TldResourcePath.java:[line 157]
H P Dm: Invocation of java.net.URL.hashCode(), which blocks to do domain name resolution, in org.apache.tomcat.util.descriptor.tld.TldResourcePath.hashCode()  At TldResourcePath.java:[line 164]
M P Bx: org.apache.catalina.session.StandardManager.doUnload() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At StandardManager.java:[line 394]
M B RV: Exceptional return value of java.io.File.delete() ignored in org.apache.catalina.session.StandardManager.doLoad()  At StandardManager.java:[line 289]
H D DLS: Dead store to unused in org.apache.jasper.compiler.ELFunctionMapper.map(Node$Nodes)  At ELFunctionMapper.java:[line 68]
M V EI: org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapEntry.getBackupNodes() may expose internal representation by returning AbstractReplicatedMap$MapEntry.backupNodes  At AbstractReplicatedMap.java:[line 1248]
M V EI2: org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapEntry.setBackupNodes(Member[]) may expose internal representation by storing an externally mutable object into AbstractReplicatedMap$MapEntry.backupNodes  At AbstractReplicatedMap.java:[line 1244]
M V EI: org.apache.naming.NamingContext.getEnvironment() may expose internal representation by returning NamingContext.env  At NamingContext.java:[line 744]
M D IM: Computation of average could overflow in org.apache.catalina.mapper.Mapper.find(Mapper$MapElement[], CharChunk, int, int)  At Mapper.java:[line 1183]
M D IM: Computation of average could overflow in org.apache.catalina.mapper.Mapper.findIgnoreCase(Mapper$MapElement[], CharChunk, int, int)  At Mapper.java:[line 1238]
M D IM: Computation of average could overflow in org.apache.catalina.mapper.Mapper.find(Mapper$MapElement[], String)  At Mapper.java:[line 1285]
M B RV: Exceptional return value of java.util.concurrent.BlockingQueue.offer(Object) ignored in org.apache.tomcat.jdbc.pool.ConnectionPool.release(PooledConnection)  At ConnectionPool.java:[line 601]
H I Dm: Found reliance on default encoding in org.apache.tomcat.jdbc.pool.ConnectionPool.getStackTrace(Throwable): java.io.ByteArrayOutputStream.toString()  At ConnectionPool.java:[line 1077]
H I Dm: Found reliance on default encoding in org.apache.tomcat.jdbc.pool.ConnectionPool.getStackTrace(Throwable): new java.io.PrintStream(OutputStream)  At ConnectionPool.java:[line 1075]
M D NP: Load of known null value in org.apache.catalina.security.SecurityUtil.doAsPrivilege(String, Servlet, Class[], Object[], Principal)  At SecurityUtil.java:[line 159]
M D NP: Load of known null value in org.apache.catalina.security.SecurityUtil.doAsPrivilege(String, Filter, Class[], Object[], Principal)  At SecurityUtil.java:[line 244]
H D UC: Useless condition: it's known that this.paramTypes.length != 0 at this point  At CallMethodRule.java:[line 352]
M P Bx: org.apache.tomcat.util.modeler.Registry.getId(String, String) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Registry.java:[line 320]
M P Bx: org.apache.tomcat.util.modeler.Registry.convertValue(String, String) invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At Registry.java:[line 526]
M P Bx: org.apache.tomcat.util.modeler.Registry.convertValue(String, String) invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At Registry.java:[line 523]
M X OBL: org.apache.tomcat.util.modeler.Registry.load(String, Object, String) may fail to clean up java.io.InputStream  Obligation to clean up resource created at Registry.java:[line 561] is not discharged
M M VO: Increment of volatile field org.apache.catalina.session.ManagerBase.duplicates in org.apache.catalina.session.ManagerBase.generateSessionId()  At ManagerBase.java:[line 873]
M V EI: org.apache.tomcat.util.descriptor.web.ContextService.getServiceqname() may expose internal representation by returning ContextService.serviceqname  At ContextService.java:[line 133]
M V EI2: org.apache.tomcat.util.descriptor.web.ContextService.setServiceqname(String[]) may expose internal representation by storing an externally mutable object into ContextService.serviceqname  At ContextService.java:[line 149]
M D ST: Write to static field org.apache.tomcat.util.net.NioBlockingSelector.threadCounter from instance method org.apache.tomcat.util.net.NioBlockingSelector.open(Selector)  At NioBlockingSelector.java:[line 61]
M V FI: org.apache.catalina.tribes.group.RpcChannel.finalize() is public; should be protected  At RpcChannel.java:[lines 182-184]
M V EI: org.apache.catalina.tribes.group.RpcChannel.getRpcId() may expose internal representation by returning RpcChannel.rpcId  At RpcChannel.java:[line 203]
M V EI2: new org.apache.catalina.tribes.group.RpcChannel(byte[], Channel, RpcCallback) may expose internal representation by storing an externally mutable object into RpcChannel.rpcId  At RpcChannel.java:[line 66]
M V EI2: org.apache.catalina.tribes.group.RpcChannel.setRpcId(byte[]) may expose internal representation by storing an externally mutable object into RpcChannel.rpcId  At RpcChannel.java:[line 215]
H I Dm: Found reliance on default encoding in org.apache.catalina.loader.WebappClassLoaderBase.findResourceInternal(String, String, boolean): new String(byte[])  At WebappClassLoaderBase.java:[line 2619]
M V EI: org.apache.tomcat.util.descriptor.web.SecurityConstraint.findCollections() may expose internal representation by returning SecurityConstraint.collections  At SecurityConstraint.java:[line 345]
M V EI: org.apache.tomcat.util.descriptor.web.SecurityConstraint.findAuthRoles() may expose internal representation by returning SecurityConstraint.authRoles  At SecurityConstraint.java:[line 314]
M V EI: org.apache.tomcat.util.net.AbstractEndpoint.getSslEnabledProtocolsArray() may expose internal representation by returning AbstractEndpoint.sslEnabledProtocolsarr  At AbstractEndpoint.java:[line 1020]
M D REC: Exception is caught when Exception is not thrown in org.apache.tomcat.util.net.AbstractEndpoint.unlockAccept()  At AbstractEndpoint.java:[line 672]
M B CN: org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage defines clone() but doesn't implement Cloneable  At AbstractReplicatedMap.java:[lines 1505-1508]
M V EI: org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage.getBackupNodes() may expose internal representation by returning AbstractReplicatedMap$MapMessage.nodes  At AbstractReplicatedMap.java:[line 1466]
M V EI: org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage.getKeyData() may expose internal representation by returning AbstractReplicatedMap$MapMessage.keydata  At AbstractReplicatedMap.java:[line 1438]
M V EI2: new org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage(byte[], int, boolean, Serializable, Serializable, byte[], Member, Member[]) may expose internal representation by storing an externally mutable object into AbstractReplicatedMap$MapMessage.mapId  At AbstractReplicatedMap.java:[line 1396]
M V EI2: new org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage(byte[], int, boolean, Serializable, Serializable, byte[], Member, Member[]) may expose internal representation by storing an externally mutable object into AbstractReplicatedMap$MapMessage.nodes  At AbstractReplicatedMap.java:[line 1402]
M V EI2: new org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage(byte[], int, boolean, Serializable, Serializable, byte[], Member, Member[]) may expose internal representation by storing an externally mutable object into AbstractReplicatedMap$MapMessage.diffvalue  At AbstractReplicatedMap.java:[line 1401]
M V EI: org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage.getDiffValue() may expose internal representation by returning AbstractReplicatedMap$MapMessage.diffvalue  At AbstractReplicatedMap.java:[line 1462]
M V EI: org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage.getValueData() may expose internal representation by returning AbstractReplicatedMap$MapMessage.valuedata  At AbstractReplicatedMap.java:[line 1458]
M V EI: org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage.getMapId() may expose internal representation by returning AbstractReplicatedMap$MapMessage.mapId  At AbstractReplicatedMap.java:[line 1478]
M B Se: The field org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage.value is transient but isn't set by deserialization  In AbstractReplicatedMap.java
M B Se: The field org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage.key is transient but isn't set by deserialization  In AbstractReplicatedMap.java
H I Dm: Found reliance on default encoding in org.apache.catalina.tribes.tipis.AbstractReplicatedMap$MapMessage.toString(): new String(byte[])  At AbstractReplicatedMap.java:[line 1365]
M B ES: Comparison of String objects using == or != in org.apache.tomcat.util.digester.Digester.updateAttributes(Attributes)   At Digester.java:[line 1975]
H B ES: Comparison of String objects using == or != in org.apache.tomcat.util.digester.Digester.updateBodyText(StringBuilder)   At Digester.java:[line 2003]
M V EI2: org.apache.tomcat.util.http.fileupload.ParameterParser.parse(char[], int, int, char) may expose internal representation by storing an externally mutable object into ParameterParser.chars  At ParameterParser.java:[line 302]
H B DE: org.apache.catalina.tribes.membership.McastServiceImpl.stop(int) might ignore java.lang.Exception  At McastServiceImpl.java:[line 332]
H P Dm: org.apache.catalina.core.StandardHost.findReloadedContextMemoryLeaks() forces garbage collection; extremely dubious except in benchmarking code  At StandardHost.java:[line 748]
M P WMI: org.apache.catalina.core.ApplicationHttpRequest.mergeParameters() makes inefficient use of keySet iterator instead of entrySet iterator  At ApplicationHttpRequest.java:[line 889]
M V EI: org.apache.catalina.webresources.AbstractArchiveResource.getCertificates() may expose internal representation by returning AbstractArchiveResource.certificates  At AbstractArchiveResource.java:[line 208]
M D RCN: Redundant nullcheck of m, which is known to be non-null in org.apache.catalina.loader.WebappLoader.getClasspath(ClassLoader)  Redundant null check at WebappLoader.java:[line 651]
M V EI: org.apache.tomcat.util.http.fileupload.disk.DiskFileItem.get() may expose internal representation by returning DiskFileItem.cachedContent  At DiskFileItem.java:[line 288]
M B RV: Exceptional return value of java.io.File.delete() ignored in org.apache.tomcat.util.http.fileupload.disk.DiskFileItem.delete()  At DiskFileItem.java:[line 426]
M B RV: Exceptional return value of java.io.File.delete() ignored in org.apache.tomcat.util.http.fileupload.disk.DiskFileItem.finalize()  At DiskFileItem.java:[line 544]
H I Dm: Found reliance on default encoding in org.apache.tomcat.util.http.fileupload.disk.DiskFileItem.getString(): new String(byte[])  At DiskFileItem.java:[line 343]
M V EI2: org.apache.tomcat.util.net.Nio2Endpoint.setOomParachuteData(byte[]) may expose internal representation by storing an externally mutable object into Nio2Endpoint.oomParachuteData  At Nio2Endpoint.java:[line 184]
M V EI: org.apache.tomcat.util.net.Nio2Endpoint.getCiphersUsed() may expose internal representation by returning Nio2Endpoint.enabledCiphers  At Nio2Endpoint.java:[line 219]
M V EI: org.apache.tomcat.util.net.Nio2Endpoint.getOomParachuteData() may expose internal representation by returning Nio2Endpoint.oomParachuteData  At Nio2Endpoint.java:[line 479]
M D BC: Unchecked/unconfirmed cast from org.apache.tomcat.util.net.SocketWrapper<org.apache.tomcat.util.net.Nio2Channel> to org.apache.tomcat.util.net.Nio2Endpoint$Nio2SocketWrapper in org.apache.tomcat.util.net.Nio2Endpoint.closeSocket(SocketWrapper, SocketStatus)  At Nio2Endpoint.java:[line 636]
M P SBSC: org.apache.catalina.startup.CredentialHandlerRuleSet.addRuleInstances(Digester) concatenates strings using + in a loop  At CredentialHandlerRuleSet.java:[line 91]
M V EI: org.apache.catalina.core.StandardService.findConnectors() may expose internal representation by returning StandardService.connectors  At StandardService.java:[line 278]
M D RCN: Redundant nullcheck of baseURI, which is known to be non-null in new org.apache.jasper.JspCompilationContext(String, TagInfo, Options, ServletContext, JspServletWrapper, JspRuntimeContext, Jar, boolean)  Redundant null check at JspCompilationContext.java:[line 118]
M V DP: org.apache.jasper.JspCompilationContext.getJspLoader() creates a org.apache.jasper.servlet.JasperLoader classloader, which should be performed within a doPrivileged block  At JspCompilationContext.java:[line 177]
M B RR: org.apache.catalina.connector.CoyoteReader.readLine() ignores result of org.apache.catalina.connector.CoyoteReader.skip(long)  At CoyoteReader.java:[line 201]
H I Dm: Found reliance on default encoding in org.apache.jasper.compiler.JavacErrorDetail.readFile(InputStream): new java.io.InputStreamReader(InputStream)  At JavacErrorDetail.java:[line 221]
M D SF: Switch statement found in org.apache.jasper.compiler.JspUtil.toJavaSourceType(String) where default case is missing  At JspUtil.java:[lines 943-952]
M D IM: Computation of average could overflow in org.apache.jasper.compiler.JspUtil.isJavaKeyword(String)  At JspUtil.java:[line 873]
M B Dm: org.apache.catalina.startup.Catalina.stopServer(String[]) invokes System.exit(...), which shuts down the entire virtual machine  At Catalina.java:[line 435]
M B OS: org.apache.catalina.startup.Catalina.load() may fail to close stream  At Catalina.java:[line 494]
M X OBL: org.apache.catalina.startup.Catalina.load() may fail to clean up java.io.InputStream  Obligation to clean up resource created at Catalina.java:[line 494] is not discharged
M D RV: Return value of org.apache.tomcat.util.net.URL.isSchemeChar(char) ignored, but method has no side effect  At Response.java:[line 85]
M P Bx: org.apache.jasper.compiler.PageInfo.setBufferValue(String, Node, ErrorDispatcher) invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At PageInfo.java:[line 458]
H D UC: Useless condition: it's known that typeName.length != 0 at this point  At ReferenceBinding.java:[line 734]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.sourceName() may expose internal representation by returning ReferenceBinding.sourceName  At ReferenceBinding.java:[line 1751]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.getFileName() may expose internal representation by returning ReferenceBinding.fileName  At ReferenceBinding.java:[line 983]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.constantPoolName() may expose internal representation by returning ReferenceBinding.constantPoolName  At ReferenceBinding.java:[line 875]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.signature() may expose internal representation by returning ReferenceBinding.signature  At ReferenceBinding.java:[line 1745]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.computeId() where default case is missing  At ReferenceBinding.java:[lines 423-856]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.applyCloseableClassWhitelists() where default case is missing  At ReferenceBinding.java:[lines 1816-1840]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith(TypeBinding, Scope)  At ReferenceBinding.java:[line 1246]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ElementValuePair$UnresolvedEnumConstant.getEnumConstantName() may expose internal representation by returning ElementValuePair$UnresolvedEnumConstant.enumConstantName  At ElementValuePair.java:[line 44]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.lookup.TypeBindingVisitor.visit(TypeBindingVisitor, TypeBinding)  At TypeBindingVisitor.java:[line 71]
M C BIT: Bitwise OR of signed byte value computed in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.getElaborationId(int, byte)   At ProblemReporter.java:[line 198]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.importProblem(ImportReference, Binding) where default case is missing  At ProblemReporter.java:[lines 3045-3059]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.javadocVisibilityArgument(int, int) where default case is missing  At ProblemReporter.java:[lines 5570-5586]
M D UC: Useless object stored in variable arguments of method org.eclipse.jdt.internal.compiler.problem.ProblemReporter.nullityMismatchingTypeAnnotation(Expression, TypeBinding, TypeBinding, NullAnnotationMatching)  At ProblemReporter.java:[line 9738]
M D UC: Useless object stored in variable shortArguments of method org.eclipse.jdt.internal.compiler.problem.ProblemReporter.nullityMismatchingTypeAnnotation(Expression, TypeBinding, TypeBinding, NullAnnotationMatching)  At ProblemReporter.java:[line 9739]
M D DLS: Dead store to binding in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.expressionNonNullComparison(Expression, boolean)  At ProblemReporter.java:[line 5700]
M D BC: Unchecked/unconfirmed cast from org.eclipse.jdt.internal.compiler.lookup.MethodBinding to org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidConstructor(Statement, MethodBinding)  At ProblemReporter.java:[line 3527]
M D BC: Unchecked/unconfirmed cast from org.eclipse.jdt.internal.compiler.lookup.MethodBinding to org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidMethod(MessageSend, MethodBinding)  At ProblemReporter.java:[line 4080]
M D BC: Unchecked/unconfirmed cast from org.eclipse.jdt.internal.compiler.lookup.MethodBinding to org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.javadocInvalidConstructor(Statement, MethodBinding, int)  At ProblemReporter.java:[line 4989]
M D BC: Unchecked/unconfirmed cast from org.eclipse.jdt.internal.compiler.lookup.MethodBinding to org.eclipse.jdt.internal.compiler.lookup.ProblemMethodBinding in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.javadocInvalidMethod(MessageSend, MethodBinding, int)  At ProblemReporter.java:[line 5148]
M D BC: instanceof will always return true for all non-null values in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.missingTypeInMethod(ASTNode, MethodBinding), since all org.eclipse.jdt.internal.compiler.ast.MessageSend are instances of org.eclipse.jdt.internal.compiler.ast.MessageSend  At ProblemReporter.java:[line 6229]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(TypeBinding, AnnotationBinding[]) where default case is missing  At LookupEnvironment.java:[lines 979-981]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding(ReferenceBinding[], LookupEnvironment) may expose internal representation by storing an externally mutable object into IntersectionCastTypeBinding.intersectingTypes  At IntersectionCastTypeBinding.java:[line 33]
M V EI: org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding.superInterfaces() may expose internal representation by returning IntersectionCastTypeBinding.intersectingTypes  At IntersectionCastTypeBinding.java:[line 123]
M V EI: org.eclipse.jdt.internal.compiler.lookup.IntersectionCastTypeBinding.getIntersectingTypes() may expose internal representation by returning IntersectionCastTypeBinding.intersectingTypes  At IntersectionCastTypeBinding.java:[line 110]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.BlockScope.emulateOuterAccess(LocalVariableBinding) where default case is missing  At BlockScope.java:[lines 309-316]
M P SBSC: org.eclipse.jdt.internal.compiler.lookup.BlockScope.basicToString(int) concatenates strings using + in a loop  At BlockScope.java:[line 183]
M P SBSC: org.eclipse.jdt.internal.compiler.lookup.BlockScope.toString(int) concatenates strings using + in a loop  At BlockScope.java:[line 1026]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.Scope.createTypeVariables(TypeParameter[], Binding) where default case is missing  At Scope.java:[lines 1104-1117]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.Scope.getBinding(char[], int, InvocationSite, boolean) where one case falls through to the next case  At Scope.java:[lines 2100-2104]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(char[], int, boolean) where one case falls through to the next case  At Scope.java:[lines 3198-3201]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.Scope.typeAnnotationsResolutionScope(Scope) where default case is missing  At Scope.java:[lines 5106-5112]
M P SBSC: org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(ParameterizedTypeBinding, ReferenceBinding, TypeBinding[], Invocation) concatenates strings using + in a loop  At Scope.java:[line 4993]
M C BC: instanceof will always return false in org.eclipse.jdt.internal.compiler.lookup.Scope.getOnlyPackage(char[][]), since a org.eclipse.jdt.internal.compiler.lookup.PackageBinding can't be a org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding  At Scope.java:[line 3023]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.Expression.computeConversion(Scope, TypeBinding, TypeBinding) where default case is missing  At Expression.java:[lines 669-685]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.Expression.postConversionType(Scope) where default case is missing  At Expression.java:[lines 974-997]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding(char[], Binding, int, LookupEnvironment) may expose internal representation by storing an externally mutable object into TypeVariableBinding.sourceName  At TypeVariableBinding.java:[line 63]
M V EI: org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.readableName() may expose internal representation by returning TypeVariableBinding.sourceName  At TypeVariableBinding.java:[line 654]
M V EI: org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.otherUpperBounds() may expose internal representation by returning TypeVariableBinding.superInterfaces  At TypeVariableBinding.java:[line 640]
M V EI: org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.superInterfaces() may expose internal representation by returning TypeVariableBinding.superInterfaces  At TypeVariableBinding.java:[line 721]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.setSuperInterfaces(ReferenceBinding[]) may expose internal representation by storing an externally mutable object into TypeVariableBinding.superInterfaces  At TypeVariableBinding.java:[line 892]
M V EI: org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.genericTypeSignature() may expose internal representation by returning TypeVariableBinding.genericTypeSignature  At TypeVariableBinding.java:[line 384]
M V EI: org.eclipse.jdt.internal.compiler.lookup.WildcardBinding.superInterfaces() may expose internal representation by returning WildcardBinding.superInterfaces  At WildcardBinding.java:[line 829]
M V EI: org.eclipse.jdt.internal.compiler.lookup.WildcardBinding.signature() may expose internal representation by returning WildcardBinding.signature  At WildcardBinding.java:[line 764]
M V EI: org.eclipse.jdt.internal.compiler.lookup.WildcardBinding.genericTypeSignature() may expose internal representation by returning WildcardBinding.genericSignature  At WildcardBinding.java:[line 483]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.WildcardBinding.resolve() where default case is missing  At WildcardBinding.java:[lines 705-719]
M V EI: org.eclipse.jdt.internal.compiler.lookup.InferenceVariable.sourceName() may expose internal representation by returning InferenceVariable.sourceName  At InferenceVariable.java:[line 83]
M V EI: org.eclipse.jdt.internal.compiler.lookup.InferenceVariable.readableName() may expose internal representation by returning InferenceVariable.sourceName  At InferenceVariable.java:[line 87]
M C EC: Using .equals to compare two char[]'s, (equivalent to ==) in org.eclipse.jdt.internal.compiler.lookup.InferenceVariable.equals(Object)  At InferenceVariable.java:[line 111]
M C DMI: Invocation of hashCode on array in org.eclipse.jdt.internal.compiler.lookup.InferenceVariable.hashCode()  At InferenceVariable.java:[line 104]
M V EI: org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.genericTypeSignature() may expose internal representation by returning CaptureBinding.genericTypeSignature  At CaptureBinding.java:[line 115]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.initializeBounds(Scope, ParameterizedTypeBinding) where default case is missing  At CaptureBinding.java:[lines 128-159]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.CaptureBinding18.setUpperBounds(TypeBinding[], ReferenceBinding) may expose internal representation by storing an externally mutable object into CaptureBinding18.upperBounds  At CaptureBinding18.java:[line 29]
M V EI: org.eclipse.jdt.internal.compiler.lookup.CaptureBinding18.readableName() may expose internal representation by returning CaptureBinding18.originalName  At CaptureBinding18.java:[line 288]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.CaptureBinding18(ReferenceBinding, char[], char[], int, int, LookupEnvironment) may expose internal representation by storing an externally mutable object into CaptureBinding18.originalName  At CaptureBinding18.java:[line 25]
M V EI: org.eclipse.jdt.internal.compiler.lookup.CaptureBinding18.genericTypeSignature() may expose internal representation by returning CaptureBinding18.genericTypeSignature  At CaptureBinding18.java:[line 265]
M V EI: org.eclipse.jdt.internal.compiler.lookup.CaptureBinding18.shortReadableName() may expose internal representation by returning CaptureBinding18.originalName  At CaptureBinding18.java:[line 314]
M P SBSC: org.eclipse.jdt.internal.compiler.lookup.MethodScope.basicToString(int) concatenates strings using + in a loop  At MethodScope.java:[line 80]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.MethodBinding(int, char[], TypeBinding, TypeBinding[], ReferenceBinding[], ReferenceBinding) may expose internal representation by storing an externally mutable object into MethodBinding.selector  At MethodBinding.java:[line 68]
M V EI: org.eclipse.jdt.internal.compiler.lookup.MethodBinding.signature() may expose internal representation by returning MethodBinding.signature  At MethodBinding.java:[line 989]
M V EI: org.eclipse.jdt.internal.compiler.lookup.MethodBinding.constantPoolName() may expose internal representation by returning MethodBinding.selector  At MethodBinding.java:[line 476]
M V EI: org.eclipse.jdt.internal.compiler.lookup.MethodBinding.signature(ClassFile) may expose internal representation by returning MethodBinding.signature  At MethodBinding.java:[line 1095]
M V EI: org.eclipse.jdt.internal.compiler.lookup.MethodBinding.typeVariables() may expose internal representation by returning MethodBinding.typeVariables  At MethodBinding.java:[line 1256]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.Annotation.detectStandardAnnotation(Scope, ReferenceBinding, MemberValuePair) where default case is missing  At Annotation.java:[lines 314-416]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(BlockScope) where default case is missing  At Annotation.java:[lines 882-948]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.Annotation.isAnnotationTargetAllowed(Annotation, BlockScope, TypeBinding, int) where default case is missing  At Annotation.java:[lines 972-979]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference(char[], int, Annotation[][], long) may expose internal representation by storing an externally mutable object into ArrayTypeReference.annotationsOnDimensions  At ArrayTypeReference.java:[line 47]
M V EI2: org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.setAnnotationsOnDimensions(Annotation[][]) may expose internal representation by storing an externally mutable object into ArrayTypeReference.annotationsOnDimensions  At ArrayTypeReference.java:[line 73]
M V EI: org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.getAnnotationsOnDimensions(boolean) may expose internal representation by returning ArrayTypeReference.annotationsOnDimensions  At ArrayTypeReference.java:[line 64]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.TypeParameter.getAllAnnotationContexts(int, int, List) where default case is missing  At TypeParameter.java:[lines 63-68]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ArrayBinding.genericTypeSignature() may expose internal representation by returning ArrayBinding.genericTypeSignature  At ArrayBinding.java:[line 232]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.ArrayBinding.setTypeAnnotations(AnnotationBinding[], boolean) may expose internal representation by storing an externally mutable object into ArrayBinding.typeAnnotations  At ArrayBinding.java:[line 390]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ArrayBinding.constantPoolName() may expose internal representation by returning ArrayBinding.constantPoolName  At ArrayBinding.java:[line 152]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.typeToRecord(TypeBinding) where default case is missing  At CompilationUnitScope.java:[lines 806-816]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding.toString() where default case is missing  At LocalVariableBinding.java:[lines 242-250]
M P SBSC: org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding.toString() concatenates strings using + in a loop  At LocalVariableBinding.java:[line 259]
M B Nm: The field name org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.CoverageTestId doesn't start with a lower case letter  In UnconditionalFlowInfo.java
M P SBSC: org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.toString() concatenates strings using + in a loop  At UnconditionalFlowInfo.java:[line 1987]
M V EI: org.eclipse.jdt.internal.compiler.lookup.CatchParameterBinding.getPreciseTypes() may expose internal representation by returning CatchParameterBinding.preciseTypes  At CatchParameterBinding.java:[line 24]
M D ST: Write to static field org.eclipse.jdt.internal.compiler.codegen.CodeStream.noLabels from instance method org.eclipse.jdt.internal.compiler.codegen.CodeStream.init(ClassFile)  At CodeStream.java:[line 4133]
M D ST: Write to static field org.eclipse.jdt.internal.compiler.codegen.CodeStream.noExceptionHandlers from instance method org.eclipse.jdt.internal.compiler.codegen.CodeStream.init(ClassFile)  At CodeStream.java:[line 4126]
M D ST: Write to static field org.eclipse.jdt.internal.compiler.codegen.CodeStream.noVisibleLocals from instance method org.eclipse.jdt.internal.compiler.codegen.CodeStream.init(ClassFile)  At CodeStream.java:[line 4112]
M D ST: Write to static field org.eclipse.jdt.internal.compiler.codegen.CodeStream.noLocals from instance method org.eclipse.jdt.internal.compiler.codegen.CodeStream.init(ClassFile)  At CodeStream.java:[line 4119]
M C INT: Bad comparison of signed byte with 127 in org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateInlinedValue(byte)  At CodeStream.java:[line 2137]
M P Bx: org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateSyntheticBodyForDeserializeLambda(SyntheticMethodBinding, SyntheticMethodBinding[]) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At CodeStream.java:[line 2538]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.checkcast(int) where default case is missing  At CodeStream.java:[lines 635-658]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.fieldAccess(byte, int, char[], char[], char[]) where default case is missing  At CodeStream.java:[lines 1274-1298]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateBoxingConversion(int) where default case is missing  At CodeStream.java:[lines 1526-1714]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateConstant(Constant, int) where default case is missing  At CodeStream.java:[lines 1827-1853]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateImplicitConversion(int) where default case is missing  At CodeStream.java:[lines 1986-2096]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateUnboxingConversion(int) where default case is missing  At CodeStream.java:[lines 3127-3200]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.getBaseTypeValue(int) where default case is missing  At CodeStream.java:[lines 3232-3305]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.getTYPE(int) where default case is missing  At CodeStream.java:[lines 3393-3468]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.newWrapperFor(int) where default case is missing  At CodeStream.java:[lines 6160-6186]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.codegen.CodeStream.sendOperator(int, int) where default case is missing  At CodeStream.java:[lines 6908-6922]
M B Nm: The field name org.eclipse.jdt.internal.compiler.codegen.CodeStream.ImplicitThis doesn't start with a lower case letter  In CodeStream.java
M P WMI: org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateSyntheticBodyForDeserializeLambda(SyntheticMethodBinding, SyntheticMethodBinding[]) makes inefficient use of keySet iterator instead of entrySet iterator  At CodeStream.java:[line 2592]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.memberTypes() may expose internal representation by returning ParameterizedTypeBinding.memberTypes  At ParameterizedTypeBinding.java:[line 917]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.methods() may expose internal representation by returning ParameterizedTypeBinding.methods  At ParameterizedTypeBinding.java:[line 948]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.genericTypeSignature() may expose internal representation by returning ParameterizedTypeBinding.genericTypeSignature  At ParameterizedTypeBinding.java:[line 506]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.signature() may expose internal representation by returning ParameterizedTypeBinding.signature  At ParameterizedTypeBinding.java:[line 1173]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.superInterfaces() may expose internal representation by returning ParameterizedTypeBinding.superInterfaces  At ParameterizedTypeBinding.java:[line 1247]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.unResolvedFields() may expose internal representation by returning ParameterizedTypeBinding.fields  At ParameterizedTypeBinding.java:[line 1381]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.fields() may expose internal representation by returning ParameterizedTypeBinding.fields  At ParameterizedTypeBinding.java:[line 439]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.typeArguments() may expose internal representation by returning ParameterizedTypeBinding.arguments  At ParameterizedTypeBinding.java:[line 1377]
M V EI: org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding.genericTypeSignature() may expose internal representation by returning RawTypeBinding.genericTypeSignature  At RawTypeBinding.java:[line 159]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.util.Util.computeOuterMostVisibility(TypeDeclaration, int) where default case is missing  At Util.java:[lines 366-377]
M B RV: Exceptional return value of java.io.File.mkdirs() ignored in org.eclipse.jdt.internal.compiler.util.Util.buildAllDirectoriesInto(String, String)  At Util.java:[line 279]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.util.Util.getInputStreamAsCharArray(InputStream, int, String): new java.io.InputStreamReader(InputStream)  At Util.java:[line 565]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.InferenceSubstitution(LookupEnvironment, InferenceVariable[]) may expose internal representation by storing an externally mutable object into InferenceSubstitution.variables  At InferenceSubstitution.java:[line 23]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference(char[][], int, Annotation[][], long[]) may expose internal representation by storing an externally mutable object into ArrayQualifiedTypeReference.annotationsOnDimensions  At ArrayQualifiedTypeReference.java:[line 34]
M V EI2: org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference.setAnnotationsOnDimensions(Annotation[][]) may expose internal representation by storing an externally mutable object into ArrayQualifiedTypeReference.annotationsOnDimensions  At ArrayQualifiedTypeReference.java:[line 62]
M V EI: org.eclipse.jdt.internal.compiler.ast.ArrayQualifiedTypeReference.getAnnotationsOnDimensions(boolean) may expose internal representation by returning ArrayQualifiedTypeReference.annotationsOnDimensions  At ArrayQualifiedTypeReference.java:[line 53]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduceSubType(Scope, TypeBinding, TypeBinding) where one case falls through to the next case  At ConstraintTypeFormula.java:[lines 305-308]
M P Bx: org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream.addFramePosition(int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At StackMapFrameCodeStream.java:[line 207]
M P Bx: org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream.removeFramePosition(int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At StackMapFrameCodeStream.java:[line 220]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.ClassScope.buildFields() where default case is missing  At ClassScope.java:[lines 128-131]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.ClassScope.checkAndSetModifiers() where default case is missing  At ClassScope.java:[lines 479-513]
M V EI: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.dumpBytes() may expose internal representation by returning ConstantPool.poolContent  At ConstantPool.java:[line 325]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.SingleTypeReference(char[], long) may expose internal representation by storing an externally mutable object into SingleTypeReference.token  At SingleTypeReference.java:[line 27]
M V EI: org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getLastToken() may expose internal representation by returning SingleTypeReference.token  At SingleTypeReference.java:[line 45]
M V EI: org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference.getTypeName() may expose internal representation by returning QualifiedTypeReference.tokens  At QualifiedTypeReference.java:[line 162]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference(char[][], long[]) may expose internal representation by storing an externally mutable object into QualifiedTypeReference.tokens  At QualifiedTypeReference.java:[line 25]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference(char[][], long[]) may expose internal representation by storing an externally mutable object into QualifiedTypeReference.sourcePositions  At QualifiedTypeReference.java:[line 26]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHandlers(TypeBinding, ASTNode, FlowInfo, BlockScope, boolean) where default case is missing  At FlowContext.java:[lines 262-275]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.flow.FlowContext.checkExceptionHandlers(TypeBinding[], ASTNode, FlowInfo, BlockScope) where default case is missing  At FlowContext.java:[lines 387-404]
M P SBSC: org.eclipse.jdt.internal.compiler.ast.CastExpression.printExpression(int, StringBuffer) concatenates strings using + in a loop  At CastExpression.java:[line 510]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.LocalDeclaration(char[], int, int) may expose internal representation by storing an externally mutable object into LocalDeclaration.name  At LocalDeclaration.java:[line 58]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.Argument.resolveForCatch(BlockScope) where default case is missing  At Argument.java:[lines 162-172]
M P Bx: org.eclipse.jdt.internal.compiler.ast.FakedTrackingVariable.recordErrorLocation(ASTNode, int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At FakedTrackingVariable.java:[line 833]
M B NP: org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.getParameterNonNullness(MethodBinding, int, boolean) has Boolean return type and returns explicit null  At ImplicitNullAnnotationVerifier.java:[line 434]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(MethodBinding, AbstractMethodDeclaration, boolean, Scope)  At ImplicitNullAnnotationVerifier.java:[line 123]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(MethodBinding, AbstractMethodDeclaration, boolean, Scope)  At ImplicitNullAnnotationVerifier.java:[line 121]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkNullSpecInheritance(MethodBinding, AbstractMethodDeclaration, boolean, boolean, MethodBinding, Scope, ImplicitNullAnnotationVerifier$InheritedNonNullnessInfo[])  At ImplicitNullAnnotationVerifier.java:[line 336]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkNullSpecInheritance(MethodBinding, AbstractMethodDeclaration, boolean, boolean, MethodBinding, Scope, ImplicitNullAnnotationVerifier$InheritedNonNullnessInfo[])  At ImplicitNullAnnotationVerifier.java:[line 366]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.recordDeferredInheritedNullness(Scope, ASTNode, MethodBinding, Boolean, ImplicitNullAnnotationVerifier$InheritedNonNullnessInfo)  At ImplicitNullAnnotationVerifier.java:[line 454]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.ast.Statement.analyseArguments(BlockScope, FlowContext, FlowInfo, MethodBinding, Expression[])  At Statement.java:[line 134]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.ast.Statement.internalAnalyseOneArgument18(BlockScope, FlowContext, TypeBinding, Expression, int, Boolean, TypeBinding)  At Statement.java:[line 162]
M V EI: org.eclipse.jdt.internal.compiler.ast.ArrayAllocationExpression.getAnnotationsOnDimensions() may expose internal representation by returning ArrayAllocationExpression.annotationsOnDimensions  At ArrayAllocationExpression.java:[line 241]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.setSuperInterfaces(ReferenceBinding[]) may expose internal representation by storing an externally mutable object into SourceTypeBinding.superInterfaces  At SourceTypeBinding.java:[line 2282]
M V EI: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.genericTypeSignature() may expose internal representation by returning SourceTypeBinding.genericReferenceTypeSignature  At SourceTypeBinding.java:[line 917]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.setMethods(MethodBinding[]) may expose internal representation by storing an externally mutable object into SourceTypeBinding.methods  At SourceTypeBinding.java:[line 2250]
M V EI: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields() may expose internal representation by returning SourceTypeBinding.fields  At SourceTypeBinding.java:[line 862]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.setMemberTypes(ReferenceBinding[]) may expose internal representation by storing an externally mutable object into SourceTypeBinding.memberTypes  At SourceTypeBinding.java:[line 2225]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.setFields(FieldBinding[]) may expose internal representation by storing an externally mutable object into SourceTypeBinding.fields  At SourceTypeBinding.java:[line 2216]
M V EI: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.setMemberTypes(ReferenceBinding[]) may expose internal representation by returning SourceTypeBinding.memberTypes  At SourceTypeBinding.java:[line 2234]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.setTypeVariables(TypeVariableBinding[]) may expose internal representation by storing an externally mutable object into SourceTypeBinding.typeVariables  At SourceTypeBinding.java:[line 2298]
M V EI: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.unResolvedFields() may expose internal representation by returning SourceTypeBinding.fields  At SourceTypeBinding.java:[line 2528]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding(char[][], PackageBinding, ClassScope) may expose internal representation by storing an externally mutable object into SourceTypeBinding.compoundName  At SourceTypeBinding.java:[line 99]
M V EI: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.memberTypes() may expose internal representation by returning SourceTypeBinding.memberTypes  At SourceTypeBinding.java:[line 1412]
M V EI: org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods() may expose internal representation by returning SourceTypeBinding.methods  At SourceTypeBinding.java:[line 1435]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.getNullDefault() where default case is missing  At SourceTypeBinding.java:[lines 1330-1336]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.getNullDefault() where one case falls through to the next case  At SourceTypeBinding.java:[lines 1332-1335]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.FieldReference(char[], long) may expose internal representation by storing an externally mutable object into FieldReference.token  At FieldReference.java:[line 63]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.FieldReference.postConversionType(Scope) where default case is missing  At FieldReference.java:[lines 566-589]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.FieldReference.resolveType(BlockScope) where default case is missing  At FieldReference.java:[lines 645-651]
M D RCN: Redundant nullcheck of synthLocal, which is known to be non-null in org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding.addSyntheticArgumentAndField(ReferenceBinding)  Redundant null check at NestedTypeBinding.java:[line 121]
M V EI: org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding.syntheticEnclosingInstances() may expose internal representation by returning NestedTypeBinding.enclosingInstances  At NestedTypeBinding.java:[line 234]
M V EI: org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding.syntheticOuterLocalVariables() may expose internal representation by returning NestedTypeBinding.outerLocalVariables  At NestedTypeBinding.java:[line 255]
M V EI: org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding.syntheticEnclosingInstanceTypes() may expose internal representation by returning NestedTypeBinding.enclosingTypes  At NestedTypeBinding.java:[line 250]
M V EI: org.eclipse.jdt.internal.compiler.lookup.ElementValuePair.getName() may expose internal representation by returning ElementValuePair.name  At ElementValuePair.java:[line 98]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.ElementValuePair(char[], Object, MethodBinding) may expose internal representation by storing an externally mutable object into ElementValuePair.name  At ElementValuePair.java:[line 89]
M B BIT: Check for sign of bitwise operation in org.eclipse.jdt.internal.compiler.lookup.ElementValuePair.getValue(Expression)  At ElementValuePair.java:[line 77]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.MemberValuePair(char[], int, int, Expression) may expose internal representation by storing an externally mutable object into MemberValuePair.name  At MemberValuePair.java:[line 42]
M V EI: org.eclipse.jdt.internal.compiler.ast.SingleMemberAnnotation.memberValuePairs() may expose internal representation by returning SingleMemberAnnotation.singlePairs  At SingleMemberAnnotation.java:[line 50]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding(ReferenceBinding, ElementValuePair[]) may expose internal representation by storing an externally mutable object into AnnotationBinding.pairs  At AnnotationBinding.java:[line 184]
M V EI: org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding.getElementValuePairs() may expose internal representation by returning AnnotationBinding.pairs  At AnnotationBinding.java:[line 215]
M V EI: org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding.constantPoolName() may expose internal representation by returning LocalTypeBinding.constantPoolName  At LocalTypeBinding.java:[line 160]
M V EI: org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding.sourceName() may expose internal representation by returning LocalTypeBinding.sourceName  At LocalTypeBinding.java:[line 291]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding.setConstantPoolName(char[]) may expose internal representation by storing an externally mutable object into LocalTypeBinding.constantPoolName  At LocalTypeBinding.java:[line 261]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.availableMethods() may expose internal representation by returning BinaryTypeBinding.methods  At BinaryTypeBinding.java:[line 348]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.typeVariables() may expose internal representation by returning BinaryTypeBinding.typeVariables  At BinaryTypeBinding.java:[line 1832]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.fields() may expose internal representation by returning BinaryTypeBinding.fields  At BinaryTypeBinding.java:[line 913]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.methods() may expose internal representation by returning BinaryTypeBinding.methods  At BinaryTypeBinding.java:[line 1355]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.memberTypes() may expose internal representation by returning BinaryTypeBinding.memberTypes  At BinaryTypeBinding.java:[line 1327]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.superInterfaces() may expose internal representation by returning BinaryTypeBinding.superInterfaces  At BinaryTypeBinding.java:[line 1795]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.unResolvedFields() may expose internal representation by returning BinaryTypeBinding.fields  At BinaryTypeBinding.java:[line 1954]
M V EI: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.availableFields() may expose internal representation by returning BinaryTypeBinding.fields  At BinaryTypeBinding.java:[line 288]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.scanTypeForNullDefaultAnnotation(IBinaryType, PackageBinding, BinaryTypeBinding) where default case is missing  At BinaryTypeBinding.java:[lines 1687-1692]
M D NP: Load of known null value in org.apache.catalina.ssi.ExpressionParseTree.pushOpp(ExpressionParseTree$OppNode)  At ExpressionParseTree.java:[line 77]
M D REC: Exception is caught when Exception is not thrown in org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendObjectByCompletion(Object, SendHandler)  At WsRemoteEndpointImplBase.java:[line 591]
H D NS: Potentially dangerous use of non-short-circuit logic in org.apache.tomcat.websocket.WsFrameBase.processDataText()  At WsFrameBase.java:[line 472]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.SingleNameReference(char[], long) may expose internal representation by storing an externally mutable object into SingleNameReference.token  At SingleNameReference.java:[line 63]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.SingleNameReference.analyseAssignment(BlockScope, FlowContext, FlowInfo, Assignment, boolean) where default case is missing  At SingleNameReference.java:[lines 72-99]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.SingleNameReference.analyseCode(BlockScope, FlowContext, FlowInfo, boolean) where default case is missing  At SingleNameReference.java:[lines 177-199]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.SingleNameReference.generateCompoundAssignment(BlockScope, CodeStream, Expression, int, int, boolean) where default case is missing  At SingleNameReference.java:[lines 528-536]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.SingleNameReference.manageEnclosingInstanceAccessIfNecessary(BlockScope, FlowInfo) where default case is missing  At SingleNameReference.java:[lines 887-890]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.SingleNameReference.postConversionType(Scope) where default case is missing  At SingleNameReference.java:[lines 929-952]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.SingleNameReference.resolveType(BlockScope) where one case falls through to the next case  At SingleNameReference.java:[lines 1025-1028]
M D BC: Unchecked/unconfirmed cast from org.eclipse.jdt.internal.compiler.lookup.BlockScope to org.eclipse.jdt.internal.compiler.lookup.MethodScope in org.eclipse.jdt.internal.compiler.ast.JavadocSingleNameReference.resolve(BlockScope, boolean, boolean)  At JavadocSingleNameReference.java:[line 46]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.Javadoc.resolveReference(Expression, Scope) where default case is missing  At Javadoc.java:[lines 384-389]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.Javadoc.resolveTypeParameterTags(Scope, boolean) where default case is missing  At Javadoc.java:[lines 563-582]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.FieldDeclaration(char[], int, int) may expose internal representation by storing an externally mutable object into FieldDeclaration.name  At FieldDeclaration.java:[line 59]
M V EI: org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.typeParameters() may expose internal representation by returning MethodDeclaration.typeParameters  At MethodDeclaration.java:[line 353]
H D UC: Useless condition: it's known that haveDescriptor == true at this point  At LambdaExpression.java:[line 264]
M V EI: org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resultExpressions() may expose internal representation by returning LambdaExpression.resultExpressions  At LambdaExpression.java:[line 158]
M V EI: org.eclipse.jdt.internal.compiler.ast.LambdaExpression.arguments() may expose internal representation by returning LambdaExpression.arguments  At LambdaExpression.java:[line 142]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.LambdaExpression.mergeParameterNullAnnotations(BlockScope) where default case is missing  At LambdaExpression.java:[lines 562-565]
M P SBSC: org.eclipse.jdt.internal.compiler.ast.LambdaExpression.printExpression(int, StringBuffer, boolean) concatenates strings using + in a loop  At LambdaExpression.java:[line 638]
M D RCN: Redundant nullcheck of pathInfo, which is known to be non-null in org.apache.catalina.connector.Request.getRequestDispatcher(String)  Redundant null check at Request.java:[line 1352]
M D RCN: Redundant nullcheck of org.apache.catalina.connector.Request.getPathInfo(), which is known to be non-null in org.apache.catalina.connector.Request.getPathTranslated()  Redundant null check at Request.java:[line 2122]
M V EI: org.apache.catalina.connector.Request.getCookies() may expose internal representation by returning Request.cookies  At Request.java:[line 1996]
M D UC: Useless object stored in variable buffer of method org.apache.catalina.connector.Request.setCharacterEncoding(String)  At Request.java:[line 1587]
H I Dm: Found reliance on default encoding in org.apache.catalina.connector.Request.parseParts(boolean): String.getBytes()  At Request.java:[line 2775]
M D RCN: Redundant nullcheck of uri, which is known to be non-null in org.apache.catalina.realm.RealmBase.findSecurityConstraints(Request, Context)  Redundant null check at RealmBase.java:[line 706]
M B Nm: The method name org.apache.catalina.realm.RealmBase.Digest(String, String, String) doesn't start with a lower case letter  At RealmBase.java:[lines 1435-1450]
H I Dm: Found reliance on default encoding in org.apache.catalina.realm.RealmBase.Digest(String, String, String): String.getBytes()  At RealmBase.java:[line 1441]
M V EI: org.apache.catalina.core.StandardContext.getNotificationInfo() may expose internal representation by returning StandardContext.notificationInfo  At StandardContext.java:[line 6332]
M V EI: org.apache.catalina.core.StandardContext.getJavaVMs() may expose internal representation by returning StandardContext.javaVMs  At StandardContext.java:[line 6443]
M V EI: org.apache.catalina.core.StandardContext.findConstraints() may expose internal representation by returning StandardContext.constraints  At StandardContext.java:[line 3294]
M V EI2: org.apache.catalina.core.StandardContext.setApplicationLifecycleListeners(Object[]) may expose internal representation by storing an externally mutable object into StandardContext.applicationLifecycleListenersObjects  At StandardContext.java:[line 1202]
M V EI: org.apache.catalina.core.StandardContext.findApplicationListeners() may expose internal representation by returning StandardContext.applicationListeners  At StandardContext.java:[line 3270]
M V EI2: org.apache.catalina.core.StandardContext.setJavaVMs(String[]) may expose internal representation by storing an externally mutable object into StandardContext.javaVMs  At StandardContext.java:[line 6447]
M V EI: org.apache.catalina.core.StandardContext.getApplicationLifecycleListeners() may expose internal representation by returning StandardContext.applicationLifecycleListenersObjects  At StandardContext.java:[line 1189]
M P WMI: org.apache.catalina.core.StandardContext.filterStop() makes inefficient use of keySet iterator instead of entrySet iterator  At StandardContext.java:[line 4617]
H I Dm: Found reliance on default encoding in org.apache.catalina.core.StandardContext.getDeploymentDescriptor(): new java.io.InputStreamReader(InputStream)  At StandardContext.java:[line 6188]
M D RCN: Redundant nullcheck of connAddress, which is known to be non-null in org.apache.catalina.mbeans.MBeanFactory.removeConnector(String)  Redundant null check at MBeanFactory.java:[line 712]
M V EI: org.apache.catalina.core.StandardServer.findServices() may expose internal representation by returning StandardServer.services  At StandardServer.java:[line 555]
M D NP: Load of known null value in javax.el.BeanNameELResolver.getValue(ELContext, Object, Object)  At BeanNameELResolver.java:[line 48]
M D NP: Load of known null value in javax.el.BeanNameELResolver.setValue(ELContext, Object, Object, Object)  At BeanNameELResolver.java:[line 76]
M D NP: Load of known null value in javax.el.BeanNameELResolver.getType(ELContext, Object, Object)  At BeanNameELResolver.java:[line 116]
M D NP: Load of known null value in javax.el.BeanNameELResolver.isReadOnly(ELContext, Object, Object)  At BeanNameELResolver.java:[line 148]
M V EI2: org.apache.catalina.filters.ExpiresFilter.setExcludedResponseStatusCodes(int[]) may expose internal representation by storing an externally mutable object into ExpiresFilter.excludedResponseStatusCodes  At ExpiresFilter.java:[line 1630]
M V EI: org.apache.catalina.filters.ExpiresFilter.getExcludedResponseStatusCodesAsInts() may expose internal representation by returning ExpiresFilter.excludedResponseStatusCodes  At ExpiresFilter.java:[line 1244]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.FunctionalExpression.reportSamProblem(BlockScope, MethodBinding) where default case is missing  At FunctionalExpression.java:[lines 191-202]
M P Bx: org.eclipse.jdt.internal.compiler.ClassFile.filterFakeFrames(Set, Map, int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At ClassFile.java:[line 5287]
M P Bx: org.eclipse.jdt.internal.compiler.ClassFile.traverse(MethodBinding, int, byte[], int, int, Map, boolean) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead  At ClassFile.java:[line 6607]
M P Bx: org.eclipse.jdt.internal.compiler.ClassFile.traverse(MethodBinding, int, byte[], int, int, Map, boolean) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At ClassFile.java:[line 6608]
M P Bx: org.eclipse.jdt.internal.compiler.ClassFile.addRealJumpTarget(Set, int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At ClassFile.java:[line 6633]
M P Bx: org.eclipse.jdt.internal.compiler.ClassFile.add(Map, StackMapFrame) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At ClassFile.java:[line 6636]
M V EI: org.eclipse.jdt.internal.compiler.ClassFile.getBytes() may expose internal representation by returning ClassFile.bytes  At ClassFile.java:[line 4792]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ClassFile.addSpecialMethods() where default case is missing  At ClassFile.java:[lines 889-941]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ClassFile.dumpTargetTypeContents(int, AnnotationContext) where default case is missing  At ClassFile.java:[lines 2203-2296]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ClassFile.generateConstantValueAttribute(Constant, FieldBinding, int) where default case is missing  At ClassFile.java:[lines 2462-2520]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ClassFile.generateElementValue(int, Expression, Constant, TypeBinding) where default case is missing  At ClassFile.java:[lines 2581-2653]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ClassFile.generateStackMapAttribute(MethodBinding, int, int, int, boolean) where default case is missing  At ClassFile.java:[lines 4210-4219]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ClassFile.generateStackMapTableAttribute(MethodBinding, int, int, int, boolean) where default case is missing  At ClassFile.java:[lines 4388-4397]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ClassFile.traverse(MethodBinding, int, byte[], int, int, Map, boolean) where default case is missing  At ClassFile.java:[lines 5480-5494]
M V EI: org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.genericTypeArguments() may expose internal representation by returning ReferenceExpression.resolvedTypeArguments  At ReferenceExpression.java:[line 789]
M V EI2: org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.initialize(CompilationResult, Expression, TypeReference[], char[], int) may expose internal representation by storing an externally mutable object into ReferenceExpression.typeArguments  At ReferenceExpression.java:[line 108]
M V EI2: org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.initialize(CompilationResult, Expression, TypeReference[], char[], int) may expose internal representation by storing an externally mutable object into ReferenceExpression.selector  At ReferenceExpression.java:[line 109]
M B Nm: The class name org.apache.tomcat.jdbc.pool.DataSource shadows the simple name of implemented interface javax.sql.DataSource  At DataSource.java:[lines 39-157]
M B Nm: The class name org.apache.tomcat.jdbc.pool.XADataSource shadows the simple name of implemented interface javax.sql.XADataSource  At XADataSource.java:[lines 26-35]
M D RCN: Redundant nullcheck of thisMethods, which is known to be non-null in org.apache.catalina.core.StandardWrapper.getAllDeclaredMethods(Class)  Redundant null check at StandardWrapper.java:[line 1686]
M V EI: org.apache.catalina.core.StandardWrapper.getNotificationInfo() may expose internal representation by returning StandardWrapper.notificationInfo  At StandardWrapper.java:[line 1918]
M V EI: org.apache.catalina.core.StandardWrapper.getServletMethods() may expose internal representation by returning StandardWrapper.DEFAULT_SERVLET_METHODS  At StandardWrapper.java:[line 598]
M M SWL: org.apache.catalina.core.StandardWrapper.unload() calls Thread.sleep() with a lock held  At StandardWrapper.java:[line 1406]
H C NP: org.apache.tomcat.dbcp.dbcp2.DelegatingConnection.prepareStatement(String) may return null, but is declared @Nonnull  At DelegatingConnection.java:[line 298]
M B NP: org.apache.el.lang.ELSupport.coerceToBoolean(ELContext, Object, boolean) has Boolean return type and returns explicit null  At ELSupport.java:[line 261]
M B RV: org.apache.el.lang.ELSupport.compare(ELContext, Object, Object) negates the return value of Comparable.compareTo(Object)  At ELSupport.java:[line 137]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.BoundSet.incorporate(InferenceContext18) where default case is missing  At BoundSet.java:[lines 469-477]
M B NP: org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.moreSpecificMain(TypeBinding, TypeBinding, Expression) has Boolean return type and returns explicit null  At InferenceContext18.java:[line 726]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.enterPolyInvocation(InvocationSite, Expression[]) may expose internal representation by storing an externally mutable object into InferenceContext18.invocationArguments  At InferenceContext18.java:[line 1361]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.resumeSuspendedInference(InferenceContext18$SuspendedInferenceRecord) may expose internal representation by storing an externally mutable object into InferenceContext18.invocationArguments  At InferenceContext18.java:[line 1391]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.InferenceContext18(Scope, Expression[], InvocationSite) may expose internal representation by storing an externally mutable object into InferenceContext18.invocationArguments  At InferenceContext18.java:[line 236]
M V EI2: org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.resumeSuspendedInference(InferenceContext18$SuspendedInferenceRecord) may expose internal representation by storing an externally mutable object into InferenceContext18.inferenceVariables  At InferenceContext18.java:[line 1380]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.toString() where default case is missing  At InferenceContext18.java:[lines 1597-1601]
M B RC: Suspicious comparison of Boolean references in org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.isMoreSpecificThan(MethodBinding, MethodBinding, boolean, boolean)  At InferenceContext18.java:[line 696]
M D REC: Exception is caught when Exception is not thrown in org.apache.jasper.compiler.Compiler.generateJava()  At Compiler.java:[line 264]
M B RV: Exceptional return value of java.io.File.setLastModified(long) ignored in org.apache.jasper.compiler.Compiler.compile(boolean, boolean)  At Compiler.java:[line 359]
M P Bx: org.eclipse.jdt.internal.compiler.apt.model.Factory.performNecessaryPrimitiveTypeConversion(Class, Object, boolean) invokes inefficient new Character(char) constructor; use Character.valueOf(char) instead  At Factory.java:[line 572]
M P Bx: org.eclipse.jdt.internal.compiler.apt.model.Factory.performNecessaryPrimitiveTypeConversion(Class, Object, boolean) invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At Factory.java:[line 580]
M P Bx: org.eclipse.jdt.internal.compiler.apt.model.Factory.performNecessaryPrimitiveTypeConversion(Class, Object, boolean) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Factory.java:[line 578]
M P Bx: org.eclipse.jdt.internal.compiler.apt.model.Factory.performNecessaryPrimitiveTypeConversion(Class, Object, boolean) invokes inefficient new Short(short) constructor; use Short.valueOf(short) instead  At Factory.java:[line 582]
M P Bx: org.eclipse.jdt.internal.compiler.apt.model.Factory.performNecessaryPrimitiveTypeConversion(Class, Object, boolean) invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead  At Factory.java:[line 596]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.apt.model.Factory.decodeModifiers(Set, int, int[]) where default case is missing  At Factory.java:[lines 162-201]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.BoundSet$ThreeSets.findSingleWrapperType() where default case is missing  At BoundSet.java:[lines 190-201]
M V EI: org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall.genericTypeArguments() may expose internal representation by returning ExplicitConstructorCall.genericTypeArguments  At ExplicitConstructorCall.java:[line 206]
M V EI: org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall.arguments() may expose internal representation by returning ExplicitConstructorCall.arguments  At ExplicitConstructorCall.java:[line 512]
M D BC: Unchecked/unconfirmed cast from org.eclipse.jdt.internal.compiler.lookup.BlockScope to org.eclipse.jdt.internal.compiler.lookup.MethodScope in org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall.analyseCode(BlockScope, FlowContext, FlowInfo)  At ExplicitConstructorCall.java:[line 92]
M D BC: Unchecked/unconfirmed cast from org.eclipse.jdt.internal.compiler.lookup.BlockScope to org.eclipse.jdt.internal.compiler.lookup.MethodScope in org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall.generateCode(BlockScope, CodeStream)  At ExplicitConstructorCall.java:[line 152]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.checkConstructors(Parser) where default case is missing  At TypeDeclaration.java:[lines 288-295]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(Parser, CompilationUnitDeclaration) where default case is missing  At TypeDeclaration.java:[lines 883-886]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.printHeader(int, StringBuffer) where default case is missing  At TypeDeclaration.java:[lines 941-952]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve() where one case falls through to the next case  At TypeDeclaration.java:[lines 1118-1122]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve() where default case is missing  At TypeDeclaration.java:[lines 1168-1187]
M D REC: Exception is caught when Exception is not thrown in org.apache.catalina.core.NamingContextListener.constructEnvEntry(String, String)  At NamingContextListener.java:[line 906]
M C INT: Bad comparison of nonnegative value with 0 in org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveDeprecatedAnnotations(BlockScope, Annotation[], Binding)  At ASTNode.java:[line 1140]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(BlockScope, Annotation[], Binding, boolean) where default case is missing  At ASTNode.java:[lines 841-879]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.ASTNode.copySE8AnnotationsToType(BlockScope, Binding, Annotation[], boolean) where default case is missing  At ASTNode.java:[lines 1056-1084]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.VariableBinding(char[], TypeBinding, int, Constant) may expose internal representation by storing an externally mutable object into VariableBinding.name  At VariableBinding.java:[line 30]
M V EI: org.eclipse.jdt.internal.compiler.lookup.VariableBinding.readableName() may expose internal representation by returning VariableBinding.name  At VariableBinding.java:[line 76]
M V EI: org.eclipse.jdt.internal.compiler.lookup.MemberTypeBinding.constantPoolName() may expose internal representation by returning MemberTypeBinding.constantPoolName  At MemberTypeBinding.java:[line 44]
M B BC: Equals method for org.eclipse.jdt.internal.compiler.lookup.TypeSystem$HashedParameterizedTypes$InternalParameterizedTypeBinding assumes the argument is of type TypeSystem$HashedParameterizedTypes$InternalParameterizedTypeBinding  At TypeSystem.java:[line 69]
M D Eq: org.eclipse.jdt.internal.compiler.lookup.UnresolvedAnnotationBinding doesn't override AnnotationBinding.equals(Object)  At UnresolvedAnnotationBinding.java:[line 1]
M V EI: org.eclipse.jdt.internal.compiler.lookup.UnresolvedAnnotationBinding.getElementValuePairs() may expose internal representation by returning UnresolvedAnnotationBinding.pairs  At UnresolvedAnnotationBinding.java:[line 63]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(int, String[], int, String[], int, int, int, ReferenceContext, CompilationResult) where default case is missing  At ProblemHandler.java:[lines 180-200]
M V EI: org.eclipse.jdt.internal.compiler.parser.Scanner.getSource() may expose internal representation by returning Scanner.source  At Scanner.java:[line 1907]
M V EI2: org.eclipse.jdt.internal.compiler.parser.Scanner.setSource(char[]) may expose internal representation by storing an externally mutable object into Scanner.source  At Scanner.java:[line 3827]
M V EI: org.eclipse.jdt.internal.compiler.parser.Scanner.getCurrentIdentifierSource() may expose internal representation by returning Scanner.source  At Scanner.java:[line 444]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Scanner.recordComment(int) where default case is missing  At Scanner.java:[lines 2715-2723]
M D DLS: Dead store to pos in org.eclipse.jdt.internal.compiler.parser.Scanner.parseTags()  At Scanner.java:[line 2597]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.AnnotationInfo.getTypeName() may expose internal representation by returning AnnotationInfo.typename  At AnnotationInfo.java:[line 164]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.AnnotationInfo.getElementValuePairs() may expose internal representation by returning AnnotationInfo.pairs  At AnnotationInfo.java:[line 161]
M V EI: org.eclipse.jdt.internal.compiler.ast.NormalAnnotation.memberValuePairs() may expose internal representation by returning NormalAnnotation.memberValuePairs  At NormalAnnotation.java:[line 44]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationInfo.getTypePath() may expose internal representation by returning TypeAnnotationInfo.typePath  At TypeAnnotationInfo.java:[line 190]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.classfmt.TypeAnnotationInfo.toString() where default case is missing  At TypeAnnotationInfo.java:[lines 139-150]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.RecoveredAnnotation.updateFromParserState() where default case is missing  At RecoveredAnnotation.java:[lines 91-152]
M D RV: Return value of updatedAnnotationReference() ignored, but method has no side effect  At RecoveredAnnotation.java:[line 231]
M D Eq: org.eclipse.jdt.internal.compiler.classfmt.MethodInfoWithTypeAnnotations doesn't override MethodInfo.equals(Object)  At MethodInfoWithTypeAnnotations.java:[line 1]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding(MethodBinding, TypeBinding[], LookupEnvironment) may expose internal representation by storing an externally mutable object into ParameterizedGenericMethodBinding.typeArguments  At ParameterizedGenericMethodBinding.java:[line 505]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(MethodBinding, TypeBinding[], Scope, InvocationSite, int) where default case is missing  At ParameterizedGenericMethodBinding.java:[lines 250-261]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.boundCheck18(Scope, TypeBinding[]) where default case is missing  At ParameterizedGenericMethodBinding.java:[lines 288-299]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.BinaryExpression.generateCode(BlockScope, CodeStream, boolean) where default case is missing  At BinaryExpression.java:[lines 134-571]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.BinaryExpression.generateOptimizedGreaterThan(BlockScope, CodeStream, BranchLabel, BranchLabel, boolean) where default case is missing  At BinaryExpression.java:[lines 720-734]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.BinaryExpression.generateOptimizedGreaterThanOrEqual(BlockScope, CodeStream, BranchLabel, BranchLabel, boolean) where default case is missing  At BinaryExpression.java:[lines 828-842]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.BinaryExpression.generateOptimizedLessThan(BlockScope, CodeStream, BranchLabel, BranchLabel, boolean) where default case is missing  At BinaryExpression.java:[lines 934-948]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.BinaryExpression.generateOptimizedLessThanOrEqual(BlockScope, CodeStream, BranchLabel, BranchLabel, boolean) where default case is missing  At BinaryExpression.java:[lines 1040-1054]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.BinaryExpression.optimizedBooleanConstant(int, int, int) where default case is missing  At BinaryExpression.java:[lines 1738-1781]
M V EI2: new org.eclipse.jdt.internal.compiler.flow.LabelFlowContext(FlowContext, ASTNode, char[], BranchLabel, BlockScope) may expose internal representation by storing an externally mutable object into LabelFlowContext.labelName  At LabelFlowContext.java:[line 30]
M V EI: org.eclipse.jdt.internal.compiler.flow.LabelFlowContext.labelName() may expose internal representation by returning LabelFlowContext.labelName  At LabelFlowContext.java:[line 52]
M V EI2: org.eclipse.jdt.internal.compiler.parser.RecoveredField.attach(RecoveredAnnotation[], int, int, int) may expose internal representation by storing an externally mutable object into RecoveredField.annotations  At RecoveredField.java:[line 144]
M V EI: org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.typeParameters() may expose internal representation by returning ConstructorDeclaration.typeParameters  At ConstructorDeclaration.java:[line 613]
M V EI2: org.eclipse.jdt.internal.compiler.parser.RecoveredLocalVariable.attach(RecoveredAnnotation[], int, int, int) may expose internal representation by storing an externally mutable object into RecoveredLocalVariable.annotations  At RecoveredLocalVariable.java:[line 70]
M V EI2: org.eclipse.jdt.internal.compiler.parser.RecoveredType.attach(RecoveredAnnotation[], int, int, int) may expose internal representation by storing an externally mutable object into RecoveredType.annotations  At RecoveredType.java:[line 317]
M V EI2: org.eclipse.jdt.internal.compiler.parser.RecoveredType.add(TypeParameter[], int) may expose internal representation by storing an externally mutable object into RecoveredType.pendingTypeParameters  At RecoveredType.java:[line 273]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.flow.LoopingFlowContext.complainOnDeferredNullChecks(BlockScope, FlowInfo) where default case is missing  At LoopingFlowContext.java:[lines 309-413]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.MethodInfo.getMethodDescriptor() may expose internal representation by returning MethodInfo.descriptor  At MethodInfo.java:[line 297]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.MethodInfo.getArgumentNames() may expose internal representation by returning MethodInfo.argumentNames  At MethodInfo.java:[line 253]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.MethodInfo.getGenericSignature() may expose internal representation by returning MethodInfo.signature  At MethodInfo.java:[line 278]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.MethodInfo.getSelector() may expose internal representation by returning MethodInfo.name  At MethodInfo.java:[line 334]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.MethodInfo.getExceptionTypeNames() may expose internal representation by returning MethodInfo.exceptionNames  At MethodInfo.java:[line 270]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.classfmt.MethodInfo.createMethod(byte[], int[], int) where default case is missing  At MethodInfo.java:[lines 52-117]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.classfmt.MethodInfo.readModifierRelatedAttributes() where default case is missing  At MethodInfo.java:[lines 415-430]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.UnaryExpression.generateCode(BlockScope, CodeStream, boolean) where default case is missing  At UnaryExpression.java:[lines 80-163]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.UnionTypeReference(TypeReference[]) may expose internal representation by storing an externally mutable object into UnionTypeReference.typeReferences  At UnionTypeReference.java:[line 28]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.UnionTypeReference.resolveType(BlockScope, boolean, int) where default case is missing  At UnionTypeReference.java:[lines 61-71]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.EqualExpression.checkVariableComparison(BlockScope, FlowContext, FlowInfo, FlowInfo, FlowInfo, LocalVariableBinding, int, Expression) where default case is missing  At EqualExpression.java:[lines 101-121]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.BranchStatement(char[], int, int) may expose internal representation by storing an externally mutable object into BranchStatement.label  At BranchStatement.java:[line 27]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference(char[][], long[], int, int) may expose internal representation by storing an externally mutable object into QualifiedNameReference.tokens  At QualifiedNameReference.java:[line 72]
M V EI: org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.getName() may expose internal representation by returning QualifiedNameReference.tokens  At QualifiedNameReference.java:[line 1147]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference(char[][], long[], int, int) may expose internal representation by storing an externally mutable object into QualifiedNameReference.sourcePositions  At QualifiedNameReference.java:[line 73]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.analyseAssignment(BlockScope, FlowContext, FlowInfo, Assignment, boolean) where default case is missing  At QualifiedNameReference.java:[lines 84-113]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.analyseCode(BlockScope, FlowContext, FlowInfo, boolean) where default case is missing  At QualifiedNameReference.java:[lines 190-215]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.manageEnclosingInstanceAccessIfNecessary(BlockScope, FlowInfo) where default case is missing  At QualifiedNameReference.java:[lines 869-872]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.postConversionType(Scope) where default case is missing  At QualifiedNameReference.java:[lines 937-960]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(BlockScope) where one case falls through to the next case  At QualifiedNameReference.java:[lines 1089-1092]
M V EI: org.eclipse.jdt.internal.compiler.ast.StringLiteralConcatenation.source() may expose internal representation by returning StringLiteralConcatenation.source  At StringLiteralConcatenation.java:[line 68]
M V EI: org.eclipse.jdt.internal.compiler.ast.IntersectionCastTypeReference.getTypeReferences() may expose internal representation by returning IntersectionCastTypeReference.typeReferences  At IntersectionCastTypeReference.java:[line 65]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.IntersectionCastTypeReference(TypeReference[]) may expose internal representation by storing an externally mutable object into IntersectionCastTypeReference.typeReferences  At IntersectionCastTypeReference.java:[line 34]
M V EI: org.eclipse.jdt.internal.compiler.ast.AllocationExpression.arguments() may expose internal representation by returning AllocationExpression.arguments  At AllocationExpression.java:[line 753]
M V EI: org.eclipse.jdt.internal.compiler.ast.AllocationExpression.genericTypeArguments() may expose internal representation by returning AllocationExpression.genericTypeArguments  At AllocationExpression.java:[line 258]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.ForStatement(Statement[], Expression, Statement[], Statement, boolean, int, int) may expose internal representation by storing an externally mutable object into ForStatement.initializations  At ForStatement.java:[line 55]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.ForStatement(Statement[], Expression, Statement[], Statement, boolean, int, int) may expose internal representation by storing an externally mutable object into ForStatement.increments  At ForStatement.java:[line 57]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.LongLiteral.computeConstant() where default case is missing  At LongLiteral.java:[lines 93-126]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.StringLiteral(char[], int, int, int) may expose internal representation by storing an externally mutable object into StringLiteral.source  At StringLiteral.java:[line 27]
M V EI: org.eclipse.jdt.internal.compiler.ast.StringLiteral.source() may expose internal representation by returning StringLiteral.source  At StringLiteral.java:[line 115]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.Clinit.generateCode(ClassScope, ClassFile, int) where default case is missing  At Clinit.java:[lines 268-285]
M V EI: org.eclipse.jdt.internal.compiler.parser.RecoveryScanner.getCurrentIdentifierSource() may expose internal representation by returning RecoveryScanner.fakeTokenSource  At RecoveryScanner.java:[line 215]
M V EI: org.eclipse.jdt.internal.compiler.parser.RecoveryScanner.getCurrentTokenSourceString() may expose internal representation by returning RecoveryScanner.fakeTokenSource  At RecoveryScanner.java:[line 220]
M V EI2: org.eclipse.jdt.internal.compiler.parser.RecoveryScanner.setPendingTokens(int[]) may expose internal representation by storing an externally mutable object into RecoveryScanner.pendingTokens  At RecoveryScanner.java:[line 258]
M V EI: org.eclipse.jdt.internal.compiler.parser.RecoveryScanner.getCurrentTokenSource() may expose internal representation by returning RecoveryScanner.fakeTokenSource  At RecoveryScanner.java:[line 225]
M D RV: Return value of updatedImportReference() ignored, but method has no side effect  At RecoveredImport.java:[line 46]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.LabeledStatement(char[], Statement, long, int) may expose internal representation by storing an externally mutable object into LabeledStatement.label  At LabeledStatement.java:[line 36]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.AssertStatement.resolve(BlockScope) where one case falls through to the next case  At AssertStatement.java:[lines 154-165]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.AssertStatement.resolve(BlockScope) where default case is missing  At AssertStatement.java:[lines 149-154]
M P Bx: org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.getWrappedConstantValue() invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At FieldInfo.java:[line 277]
M P Bx: org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.getWrappedConstantValue() invokes inefficient new Character(char) constructor; use Character.valueOf(char) instead  At FieldInfo.java:[line 265]
M P Bx: org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.getWrappedConstantValue() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At FieldInfo.java:[line 256]
M P Bx: org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.getWrappedConstantValue() invokes inefficient new Byte(byte) constructor; use Byte.valueOf(byte) instead  At FieldInfo.java:[line 259]
M P Bx: org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.getWrappedConstantValue() invokes inefficient new Short(short) constructor; use Short.valueOf(short) instead  At FieldInfo.java:[line 262]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.getGenericSignature() may expose internal representation by returning FieldInfo.signature  At FieldInfo.java:[line 183]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.getName() may expose internal representation by returning FieldInfo.name  At FieldInfo.java:[line 211]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.getTypeName() may expose internal representation by returning FieldInfo.descriptor  At FieldInfo.java:[line 233]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.createField(byte[], int[], int) where default case is missing  At FieldInfo.java:[lines 48-83]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.getWrappedConstantValue() where default case is missing  At FieldInfo.java:[lines 254-280]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.readConstantAttribute() where default case is missing  At FieldInfo.java:[lines 324-362]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.classfmt.FieldInfo.readModifierRelatedAttributes() where default case is missing  At FieldInfo.java:[lines 382-389]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement.resolve(BlockScope) where default case is missing  At SynchronizedStatement.java:[lines 175-190]
M V EI2: org.eclipse.jdt.internal.compiler.parser.RecoveredMethod.attach(RecoveredAnnotation[], int, int, int) may expose internal representation by storing an externally mutable object into RecoveredMethod.annotations  At RecoveredMethod.java:[line 655]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.ForeachStatement.analyseCode(BlockScope, FlowContext, FlowInfo) where default case is missing  At ForeachStatement.java:[lines 150-163]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.ForeachStatement.generateCode(BlockScope, CodeStream) where default case is missing  At ForeachStatement.java:[lines 213-236]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.util.ManifestAnalyzer.analyzeManifestContents(InputStream) where default case is missing  At ManifestAnalyzer.java:[lines 57-132]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference(char[][], TypeReference[][], int, long[]) may expose internal representation by storing an externally mutable object into ParameterizedQualifiedTypeReference.typeArguments  At ParameterizedQualifiedTypeReference.java:[line 44]
M V EI: org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.getTypeArguments() may expose internal representation by returning ParameterizedQualifiedTypeReference.typeArguments  At ParameterizedQualifiedTypeReference.java:[line 139]
M D Eq: org.eclipse.jdt.internal.compiler.classfmt.AnnotationMethodInfo doesn't override MethodInfo.equals(Object)  At AnnotationMethodInfo.java:[line 1]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.classfmt.AnnotationMethodInfo.createAnnotationMethod(byte[], int[], int) where default case is missing  At AnnotationMethodInfo.java:[lines 30-59]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference(char[], TypeReference[], int, long) may expose internal representation by storing an externally mutable object into ParameterizedSingleTypeReference.typeArguments  At ParameterizedSingleTypeReference.java:[line 39]
M V EI2: org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(ReferenceContext, int, int, TypeDeclaration[], CompilationUnitDeclaration) may expose internal representation by storing an externally mutable object into Parser.recoveredTypes  At Parser.java:[line 11637]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.consumeClassDeclaration() where default case is missing  At Parser.java:[lines 2583-2595]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.consumeExplicitConstructorInvocation(int, int) where default case is missing  At Parser.java:[lines 4078-4087]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.consumeExplicitConstructorInvocationWithTypeArguments(int, int) where default case is missing  At Parser.java:[lines 4118-4127]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(int) where default case is missing  At Parser.java:[lines 5959-7896]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.consumeToken(int) where one case falls through to the next case  At Parser.java:[lines 9066-9072]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.consumeToken(int) where default case is missing  At Parser.java:[lines 8828-9120]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.dispatchDeclarationInto(int) where default case is missing  At Parser.java:[lines 9733-9754]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.dispatchDeclarationIntoEnumDeclaration(int) where default case is missing  At Parser.java:[lines 9822-9843]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.getNextCharacter(char[], int[]) where default case is missing  At Parser.java:[lines 10104-10114]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.markEnclosingMemberWithLocalOrFunctionalType(Parser$LocalTypeKind) where one case falls through to the next case  At Parser.java:[lines 10677-10680]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.parseClassBodyDeclarations(char[], int, int, CompilationUnitDeclaration) where default case is missing  At Parser.java:[lines 11527-11541]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements() where default case is missing  At Parser.java:[lines 12058-12063]
M B OS: org.eclipse.jdt.internal.compiler.parser.Parser.readReadableNameTable(String) may fail to close stream  At Parser.java:[line 832]
M P SBSC: org.eclipse.jdt.internal.compiler.parser.Parser.toString() concatenates strings using + in a loop  At Parser.java:[line 12358]
M X OBL: org.eclipse.jdt.internal.compiler.parser.Parser.readReadableNameTable(String) may fail to clean up java.io.InputStream  Obligation to clean up resource created at Parser.java:[line 832] is not discharged
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.parser.Parser.buildFile(String, List): new java.io.FileWriter(String)  At Parser.java:[line 252]
M V EI: org.eclipse.jdt.internal.compiler.batch.CompilationUnit.getContents() may expose internal representation by returning CompilationUnit.contents  At CompilationUnit.java:[line 73]
M V EI2: new org.eclipse.jdt.internal.compiler.batch.CompilationUnit(char[], String, String, String, boolean) may expose internal representation by storing an externally mutable object into CompilationUnit.contents  At CompilationUnit.java:[line 45]
M V EI: org.eclipse.jdt.internal.compiler.batch.CompilationUnit.getMainTypeName() may expose internal representation by returning CompilationUnit.mainTypeName  At CompilationUnit.java:[line 90]
M V EI: org.eclipse.jdt.internal.compiler.batch.CompilationUnit.getFileName() may expose internal representation by returning CompilationUnit.fileName  At CompilationUnit.java:[line 87]
M D SF: Switch statement found in new org.eclipse.jdt.internal.compiler.batch.CompilationUnit(char[], String, String, String, boolean) where default case is missing  At CompilationUnit.java:[lines 47-55]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getMethods() may expose internal representation by returning ClassFileReader.methods  At ClassFileReader.java:[line 652]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getSuperclassName() may expose internal representation by returning ClassFileReader.superclassName  At ClassFileReader.java:[line 766]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getFields() may expose internal representation by returning ClassFileReader.fields  At ClassFileReader.java:[line 536]
M V EI2: new org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader(byte[], char[], boolean) may expose internal representation by storing an externally mutable object into ClassFileReader.classFileName  At ClassFileReader.java:[line 158]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.sourceFileName() may expose internal representation by returning ClassFileReader.sourceFileName  At ClassFileReader.java:[line 1232]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getAnnotations() may expose internal representation by returning ClassFileReader.annotations  At ClassFileReader.java:[line 472]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getInterfaceNames() may expose internal representation by returning ClassFileReader.interfaceNames  At ClassFileReader.java:[line 586]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getSourceName() may expose internal representation by returning ClassFileReader.sourceName  At ClassFileReader.java:[line 737]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getFileName() may expose internal representation by returning ClassFileReader.classFileName  At ClassFileReader.java:[line 543]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getEnclosingMethod() may expose internal representation by returning ClassFileReader.enclosingMethod  At ClassFileReader.java:[line 520]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getTypeAnnotations() may expose internal representation by returning ClassFileReader.typeAnnotations  At ClassFileReader.java:[line 479]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getGenericSignature() may expose internal representation by returning ClassFileReader.signature  At ClassFileReader.java:[line 547]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getConstantPoolOffsets() may expose internal representation by returning ClassFileReader.constantPoolOffsets  At ClassFileReader.java:[line 500]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getName() may expose internal representation by returning ClassFileReader.className  At ClassFileReader.java:[line 732]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getMissingTypeNames() may expose internal representation by returning ClassFileReader.missingTypeNames  At ClassFileReader.java:[line 703]
M V EI: org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.getEnclosingTypeName() may expose internal representation by returning ClassFileReader.enclosingTypeName  At ClassFileReader.java:[line 528]
M D SF: Switch statement found in new org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader(byte[], char[], boolean) where default case is missing  At ClassFileReader.java:[lines 167-225]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.printTypeModifiers(int): java.io.ByteArrayOutputStream.toString()  At ClassFileReader.java:[line 71]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.printTypeModifiers(int): new java.io.PrintWriter(OutputStream)  At ClassFileReader.java:[line 62]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.toString(): java.io.ByteArrayOutputStream.toString()  At ClassFileReader.java:[line 1243]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader.toString(): new java.io.PrintWriter(OutputStream)  At ClassFileReader.java:[line 1237]
M V EI: org.eclipse.jdt.internal.compiler.batch.ClasspathJar.normalizedPath() may expose internal representation by returning ClasspathJar.normalizedPath  At ClasspathJar.java:[line 193]
M V EI2: org.eclipse.jdt.internal.compiler.Compiler.setBinaryTypes(ReferenceBinding[]) may expose internal representation by storing an externally mutable object into Compiler.referenceBindings  At Compiler.java:[line 559]
M B Nm: The field name org.eclipse.jdt.internal.compiler.Compiler.DebugRequestor doesn't start with a lower case letter  In Compiler.java
H I Dm: Found reliance on default encoding in new org.eclipse.jdt.internal.compiler.Compiler(INameEnvironment, IErrorHandlingPolicy, CompilerOptions, ICompilerRequestor, IProblemFactory, PrintWriter, CompilationProgress): new java.io.PrintWriter(OutputStream, boolean)  At Compiler.java:[line 284]
M V EI: org.eclipse.jdt.internal.compiler.batch.ClasspathDirectory.normalizedPath() may expose internal representation by returning ClasspathDirectory.normalizedPath  At ClasspathDirectory.java:[line 184]
M D NP: Load of known null value in new org.eclipse.jdt.internal.compiler.apt.model.AnnotationValueImpl(BaseProcessingEnvImpl, Object, TypeBinding)  At AnnotationValueImpl.java:[line 89]
M D UC: Useless condition: it's known that count > 2 at this point  At XMLEncodingDetector.java:[line 160]
H D UC: Useless condition: it's known that this.handshakeComplete == true at this point  At SecureNioChannel.java:[line 229]
H B DE: org.apache.tomcat.util.net.SecureNioChannel.rehandshake(long) might ignore java.lang.Exception  At SecureNioChannel.java:[line 287]
H B HE: org.eclipse.jdt.internal.compiler.apt.util.ArchiveFileObject defines equals and uses Object.hashCode()  At ArchiveFileObject.java:[lines 147-151]
H B ES: Comparison of String parameter using == or != in org.eclipse.jdt.internal.compiler.batch.FileSystem.getClasspath(String, String, boolean, AccessRuleSet, String)   At FileSystem.java:[line 172]
M B ES: Comparison of String objects using == or != in org.eclipse.jdt.internal.compiler.batch.FileSystem.findClass(String, char[], boolean)   At FileSystem.java:[line 260]
M B ES: Comparison of String objects using == or != in org.eclipse.jdt.internal.compiler.batch.FileSystem.findTypeNames(char[][])   At FileSystem.java:[line 307]
M B ES: Comparison of String objects using == or != in org.eclipse.jdt.internal.compiler.batch.FileSystem.isPackage(char[][], char[])   At FileSystem.java:[line 363]
H D UC: Useless condition: it's known that this.remaining >= 0 at this point  At ChunkedInputFilter.java:[line 399]
M D ST: Write to static field org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory.DEFAULT_LOCALE_TEMPLATES from instance method org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory.setLocale(Locale)  At DefaultProblemFactory.java:[line 124]
M P Dm: org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory.getLocalizedMessage(int, int, String[]) invokes inefficient new String(String) constructor  At DefaultProblemFactory.java:[line 198]
M V EI: org.apache.coyote.http11.AbstractOutputBuffer.getFilters() may expose internal representation by returning AbstractOutputBuffer.filterLibrary  At AbstractOutputBuffer.java:[line 178]
M B Dm: org.eclipse.jdt.internal.compiler.batch.Main.compile(String[]) invokes System.exit(...), which shuts down the entire virtual machine  At Main.java:[line 1704]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.batch.Main.configure(String[]) where default case is missing  At Main.java:[lines 2304-2311]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.batch.Main.enableAll(int) where default case is missing  At Main.java:[lines 2920-2925]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.batch.Main.disableAll(int) where default case is missing  At Main.java:[lines 2943-2948]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.batch.Main.handleErrorOrWarningToken(String, boolean, int) where default case is missing  At Main.java:[lines 3433-3439]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.batch.Main.processPathEntries(int, ArrayList, String, String, boolean, boolean) where one case falls through to the next case  At Main.java:[lines 4275-4278]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.batch.Main.processPaths(String[], int, String, ArrayList) where default case is missing  At Main.java:[lines 4386-4391]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.batch.Main.processPaths(String[], int, String, String[]) where default case is missing  At Main.java:[lines 4448-4453]
M P SBSC: org.eclipse.jdt.internal.compiler.batch.Main.processPathEntries(int, ArrayList, String, String, boolean, boolean) concatenates strings using + in a loop  At Main.java:[line 4347]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.batch.Main.compile(String): new java.io.PrintWriter(OutputStream)  At Main.java:[line 1370]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.batch.Main.main(String[]): new java.io.PrintWriter(OutputStream)  At Main.java:[line 1405]
M M UL: org.apache.coyote.http11.InternalAprInputBuffer.doReadSocket(boolean) does not release lock on all exception paths  At InternalAprInputBuffer.java:[line 648]
M B NP: org.apache.jasper.compiler.JspReader.indexOf(char, Mark) has Boolean return type and returns explicit null  At JspReader.java:[line 202]
M V EI: org.apache.tomcat.util.net.NioEndpoint.getOomParachuteData() may expose internal representation by returning NioEndpoint.oomParachuteData  At NioEndpoint.java:[line 514]
M V EI2: org.apache.tomcat.util.net.NioEndpoint.setOomParachuteData(byte[]) may expose internal representation by storing an externally mutable object into NioEndpoint.oomParachuteData  At NioEndpoint.java:[line 247]
M V EI: org.apache.tomcat.util.net.NioEndpoint.getCiphersUsed() may expose internal representation by returning NioEndpoint.enabledCiphers  At NioEndpoint.java:[line 278]
M D BC: Unchecked/unconfirmed cast from org.apache.tomcat.util.net.SocketWrapper<org.apache.tomcat.util.net.NioChannel> to org.apache.tomcat.util.net.NioEndpoint$KeyAttachment in org.apache.tomcat.util.net.NioEndpoint.processSocket(SocketWrapper, SocketStatus, boolean)  At NioEndpoint.java:[line 608]
M D Eq: org.eclipse.jdt.internal.compiler.apt.model.AnnotationMemberValue doesn't override AnnotationValueImpl.equals(Object)  At AnnotationMemberValue.java:[line 1]
M P Bx: org.apache.catalina.tribes.tipis.AbstractReplicatedMap.memberAlive(Member) invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At AbstractReplicatedMap.java:[line 303]
M P Bx: org.apache.catalina.tribes.tipis.AbstractReplicatedMap.mapMemberAdded(Member) invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At AbstractReplicatedMap.java:[line 739]
M V FI: org.apache.catalina.tribes.tipis.AbstractReplicatedMap.finalize() is public; should be protected  At AbstractReplicatedMap.java:[lines 357-361]
M V EI2: org.apache.catalina.tribes.tipis.AbstractReplicatedMap.setExternalLoaders(ClassLoader[]) may expose internal representation by storing an externally mutable object into AbstractReplicatedMap.externalLoaders  At AbstractReplicatedMap.java:[line 1558]
M V EI: org.apache.catalina.tribes.tipis.AbstractReplicatedMap.getExternalLoaders() may expose internal representation by returning AbstractReplicatedMap.externalLoaders  At AbstractReplicatedMap.java:[line 1542]
M V EI: org.apache.catalina.tribes.tipis.AbstractReplicatedMap.getMapContextName() may expose internal representation by returning AbstractReplicatedMap.mapContextName  At AbstractReplicatedMap.java:[line 1518]
H D UC: Useless condition: it's known that i != 9 at this point  At AbstractInputBuffer.java:[line 84]
M V EI: org.apache.coyote.http11.AbstractInputBuffer.getFilters() may expose internal representation by returning AbstractInputBuffer.filterLibrary  At AbstractInputBuffer.java:[line 197]
M V EI: org.apache.tomcat.util.bcel.classfile.Annotations.getAnnotationEntries() may expose internal representation by returning Annotations.annotation_table  At Annotations.java:[line 50]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.tool.EclipseFileObject.openReader(boolean): new java.io.FileReader(File)  At EclipseFileObject.java:[line 185]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.tool.EclipseFileObject.openWriter(): new java.io.FileWriter(File)  At EclipseFileObject.java:[line 194]
M D BC: instanceof will always return true for all non-null values in org.apache.catalina.authenticator.SingleSignOn.startInternal(), since all org.apache.catalina.Engine are instances of org.apache.catalina.Engine  At SingleSignOn.java:[line 598]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.apt.util.EclipseFileObject.openReader(boolean): new java.io.FileReader(File)  At EclipseFileObject.java:[line 174]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.apt.util.EclipseFileObject.openWriter(): new java.io.FileWriter(File)  At EclipseFileObject.java:[line 182]
H P Bx: Boxing/unboxing to parse a primitive org.apache.catalina.tribes.membership.McastService.getRecoveryCounter()  At McastService.java:[line 198]
H P Bx: Boxing/unboxing to parse a primitive org.apache.catalina.tribes.membership.McastService.getRecoverySleepTime()  At McastService.java:[line 222]
H P Bx: Boxing/unboxing to parse a primitive org.apache.catalina.tribes.membership.McastService.getPort()  At McastService.java:[line 241]
H P Bx: Boxing/unboxing to parse a primitive org.apache.catalina.tribes.membership.McastService.getFrequency()  At McastService.java:[line 250]
H P Bx: Boxing/unboxing to parse a primitive org.apache.catalina.tribes.membership.McastService.getDropTime()  At McastService.java:[line 262]
M P Bx: org.apache.catalina.tribes.membership.McastService.getRecoveryCounter() invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At McastService.java:[line 198]
M P Bx: org.apache.catalina.tribes.membership.McastService.getRecoverySleepTime() invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At McastService.java:[line 222]
M P Bx: org.apache.catalina.tribes.membership.McastService.getPort() invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At McastService.java:[line 241]
M P Bx: org.apache.catalina.tribes.membership.McastService.getFrequency() invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At McastService.java:[line 250]
M P Bx: org.apache.catalina.tribes.membership.McastService.getDropTime() invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At McastService.java:[line 262]
M V EI2: org.apache.catalina.tribes.membership.McastService.setDomain(byte[]) may expose internal representation by storing an externally mutable object into McastService.domain  At McastService.java:[line 548]
M V EI: org.apache.catalina.tribes.membership.McastService.getDomain() may expose internal representation by returning McastService.domain  At McastService.java:[line 525]
M V EI2: org.apache.catalina.tribes.membership.McastService.setPayload(byte[]) may expose internal representation by storing an externally mutable object into McastService.payload  At McastService.java:[line 535]
M V EI: org.apache.catalina.tribes.membership.McastService.getPayload() may expose internal representation by returning McastService.payload  At McastService.java:[line 521]
M V EI2: org.apache.coyote.http11.AbstractHttp11Processor.setCompressableMimeTypes(String[]) may expose internal representation by storing an externally mutable object into AbstractHttp11Processor.compressableMimeTypes  At AbstractHttp11Processor.java:[line 307]
M D SF: Switch statement found in org.apache.coyote.http11.AbstractHttp11Processor.process(SocketWrapper) where one case falls through to the next case  At AbstractHttp11Processor.java:[lines 1046-1050]
M P WMI: org.apache.jasper.compiler.TagFileProcessor$TagFileDirectiveVisitor.postCheck() makes inefficient use of keySet iterator instead of entrySet iterator  At TagFileProcessor.java:[line 449]
M V EI: org.apache.tomcat.util.net.jsse.JSSESocketFactory.getEnableableCiphers(SSLContext) may expose internal representation by returning JSSESocketFactory.defaultServerCipherSuites  At JSSESocketFactory.java:[line 274]
M V EI: org.apache.tomcat.util.net.jsse.JSSESocketFactory.getEnabledCiphers() may expose internal representation by returning JSSESocketFactory.enabledCiphers  At JSSESocketFactory.java:[line 328]
M V EI: org.apache.tomcat.util.net.jsse.JSSESocketFactory.getEnableableProtocols(SSLContext) may expose internal representation by returning JSSESocketFactory.defaultServerProtocols  At JSSESocketFactory.java:[line 746]
M D BC: Unchecked/unconfirmed cast from java.net.Socket to javax.net.ssl.SSLSocket in org.apache.tomcat.util.net.jsse.JSSESocketFactory.handshake(Socket)  At JSSESocketFactory.java:[line 255]
M V DP: org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.getClassLoader(JavaFileManager$Location) creates a java.net.URLClassLoader classloader, which should be performed within a doPrivileged block  At EclipseFileManager.java:[line 266]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.normalized(String) where default case is missing  At EclipseFileManager.java:[lines 817-822]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.processPathEntries(int, ArrayList, String, String, boolean, boolean) where default case is missing  At EclipseFileManager.java:[lines 1035-1041]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.processPathEntries(int, ArrayList, String, String, boolean, boolean) where one case falls through to the next case  At EclipseFileManager.java:[lines 948-951]
M P SBSC: org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.processPathEntries(int, ArrayList, String, String, boolean, boolean) concatenates strings using + in a loop  At EclipseFileManager.java:[line 1020]
M V EI2: org.apache.catalina.tribes.transport.nio.NioSender.setMessage(byte[], int, int) may expose internal representation by storing an externally mutable object into NioSender.current  At NioSender.java:[line 356]
M V EI: org.apache.catalina.tribes.transport.nio.NioSender.getMessage() may expose internal representation by returning NioSender.current  At NioSender.java:[line 382]
M B CN: org.apache.catalina.tribes.io.ChannelData defines clone() but doesn't implement Cloneable  At ChannelData.java:[lines 308-314]
M V EI2: org.apache.catalina.tribes.io.ChannelData.setUniqueId(byte[]) may expose internal representation by storing an externally mutable object into ChannelData.uniqueId  At ChannelData.java:[line 131]
M V EI2: new org.apache.catalina.tribes.io.ChannelData(byte[], XByteBuffer, long) may expose internal representation by storing an externally mutable object into ChannelData.uniqueId  At ChannelData.java:[line 87]
M V EI: org.apache.catalina.tribes.io.ChannelData.getUniqueId() may expose internal representation by returning ChannelData.uniqueId  At ChannelData.java:[line 125]
M B Se: Class org.apache.catalina.tribes.io.ChannelData defines non-transient non-serializable instance field message  In ChannelData.java
M D DLS: Dead store to offset in org.apache.catalina.tribes.io.ChannelData.getDataPackage(byte[], int)  At ChannelData.java:[line 221]
M V EI: org.apache.tomcat.util.bcel.classfile.JavaClass.getInterfaceNames() may expose internal representation by returning JavaClass.interface_names  At JavaClass.java:[line 90]
M B Se: Class javax.servlet.jsp.jstl.core.IteratedValueExpression defines non-transient non-serializable instance field iteratedExpression  In IteratedValueExpression.java
M M UL: org.apache.coyote.http11.InternalAprOutputBuffer.writeToSocket(boolean) does not release lock on all exception paths  At InternalAprOutputBuffer.java:[line 251]
M P Dm: org.eclipse.jdt.internal.compiler.batch.Main$Logger.logExtraProblem(CategorizedProblem, int, int) invokes inefficient new String(String) constructor  At Main.java:[line 619]
M P Bx: org.eclipse.jdt.internal.compiler.batch.Main$Logger.logNumberOfClassFilesGenerated(int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Main.java:[line 705]
M P Bx: org.eclipse.jdt.internal.compiler.batch.Main$Logger.logProblemsSummary(int, int, int, int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Main.java:[line 868]
M P Bx: org.eclipse.jdt.internal.compiler.batch.Main$Logger.logTiming(CompilerStats) invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At Main.java:[line 951]
M P Bx: org.eclipse.jdt.internal.compiler.batch.Main$Logger.logXmlExtraProblem(CategorizedProblem, int, int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Main.java:[line 1041]
M P Bx: org.eclipse.jdt.internal.compiler.batch.Main$Logger.logXmlProblem(CategorizedProblem, char[]) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Main.java:[line 1061]
M P Bx: org.eclipse.jdt.internal.compiler.batch.Main$Logger.logXmlTask(CategorizedProblem, char[]) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Main.java:[line 1097]
M P Bx: org.eclipse.jdt.internal.compiler.batch.Main$Logger.startLoggingExtraProblems(int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Main.java:[line 1214]
M P Bx: org.eclipse.jdt.internal.compiler.batch.Main$Logger.startLoggingProblems(int, int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Main.java:[line 1223]
M P Bx: org.eclipse.jdt.internal.compiler.batch.Main$Logger.startLoggingTasks(int) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At Main.java:[line 1269]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.batch.Main$Logger.setLog(String): new java.io.PrintWriter(OutputStream)  At Main.java:[line 1200]
M V EI: org.eclipse.jdt.internal.compiler.lookup.AptBinaryLocalVariableBinding.getAnnotations() may expose internal representation by returning AptBinaryLocalVariableBinding.annotationBindings  At AptBinaryLocalVariableBinding.java:[line 25]
M D IM: Computation of average could overflow in org.apache.jasper.compiler.ELParser.isELReserved(String)  At ELParser.java:[line 183]
M P Bx: org.apache.catalina.tribes.tipis.ReplicatedMap.mapMemberAdded(Member) invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At ReplicatedMap.java:[line 240]
M B Se: Class org.apache.catalina.tribes.tipis.ReplicatedMap defines non-transient non-serializable instance field log  In ReplicatedMap.java
M D REC: Exception is caught when Exception is not thrown in org.apache.jasper.compiler.TagFileProcessor.loadTagFile(Compiler, String, TagInfo, PageInfo)  At TagFileProcessor.java:[line 608]
M D RCN: Redundant nullcheck of mParamTypes, which is known to be non-null in org.apache.el.util.ReflectionUtil.getMethod(EvaluationContext, Object, Object, Class[], Object[])  Redundant null check at ReflectionUtil.java:[line 159]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.JavadocArgumentExpression(char[], int, int, TypeReference) may expose internal representation by storing an externally mutable object into JavadocArgumentExpression.token  At JavadocArgumentExpression.java:[line 23]
M V DP: org.eclipse.jdt.internal.compiler.tool.EclipseFileManager.getClassLoader(JavaFileManager$Location) creates a java.net.URLClassLoader classloader, which should be performed within a doPrivileged block  At EclipseFileManager.java:[line 269]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.tool.EclipseFileManager.normalized(String) where default case is missing  At EclipseFileManager.java:[lines 817-822]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.tool.EclipseFileManager.processPathEntries(int, ArrayList, String, String, boolean, boolean) where default case is missing  At EclipseFileManager.java:[lines 1036-1042]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.tool.EclipseFileManager.processPathEntries(int, ArrayList, String, String, boolean, boolean) where one case falls through to the next case  At EclipseFileManager.java:[lines 949-952]
M P SBSC: org.eclipse.jdt.internal.compiler.tool.EclipseFileManager.processPathEntries(int, ArrayList, String, String, boolean, boolean) concatenates strings using + in a loop  At EclipseFileManager.java:[line 1021]
M P Dm: org.apache.el.stream.Stream.noneMatch(LambdaExpression) invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead  At Stream.java:[line 394]
M B Dm: org.eclipse.jdt.internal.compiler.tool.EclipseCompilerImpl.call() invokes System.exit(...), which shuts down the entire virtual machine  At EclipseCompilerImpl.java:[line 78]
M B RV: Exceptional return value of java.io.File.mkdirs() ignored in org.eclipse.jdt.internal.compiler.tool.EclipseCompilerImpl.outputClassFiles(CompilationResult)  At EclipseCompilerImpl.java:[line 334]
M D SF: Switch statement found in org.apache.coyote.http11.Http11Nio2Processor.actionInternal(ActionCode, Object) where default case is missing  At Http11Nio2Processor.java:[lines 325-538]
M D RCN: Redundant nullcheck of noContext, which is known to be non-null in org.apache.catalina.ssi.SSIServletExternalResolver.getServletContextAndPathFromVirtualPath(String)  Redundant null check at SSIServletExternalResolver.java:[line 432]
H I Dm: Found reliance on default encoding in org.apache.catalina.ssi.SSIServletExternalResolver.getFileText(String, boolean): new String(byte[])  At SSIServletExternalResolver.java:[line 543]
M D SF: Switch statement found in websocket.drawboard.DrawboardEndpoint$3$1.run() where default case is missing  At DrawboardEndpoint.java:[lines 185-207]
H D UC: Useless condition: it's known that hasMultiLines == false at this point  At AbstractCommentParser.java:[line 863]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.AbstractCommentParser.parseParam() where one case falls through to the next case  At AbstractCommentParser.java:[lines 866-869]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.AbstractCommentParser.parseQualifiedName(boolean) where default case is missing  At AbstractCommentParser.java:[lines 1111-1122]
M D RCN: Redundant nullcheck of query, which is known to be non-null in org.apache.catalina.authenticator.DigestAuthenticator$DigestInfo.validate(Request)  Redundant null check at DigestAuthenticator.java:[line 484]
M B Se: Class org.apache.catalina.tribes.tipis.LazyReplicatedMap defines non-transient non-serializable instance field log  In LazyReplicatedMap.java
M B DE: org.apache.catalina.tribes.transport.nio.ParallelNioSender.disconnect() might ignore java.lang.Exception  At ParallelNioSender.java:[line 301]
M V FI: org.apache.catalina.tribes.transport.nio.ParallelNioSender.finalize() is public; should be protected  At ParallelNioSender.java:[lines 306-315]
M D REC: Exception is caught when Exception is not thrown in org.apache.catalina.tribes.transport.nio.ParallelNioSender.sendMessage(Member[], ChannelMessage)  At ParallelNioSender.java:[line 121]
M B RC: Suspicious comparison of Boolean references in org.apache.catalina.connector.CometEventImpl.setTimeout(int)  At CometEventImpl.java:[line 125]
M B RV: Exceptional return value of java.io.File.setLastModified(long) ignored in org.apache.catalina.startup.ExpandWar.expand(Host, URL, String)  At ExpandWar.java:[line 168]
M B RV: Exceptional return value of java.io.File.createNewFile() ignored in org.apache.catalina.startup.ExpandWar.expand(Host, URL, String)  At ExpandWar.java:[line 174]
M B RV: Exceptional return value of java.io.File.delete() ignored in org.apache.catalina.startup.ExpandWar.deleteDir(File, boolean)  At ExpandWar.java:[line 348]
M D REC: Exception is caught when Exception is not thrown in org.apache.catalina.tribes.group.GroupChannel.send(Member[], Serializable, int, ErrorHandler)  At GroupChannel.java:[line 243]
M B RV: Exceptional return value of java.io.File.renameTo(File) ignored in org.apache.catalina.manager.ManagerServlet.deploy(PrintWriter, ContextName, String, boolean, HttpServletRequest, StringManager)  At ManagerServlet.java:[line 726]
M D RCN: Redundant nullcheck of query, which is known to be non-null in org.apache.catalina.valves.ExtendedAccessLogValve$3.addElement(CharArrayWriter, Date, Request, Response, long)  Redundant null check at ExtendedAccessLogValve.java:[line 669]
M D RCN: Redundant nullcheck of query, which is known to be non-null in org.apache.catalina.valves.ExtendedAccessLogValve$2.addElement(CharArrayWriter, Date, Request, Response, long)  Redundant null check at ExtendedAccessLogValve.java:[line 655]
M D SF: Switch statement found in org.apache.jasper.compiler.Generator.generateSetJspContext(TagInfo) where default case is missing  At Generator.java:[lines 3932-3954]
M B RC: Suspicious comparison of Boolean references in org.apache.catalina.servlets.DefaultServlet.checkSendfile(HttpServletRequest, HttpServletResponse, WebResource, long, DefaultServlet$Range)  At DefaultServlet.java:[line 1701]
H I Dm: Found reliance on default encoding in org.apache.catalina.servlets.DefaultServlet.getReadme(WebResource): new java.io.InputStreamReader(InputStream)  At DefaultServlet.java:[line 1543]
H I Dm: Found reliance on default encoding in org.apache.catalina.servlets.DefaultServlet.copy(WebResource, InputStream, PrintWriter, String): new java.io.InputStreamReader(InputStream)  At DefaultServlet.java:[line 1958]
M V EI2: new org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream(int, Scanner, int[], int[], int[], int, int, int) may expose internal representation by storing an externally mutable object into LexStream.intervalFlagsToSkip  At LexStream.java:[line 68]
M V EI2: new org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream(int, Scanner, int[], int[], int[], int, int, int) may expose internal representation by storing an externally mutable object into LexStream.intervalEndToSkip  At LexStream.java:[line 67]
M V EI2: new org.eclipse.jdt.internal.compiler.parser.diagnose.LexStream(int, Scanner, int[], int[], int[], int, int, int) may expose internal representation by storing an externally mutable object into LexStream.intervalStartToSkip  At LexStream.java:[line 66]
M D UC: Useless object stored in variable ncondition of method org.apache.catalina.valves.rewrite.RewriteCond.parse(Map)  At RewriteCond.java:[line 126]
M D UC: Useless object stored in variable condition of method org.apache.catalina.valves.rewrite.RewriteCond.parse(Map)  At RewriteCond.java:[line 118]
M D UC: Useless object stored in variable ncondition of method org.apache.catalina.valves.rewrite.RewriteCond.parse(Map)  At RewriteCond.java:[line 129]
M D UC: Useless object stored in variable ncondition of method org.apache.catalina.valves.rewrite.RewriteCond.parse(Map)  At RewriteCond.java:[line 132]
M D UC: Useless object stored in variable condition of method org.apache.catalina.valves.rewrite.RewriteCond.parse(Map)  At RewriteCond.java:[line 122]
M D UC: Useless object stored in variable condition of method org.apache.catalina.valves.rewrite.RewriteCond.parse(Map)  At RewriteCond.java:[line 135]
M D UC: Useless object stored in variable condition of method org.apache.catalina.valves.rewrite.RewriteCond.parse(Map)  At RewriteCond.java:[line 114]
M V EI2: org.apache.catalina.valves.rewrite.RewriteRule.setConditions(RewriteCond[]) may expose internal representation by storing an externally mutable object into RewriteRule.conditions  At RewriteRule.java:[line 337]
M V EI: org.apache.catalina.valves.rewrite.RewriteRule.getConditions() may expose internal representation by returning RewriteRule.conditions  At RewriteRule.java:[line 334]
M B RV: Exceptional return value of java.io.File.delete() ignored in org.apache.catalina.ha.deploy.FileMessageFactory.isValid()  At FileMessageFactory.java:[line 401]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference.internalResolveType(Scope) where default case is missing  At JavadocFieldReference.java:[lines 61-67]
M V EI2: compressionFilters.CompressionServletResponseWrapper.setCompressionMimeTypes(String[]) may expose internal representation by storing an externally mutable object into CompressionServletResponseWrapper.compressionMimeTypes  At CompressionServletResponseWrapper.java:[line 132]
H I Dm: Found reliance on default encoding in compressionFilters.CompressionServletResponseWrapper.getWriter(): new java.io.PrintWriter(OutputStream)  At CompressionServletResponseWrapper.java:[line 251]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend(char[], long) may expose internal representation by storing an externally mutable object into JavadocMessageSend.selector  At JavadocMessageSend.java:[line 25]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend(char[], long, JavadocArgumentExpression[]) may expose internal representation by storing an externally mutable object into JavadocMessageSend.arguments  At JavadocMessageSend.java:[line 33]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend.internalResolveType(Scope) where default case is missing  At JavadocMessageSend.java:[lines 123-130]
M P Bx: org.apache.catalina.tribes.transport.bio.BioSender.disconnect() invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At BioSender.java:[line 94]
M P Bx: org.apache.catalina.tribes.transport.bio.BioSender.disconnect() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At BioSender.java:[line 94]
M P Bx: org.apache.catalina.tribes.transport.bio.BioSender.sendMessage(byte[], boolean) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At BioSender.java:[line 111]
M P Bx: org.apache.catalina.tribes.transport.bio.BioSender.openSocket() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At BioSender.java:[line 169]
M P Bx: org.apache.catalina.tribes.transport.bio.BioSender.openSocket() invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At BioSender.java:[line 169]
M P Bx: org.apache.catalina.tribes.transport.bio.BioSender.closeSocket() invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At BioSender.java:[line 200]
M P Bx: org.apache.catalina.tribes.transport.bio.BioSender.closeSocket() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At BioSender.java:[line 200]
M P Bx: org.apache.catalina.tribes.transport.bio.BioSender.waitForAck() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At BioSender.java:[line 260]
M P Bx: org.apache.catalina.tribes.transport.bio.BioSender.waitForAck() invokes inefficient new Long(long) constructor; use Long.valueOf(long) instead  At BioSender.java:[line 266]
H I Dm: Found reliance on default encoding in org.apache.catalina.ssi.SSIServlet.processSSI(HttpServletRequest, HttpServletResponse, URL): new java.io.InputStreamReader(InputStream)  At SSIServlet.java:[line 209]
M S HRS: HTTP parameter directly written to HTTP header output in org.apache.catalina.filters.CorsFilter.handleSimpleCORS(HttpServletRequest, HttpServletResponse, FilterChain)  At CorsFilter.java:[line 274]
M S HRS: HTTP parameter directly written to HTTP header output in org.apache.catalina.filters.CorsFilter.handlePreflightCORS(HttpServletRequest, HttpServletResponse, FilterChain)  At CorsFilter.java:[line 377]
M S HRS: HTTP parameter directly written to HTTP header output in org.apache.catalina.filters.CorsFilter.handlePreflightCORS(HttpServletRequest, HttpServletResponse, FilterChain)  At CorsFilter.java:[line 403]
M V EI2: org.apache.catalina.tribes.group.interceptors.DomainFilterInterceptor.setDomain(byte[]) may expose internal representation by storing an externally mutable object into DomainFilterInterceptor.domain  At DomainFilterInterceptor.java:[line 118]
M V EI: org.apache.catalina.tribes.group.interceptors.DomainFilterInterceptor.getDomain() may expose internal representation by returning DomainFilterInterceptor.domain  At DomainFilterInterceptor.java:[line 114]
H D NS: Potentially dangerous use of non-short-circuit logic in org.apache.catalina.tribes.membership.McastServiceImpl$RecoveryThread.run()  At McastServiceImpl.java:[line 642]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(AbstractMethodDeclaration, TypeDeclaration, ImportReference) where default case is missing  At SourceElementNotifier.java:[lines 249-258]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(FieldDeclaration, TypeDeclaration) where one case falls through to the next case  At SourceElementNotifier.java:[lines 486-494]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(FieldDeclaration, TypeDeclaration) where default case is missing  At SourceElementNotifier.java:[lines 480-554]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(TypeDeclaration, boolean, TypeDeclaration, ImportReference) where default case is missing  At SourceElementNotifier.java:[lines 636-648]
M D REC: Exception is caught when Exception is not thrown in org.apache.tomcat.jdbc.pool.interceptor.StatementCache$CachedStatement.closeInvoked()  At StatementCache.java:[line 249]
M V EI: org.eclipse.jdt.internal.compiler.ast.TrueLiteral.source() may expose internal representation by returning TrueLiteral.source  At TrueLiteral.java:[line 67]
M V EI2: new org.apache.catalina.tribes.group.interceptors.FragmentationInterceptor$FragKey(byte[]) may expose internal representation by storing an externally mutable object into FragmentationInterceptor$FragKey.uniqueId  At FragmentationInterceptor.java:[line 226]
M M ML: Synchronization on AprEndpoint$SocketWithOptionsProcessor.socket in futile attempt to guard it  At AprEndpoint.java:[line 2429]
M M ML: Synchronization on AprEndpoint$SocketWithOptionsProcessor.socket in futile attempt to guard it  At AprEndpoint.java:[line 2445]
M B OS: org.apache.taglibs.standard.tag.common.core.ImportSupport.acquireString() may fail to close stream  At ImportSupport.java:[line 242]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.tool.EclipseCompiler.getTask(Writer, JavaFileManager, DiagnosticListener, Iterable, Iterable, Iterable): new java.io.PrintWriter(OutputStream)  At EclipseCompiler.java:[line 95]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.internal.compiler.tool.EclipseCompiler.run(InputStream, OutputStream, OutputStream, String[]): new java.io.OutputStreamWriter(OutputStream)  At EclipseCompiler.java:[line 224]
M D NP: Load of known null value in org.apache.jasper.el.ELResolverImpl.getValue(ELContext, Object, Object)  At ELResolverImpl.java:[line 48]
M D NP: Load of known null value in org.apache.jasper.el.ELResolverImpl.getType(ELContext, Object, Object)  At ELResolverImpl.java:[line 72]
M D NP: Load of known null value in org.apache.jasper.el.ELResolverImpl.setValue(ELContext, Object, Object, Object)  At ELResolverImpl.java:[line 98]
M D NP: Load of known null value in org.apache.jasper.el.ELResolverImpl.isReadOnly(ELContext, Object, Object)  At ELResolverImpl.java:[line 115]
M V EI: org.eclipse.jdt.internal.compiler.ast.MessageSend.arguments() may expose internal representation by returning MessageSend.arguments  At MessageSend.java:[line 1040]
M V EI: org.eclipse.jdt.internal.compiler.ast.MessageSend.genericTypeArguments() may expose internal representation by returning MessageSend.genericTypeArguments  At MessageSend.java:[line 471]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.MessageSend.postConversionType(Scope) where default case is missing  At MessageSend.java:[lines 536-559]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(BlockScope) where default case is missing  At MessageSend.java:[lines 721-730]
M B RV: Exceptional return value of java.io.File.delete() ignored in org.apache.catalina.session.FileStore.remove(String)  At FileStore.java:[line 307]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.flow.FinallyFlowContext.complainOnDeferredChecks(FlowInfo, BlockScope) where default case is missing  At FinallyFlowContext.java:[lines 132-212]
M B RC: Suspicious comparison of Boolean references in org.apache.catalina.core.StandardWrapperValve.invoke(Request, Response)  At StandardWrapperValve.java:[line 168]
M D SF: Switch statement found in org.apache.tomcat.util.http.parser.Cookie.logInvalidHeader(Cookie$ByteBuffer) where one case falls through to the next case  At Cookie.java:[lines 584-587]
M D SF: Switch statement found in org.apache.tomcat.util.http.parser.Cookie.logInvalidVersion(Cookie$ByteBuffer) where one case falls through to the next case  At Cookie.java:[lines 609-612]
M V EI: org.apache.tomcat.jdbc.pool.interceptor.StatementCache.getTypes() may expose internal representation by returning StatementCache.types  At StatementCache.java:[line 63]
M V DP: org.apache.catalina.loader.WebappClassLoader.copyWithoutTransformers() creates a org.apache.catalina.loader.WebappClassLoader classloader, which should be performed within a doPrivileged block  At WebappClassLoader.java:[line 51]
M B FI: NioBlockingSelector.java:[line 416] is set to null inside finalize method in org.apache.tomcat.util.net.NioBlockingSelector$KeyReference  At NioBlockingSelector.java:[line 416]
M V FI: org.apache.tomcat.util.net.NioBlockingSelector$KeyReference.finalize() is public; should be protected  At NioBlockingSelector.java:[lines 412-417]
H S HRS: HTTP cookie formed from untrusted input in CookieExample.doGet(HttpServletRequest, HttpServletResponse)  At CookieExample.java:[line 54]
M D RCN: Redundant nullcheck of decodedRequestURI, which is known to be non-null in org.apache.catalina.authenticator.FormAuthenticator.matchRequest(Request)  Redundant null check at FormAuthenticator.java:[line 472]
M V EI2: new org.eclipse.jdt.internal.compiler.ast.JavadocImplicitTypeReference(char[], int) may expose internal representation by storing an externally mutable object into JavadocImplicitTypeReference.token  At JavadocImplicitTypeReference.java:[line 25]
M V EI: org.eclipse.jdt.internal.compiler.ast.JavadocImplicitTypeReference.getLastToken() may expose internal representation by returning JavadocImplicitTypeReference.token  At JavadocImplicitTypeReference.java:[line 43]
M B RV: Exceptional return value of java.io.File.renameTo(File) ignored in org.apache.catalina.users.MemoryUserDatabase.save()  At MemoryUserDatabase.java:[line 601]
M B RV: Exceptional return value of java.io.File.delete() ignored in org.apache.catalina.users.MemoryUserDatabase.save()  At MemoryUserDatabase.java:[line 565]
M D RCN: Redundant nullcheck of method, which is known to be non-null in org.apache.catalina.valves.AbstractAccessLogValve$RequestElement.addElement(CharArrayWriter, Date, Request, Response, long)  Redundant null check at AbstractAccessLogValve.java:[line 1056]
M V EI2: new org.apache.el.MethodExpressionLiteral(String, Class, Class[]) may expose internal representation by storing an externally mutable object into MethodExpressionLiteral.paramTypes  At MethodExpressionLiteral.java:[line 49]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.JavadocParser.parseSimpleTag() where default case is missing  At JavadocParser.java:[lines 401-413]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.parser.JavadocParser.updateDocComment() where default case is missing  At JavadocParser.java:[lines 938-957]
M V EI2: new org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator$CoordinationMessage(Member, Member, Member[], UniqueId, byte[]) may expose internal representation by storing an externally mutable object into NonBlockingCoordinator$CoordinationMessage.type  At NonBlockingCoordinator.java:[line 643]
M V EI: org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator$CoordinationMessage.getMembers() may expose internal representation by returning NonBlockingCoordinator$CoordinationMessage.view  At NonBlockingCoordinator.java:[line 669]
M V EI: org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator$CoordinationMessage.getType() may expose internal representation by returning NonBlockingCoordinator$CoordinationMessage.type  At NonBlockingCoordinator.java:[line 674]
M V EI2: new org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator$CoordinationMessage(Member, Member, Member[], UniqueId, byte[]) may expose internal representation by storing an externally mutable object into NonBlockingCoordinator$CoordinationMessage.view  At NonBlockingCoordinator.java:[line 641]
M B OS: org.eclipse.jdt.core.CheckDebugAttributes.execute() may fail to close stream  At CheckDebugAttributes.java:[line 61]
M D BC: instanceof will always return true for all non-null values in org.apache.el.parser.AstFunction.getValue(EvaluationContext), since all javax.el.ValueExpression are instances of javax.el.ValueExpression  At AstFunction.java:[line 106]
M D RCN: Redundant nullcheck of principal, which is known to be non-null in org.apache.catalina.realm.JAASRealm.authenticate(String, CallbackHandler)  Redundant null check at JAASRealm.java:[line 446]
M M SC: new org.eclipse.jdt.internal.compiler.ProcessTaskManager(Compiler) invokes Thread.start()  At ProcessTaskManager.java:[line 44]
M B RV: Exceptional return value of java.io.File.delete() ignored in org.apache.jasper.compiler.AntCompiler.generateClass(String[])  At AntCompiler.java:[line 253]
M D RCN: Redundant nullcheck of current, which is known to be non-null in org.apache.tomcat.util.modeler.BaseModelMBean.getNotificationInfo()  Redundant null check at BaseModelMBean.java:[line 805]
H P Bx: Boxing/unboxing to parse a primitive org.apache.catalina.servlets.WebdavServlet.doLock(HttpServletRequest, HttpServletResponse)  At WebdavServlet.java:[line 885]
M P Bx: org.apache.catalina.servlets.WebdavServlet.doLock(HttpServletRequest, HttpServletResponse) invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At WebdavServlet.java:[line 885]
M D SF: Switch statement found in org.apache.catalina.servlets.WebdavServlet.doPropfind(HttpServletRequest, HttpServletResponse) where default case is missing  At WebdavServlet.java:[lines 488-500]
M D SF: Switch statement found in org.apache.catalina.servlets.WebdavServlet.doLock(HttpServletRequest, HttpServletResponse) where default case is missing  At WebdavServlet.java:[lines 940-952]
M D SF: Switch statement found in org.apache.catalina.servlets.WebdavServlet.parseProperties(HttpServletRequest, XMLWriter, String, int, Vector) where default case is missing  At WebdavServlet.java:[lines 1932-2152]
M D SF: Switch statement found in org.apache.catalina.servlets.WebdavServlet.parseLockNullProperties(HttpServletRequest, XMLWriter, String, int, Vector) where default case is missing  At WebdavServlet.java:[lines 2213-2386]
M B Se: Class org.apache.catalina.servlets.WebdavServlet defines non-transient non-serializable instance field resourceLocks  In WebdavServlet.java
M B Se: Class org.apache.catalina.servlets.WebdavServlet defines non-transient non-serializable instance field collectionLocks  In WebdavServlet.java
H I Dm: Found reliance on default encoding in org.apache.catalina.ha.backend.TcpSender.send(String): new java.io.OutputStreamWriter(OutputStream)  At TcpSender.java:[line 107]
H I Dm: Found reliance on default encoding in org.apache.catalina.ha.backend.TcpSender.send(String): new java.io.InputStreamReader(InputStream)  At TcpSender.java:[line 106]
M D RCN: Redundant nullcheck of org.apache.catalina.mbeans.MBeanUtils.createMBean(UserDatabase), which is known to be non-null in org.apache.catalina.mbeans.GlobalResourcesLifecycleListener.createMBeans(String, UserDatabase)  Redundant null check at GlobalResourcesLifecycleListener.java:[line 180]
M D RCN: Redundant nullcheck of org.apache.catalina.mbeans.MBeanUtils.createMBean(Role), which is known to be non-null in org.apache.catalina.mbeans.GlobalResourcesLifecycleListener.createMBeans(String, UserDatabase)  Redundant null check at GlobalResourcesLifecycleListener.java:[line 192]
M D RCN: Redundant nullcheck of org.apache.catalina.mbeans.MBeanUtils.createMBean(Group), which is known to be non-null in org.apache.catalina.mbeans.GlobalResourcesLifecycleListener.createMBeans(String, UserDatabase)  Redundant null check at GlobalResourcesLifecycleListener.java:[line 205]
M D RCN: Redundant nullcheck of org.apache.catalina.mbeans.MBeanUtils.createMBean(User), which is known to be non-null in org.apache.catalina.mbeans.GlobalResourcesLifecycleListener.createMBeans(String, UserDatabase)  Redundant null check at GlobalResourcesLifecycleListener.java:[line 218]
H P Dm: org.apache.tomcat.util.scan.StandardJarScanner.scan(JarScanType, ServletContext, JarScannerCallback) is or uses a map or set of URLs, which can be a performance hog  At StandardJarScanner.java:[line 223]
H P Dm: org.apache.tomcat.util.scan.StandardJarScanner.scan(JarScanType, ServletContext, JarScannerCallback) is or uses a map or set of URLs, which can be a performance hog  At StandardJarScanner.java:[line 161]
H P Dm: org.apache.tomcat.util.scan.StandardJarScanner.scan(JarScanType, ServletContext, JarScannerCallback) is or uses a map or set of URLs, which can be a performance hog  At StandardJarScanner.java:[line 223]
M D DLS: Dead store to i in org.apache.jasper.compiler.JspDocumentParser.processChars()  At JspDocumentParser.java:[line 629]
M D DLS: Dead store to unused in org.apache.jasper.compiler.JspDocumentParser.processChars()  At JspDocumentParser.java:[line 558]
H D ST: Write to static field org.apache.catalina.core.AprLifecycleListener.instanceCreated from instance method new org.apache.catalina.core.AprLifecycleListener()  At AprLifecycleListener.java:[line 113]
M D ST: Write to static field org.apache.catalina.core.AprLifecycleListener.SSLEngine from instance method org.apache.catalina.core.AprLifecycleListener.setSSLEngine(String)  At AprLifecycleListener.java:[line 358]
M D ST: Write to static field org.apache.catalina.core.AprLifecycleListener.SSLRandomSeed from instance method org.apache.catalina.core.AprLifecycleListener.setSSLRandomSeed(String)  At AprLifecycleListener.java:[line 374]
M D ST: Write to static field org.apache.catalina.core.AprLifecycleListener.FIPSMode from instance method org.apache.catalina.core.AprLifecycleListener.setFIPSMode(String)  At AprLifecycleListener.java:[line 390]
M B DE: org.apache.catalina.tribes.transport.bio.MultipointBioSender.finalize() might ignore java.lang.Exception  At MultipointBioSender.java:[line 129]
M B DE: org.apache.catalina.tribes.transport.bio.MultipointBioSender.disconnect() might ignore java.lang.Exception  At MultipointBioSender.java:[line 123]
M V FI: org.apache.catalina.tribes.transport.bio.MultipointBioSender.finalize() is public; should be protected  At MultipointBioSender.java:[lines 129-131]
M V EI2: new org.apache.naming.SelectorContext(Hashtable) may expose internal representation by storing an externally mutable object into SelectorContext.env  At SelectorContext.java:[line 70]
M V EI2: new org.apache.naming.SelectorContext(Hashtable, boolean) may expose internal representation by storing an externally mutable object into SelectorContext.env  At SelectorContext.java:[line 80]
M B ES: Comparison of String parameter using == or != in org.apache.jasper.compiler.Parser.parseBody(Node, String, String)   At Parser.java:[line 1672]
M B ES: Comparison of String parameter using == or != in org.apache.jasper.compiler.Parser.parseBody(Node, String, String)   At Parser.java:[line 1677]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseTaglibDirective(Node)  At Parser.java:[line 441]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseAttributeDirective(Node)  At Parser.java:[line 596]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseVariableDirective(Node)  At Parser.java:[line 606]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseComment(Node)  At Parser.java:[line 621]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseDeclaration(Node)  At Parser.java:[line 636]
M D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseXMLDeclaration(Node)  At Parser.java:[line 663]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseExpression(Node)  At Parser.java:[line 697]
M D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseXMLExpression(Node)  At Parser.java:[line 722]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseELExpression(Node, char)  At Parser.java:[line 756]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseScriptlet(Node)  At Parser.java:[line 772]
M D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseXMLScriptlet(Node)  At Parser.java:[line 797]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseTemplateText(Node)  At Parser.java:[line 1335]
M D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseXMLTemplateText(Node)  At Parser.java:[line 1398]
H D DLS: Dead store to unused in org.apache.jasper.compiler.Parser.parseTagDependentBody(Node, String)  At Parser.java:[line 1605]
M D SF: Switch statement found in org.apache.tomcat.jdbc.pool.interceptor.ConnectionState.invoke(Object, Method, Object[]) where default case is missing  At ConnectionState.java:[lines 154-158]
M D NP: Load of known null value in javax.servlet.jsp.el.ImplicitObjectELResolver.getValue(ELContext, Object, Object)  At ImplicitObjectELResolver.java:[line 90]
M D NP: Load of known null value in javax.servlet.jsp.el.ImplicitObjectELResolver.getType(ELContext, Object, Object)  At ImplicitObjectELResolver.java:[line 130]
M D NP: Load of known null value in javax.servlet.jsp.el.ImplicitObjectELResolver.setValue(ELContext, Object, Object, Object)  At ImplicitObjectELResolver.java:[line 146]
M D NP: Load of known null value in javax.servlet.jsp.el.ImplicitObjectELResolver.isReadOnly(ELContext, Object, Object)  At ImplicitObjectELResolver.java:[line 161]
M D RCN: Redundant nullcheck of info, which is known to be non-null in org.apache.jasper.runtime.JspRuntimeLibrary.getReadMethod(Class, String)  Redundant null check at JspRuntimeLibrary.java:[line 783]
M D RCN: Redundant nullcheck of info, which is known to be non-null in org.apache.jasper.runtime.JspRuntimeLibrary.getWriteMethod(Class, String)  Redundant null check at JspRuntimeLibrary.java:[line 739]
M P Bx: org.apache.jasper.runtime.JspRuntimeLibrary.createTypedArray(String, Object, Method, String[], Class, Class) invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At JspRuntimeLibrary.java:[line 447]
M P Bx: org.apache.jasper.runtime.JspRuntimeLibrary.createTypedArray(String, Object, Method, String[], Class, Class) invokes inefficient new Byte(String) constructor; use Byte.valueOf(String) instead  At JspRuntimeLibrary.java:[line 452]
M P Bx: org.apache.jasper.runtime.JspRuntimeLibrary.createTypedArray(String, Object, Method, String[], Class, Class) invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At JspRuntimeLibrary.java:[line 467]
M P Bx: org.apache.jasper.runtime.JspRuntimeLibrary.createTypedArray(String, Object, Method, String[], Class, Class) invokes inefficient new Short(String) constructor; use Short.valueOf(String) instead  At JspRuntimeLibrary.java:[line 462]
M P SBSC: org.apache.jasper.runtime.JspRuntimeLibrary.escapeQueryString(String) concatenates strings using + in a loop  At JspRuntimeLibrary.java:[line 559]
M D REC: Exception is caught when Exception is not thrown in org.apache.jasper.runtime.JspRuntimeLibrary.createTypedArray(String, Object, Method, String[], Class, Class)  At JspRuntimeLibrary.java:[line 533]
H I Dm: Found reliance on default encoding in org.apache.jasper.runtime.JspRuntimeLibrary.URLEncode(String, String): new java.io.OutputStreamWriter(OutputStream)  At JspRuntimeLibrary.java:[line 965]
M S SQL: A prepared statement is generated from a nonconstant String in org.apache.catalina.valves.JDBCAccessLogValve.open()   At JDBCAccessLogValve.java:[line 588]
M D SF: Switch statement found in org.apache.coyote.http11.Http11Processor.actionInternal(ActionCode, Object) where default case is missing  At Http11Processor.java:[lines 240-375]
M D SF: Switch statement found in org.apache.jasper.runtime.JspContextWrapper.copyTagToPageScope(int) where default case is missing  At JspContextWrapper.java:[lines 419-432]
H D DLS: Dead store to listener in nonblocking.ByteCounter.doPost(HttpServletRequest, HttpServletResponse)  At ByteCounter.java:[line 66]
M M UG: org.apache.catalina.util.LifecycleBase.getState() is unsynchronized, org.apache.catalina.util.LifecycleBase.setState(LifecycleState, Object) is synchronized  At LifecycleBase.java:[line 324]
M P SBSC: org.eclipse.jdt.core.JDTCompilerAdapter.logAndAddFilesToCompile(Commandline) concatenates strings using + in a loop  At JDTCompilerAdapter.java:[line 552]
H I Dm: Found reliance on default encoding in org.eclipse.jdt.core.JDTCompilerAdapter.execute(): new java.io.PrintWriter(OutputStream)  At JDTCompilerAdapter.java:[line 78]
M B BIT: Check for sign of bitwise operation in org.apache.catalina.startup.ContextConfig.checkHandlesTypes(JavaClass)  At ContextConfig.java:[line 2049]
M X OBL: org.apache.catalina.startup.ContextConfig.getWebXmlSource(String, String) may fail to clean up java.io.InputStream  Obligation to clean up resource created at ContextConfig.java:[line 1830] is not discharged
M X OBL: org.apache.catalina.startup.ContextConfig.getContextWebXmlSource() may fail to clean up java.io.InputStream  Obligation to clean up resource created at ContextConfig.java:[line 1764] is not discharged
M D SF: Switch statement found in org.apache.el.parser.ELParser.jj_rescan_token() where default case is missing  At ELParser.java:[lines 3100-3108]
M B Nm: The method name org.apache.el.parser.ELParser.CompositeExpression() doesn't start with a lower case letter  At ELParser.java:[lines 23-75]
M B Nm: The method name org.apache.el.parser.ELParser.LiteralExpression() doesn't start with a lower case letter  At ELParser.java:[lines 87-100]
M B Nm: The method name org.apache.el.parser.ELParser.DeferredExpression() doesn't start with a lower case letter  At ELParser.java:[lines 108-134]
M B Nm: The method name org.apache.el.parser.ELParser.DynamicExpression() doesn't start with a lower case letter  At ELParser.java:[lines 142-168]
M B Nm: The method name org.apache.el.parser.ELParser.Expression() doesn't start with a lower case letter  At ELParser.java:[lines 175-176]
M B Nm: The method name org.apache.el.parser.ELParser.Semicolon() doesn't start with a lower case letter  At ELParser.java:[lines 182-219]
M B Nm: The method name org.apache.el.parser.ELParser.Assignment() doesn't start with a lower case letter  At ELParser.java:[lines 225-284]
M B Nm: The method name org.apache.el.parser.ELParser.LambdaExpression() doesn't start with a lower case letter  At ELParser.java:[lines 291-342]
M B Nm: The method name org.apache.el.parser.ELParser.LambdaParameters() doesn't start with a lower case letter  At ELParser.java:[lines 349-406]
M B Nm: The method name org.apache.el.parser.ELParser.LambdaExpressionOrInvocation() doesn't start with a lower case letter  At ELParser.java:[lines 414-479]
M B Nm: The method name org.apache.el.parser.ELParser.Choice() doesn't start with a lower case letter  At ELParser.java:[lines 486-522]
M B Nm: The method name org.apache.el.parser.ELParser.Or() doesn't start with a lower case letter  At ELParser.java:[lines 529-578]
M B Nm: The method name org.apache.el.parser.ELParser.And() doesn't start with a lower case letter  At ELParser.java:[lines 585-634]
M B Nm: The method name org.apache.el.parser.ELParser.Equality() doesn't start with a lower case letter  At ELParser.java:[lines 641-740]
M B Nm: The method name org.apache.el.parser.ELParser.Compare() doesn't start with a lower case letter  At ELParser.java:[lines 747-928]
M B Nm: The method name org.apache.el.parser.ELParser.Concatenation() doesn't start with a lower case letter  At ELParser.java:[lines 936-973]
M B Nm: The method name org.apache.el.parser.ELParser.Math() doesn't start with a lower case letter  At ELParser.java:[lines 980-1053]
M B Nm: The method name org.apache.el.parser.ELParser.Multiplication() doesn't start with a lower case letter  At ELParser.java:[lines 1060-1187]
M B Nm: The method name org.apache.el.parser.ELParser.Unary() doesn't start with a lower case letter  At ELParser.java:[lines 1194-1305]
M B Nm: The method name org.apache.el.parser.ELParser.Value() doesn't start with a lower case letter  At ELParser.java:[lines 1312-1349]
M B Nm: The method name org.apache.el.parser.ELParser.ValuePrefix() doesn't start with a lower case letter  At ELParser.java:[lines 1356-1376]
M B Nm: The method name org.apache.el.parser.ELParser.ValueSuffix() doesn't start with a lower case letter  At ELParser.java:[lines 1383-1403]
M B Nm: The method name org.apache.el.parser.ELParser.DotSuffix() doesn't start with a lower case letter  At ELParser.java:[lines 1411-1425]
M B Nm: The method name org.apache.el.parser.ELParser.BracketSuffix() doesn't start with a lower case letter  At ELParser.java:[lines 1433-1459]
M B Nm: The method name org.apache.el.parser.ELParser.MethodParameters() doesn't start with a lower case letter  At ELParser.java:[lines 1466-1525]
M B Nm: The method name org.apache.el.parser.ELParser.NonLiteral() doesn't start with a lower case letter  At ELParser.java:[lines 1532-1572]
M B Nm: The method name org.apache.el.parser.ELParser.SetData() doesn't start with a lower case letter  At ELParser.java:[lines 1581-1640]
M B Nm: The method name org.apache.el.parser.ELParser.ListData() doesn't start with a lower case letter  At ELParser.java:[lines 1644-1703]
M B Nm: The method name org.apache.el.parser.ELParser.MapData() doesn't start with a lower case letter  At ELParser.java:[lines 1712-1771]
M B Nm: The method name org.apache.el.parser.ELParser.MapEntry() doesn't start with a lower case letter  At ELParser.java:[lines 1775-1801]
M B Nm: The method name org.apache.el.parser.ELParser.Identifier() doesn't start with a lower case letter  At ELParser.java:[lines 1809-1822]
M B Nm: The method name org.apache.el.parser.ELParser.Function() doesn't start with a lower case letter  At ELParser.java:[lines 1830-1882]
M B Nm: The method name org.apache.el.parser.ELParser.Literal() doesn't start with a lower case letter  At ELParser.java:[lines 1889-1911]
M B Nm: The method name org.apache.el.parser.ELParser.Boolean() doesn't start with a lower case letter  At ELParser.java:[lines 1918-1948]
M B Nm: The method name org.apache.el.parser.ELParser.FloatingPoint() doesn't start with a lower case letter  At ELParser.java:[lines 1956-1969]
M B Nm: The method name org.apache.el.parser.ELParser.Integer() doesn't start with a lower case letter  At ELParser.java:[lines 1977-1990]
M B Nm: The method name org.apache.el.parser.ELParser.String() doesn't start with a lower case letter  At ELParser.java:[lines 1998-2011]
M B Nm: The method name org.apache.el.parser.ELParser.Null() doesn't start with a lower case letter  At ELParser.java:[lines 2019-2029]
M B Nm: The method name org.apache.el.parser.ELParser.ReInit(InputStream) doesn't start with a lower case letter  At ELParser.java:[lines 2884-2885]
M B Nm: The method name org.apache.el.parser.ELParser.ReInit(InputStream, String) doesn't start with a lower case letter  At ELParser.java:[lines 2888-2896]
M B Nm: The method name org.apache.el.parser.ELParser.ReInit(Reader) doesn't start with a lower case letter  At ELParser.java:[lines 2911-2919]
M B Nm: The method name org.apache.el.parser.ELParser.ReInit(ELParserTokenManager) doesn't start with a lower case letter  At ELParser.java:[lines 2933-2940]
M B DE: org.apache.catalina.valves.rewrite.RewriteValve.invoke(Request, Response) might ignore java.lang.Exception  At RewriteValve.java:[line 476]
M B RC: Suspicious comparison of Boolean references in org.apache.catalina.valves.rewrite.RewriteValve.invoke(Request, Response)  At RewriteValve.java:[line 266]
M D NP: Load of known null value in org.apache.el.parser.AstValue.getTarget(EvaluationContext)  At AstValue.java:[line 119]
H X LG: Changes to logger could be lost in org.apache.catalina.startup.Tomcat.setSilent(boolean)  At Tomcat.java:[line 675]
H X LG: Changes to logger could be lost in org.apache.catalina.startup.Tomcat.silence(Host, String)  At Tomcat.java:[line 683]
M B RV: Exceptional return value of java.io.File.mkdirs() ignored in org.apache.catalina.startup.Tomcat.initBaseDir()  At Tomcat.java:[line 629]
M D Eq: org.eclipse.jdt.internal.compiler.apt.model.DeclaredTypeImpl doesn't override TypeMirrorImpl.equals(Object)  At DeclaredTypeImpl.java:[line 1]
H I Dm: Found reliance on default encoding in org.apache.catalina.tribes.membership.Constants.main(String[]): String.getBytes()  At Constants.java:[line 31]
H P Bx: Boxing/unboxing to parse a primitive org.apache.jasper.runtime.JspFactoryImpl.<static initializer for JspFactoryImpl>()  At JspFactoryImpl.java:[line 45]
M P WMI: org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory.validatePropertyNames(Reference, Name, List, List) makes inefficient use of keySet iterator instead of entrySet iterator  At BasicDataSourceFactory.java:[line 296]
H D UC: Useless condition: it's known that lastModified != 0 at this point  At HostConfig.java:[line 1329]
M M SWL: org.apache.catalina.startup.HostConfig.checkResources(HostConfig$DeployedApplication, boolean) calls Thread.sleep() with a lock held  At HostConfig.java:[line 1321]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding(MethodBinding, MethodBinding, char[], TypeBinding[], SourceTypeBinding) may expose internal representation by storing an externally mutable object into SyntheticMethodBinding.selector  At SyntheticMethodBinding.java:[line 375]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding(LambdaExpression, char[], SourceTypeBinding) may expose internal representation by storing an externally mutable object into SyntheticMethodBinding.selector  At SyntheticMethodBinding.java:[line 361]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding(int, ArrayBinding, char[], SourceTypeBinding) may expose internal representation by storing an externally mutable object into SyntheticMethodBinding.selector  At SyntheticMethodBinding.java:[line 346]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding(FieldBinding, ReferenceBinding, TypeBinding, char[]) may expose internal representation by storing an externally mutable object into SyntheticMethodBinding.selector  At SyntheticMethodBinding.java:[line 171]
M V EI2: new org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding(SourceTypeBinding, char[]) may expose internal representation by storing an externally mutable object into SyntheticMethodBinding.selector  At SyntheticMethodBinding.java:[line 263]
M V DP: org.apache.catalina.loader.ParallelWebappClassLoader.copyWithoutTransformers() creates a org.apache.catalina.loader.ParallelWebappClassLoader classloader, which should be performed within a doPrivileged block  At ParallelWebappClassLoader.java:[line 61]
M D RCN: Redundant nullcheck of firstBound, which is known to be non-null in org.eclipse.jdt.internal.compiler.apt.model.TypeVariableImpl.getUpperBound()  Redundant null check at TypeVariableImpl.java:[line 62]
H I Dm: Found reliance on default encoding in org.apache.catalina.ssi.SSIFilter.doFilter(ServletRequest, ServletResponse, FilterChain): new String(byte[])  At SSIFilter.java:[line 178]
M P Dm: org.eclipse.jdt.internal.compiler.apt.model.AnnotationMirrorImpl.invoke(Object, Method, Object[]) invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead  At AnnotationMirrorImpl.java:[line 201]
M P Bx: org.eclipse.jdt.internal.compiler.apt.model.AnnotationMirrorImpl.invoke(Object, Method, Object[]) invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At AnnotationMirrorImpl.java:[line 191]
M P Bx: org.apache.tomcat.jdbc.naming.GenericNamingResourcesFactory.setProperty(Object, String, String) invokes inefficient new Integer(String) constructor; use Integer.valueOf(String) instead  At GenericNamingResourcesFactory.java:[line 123]
M P Bx: org.apache.tomcat.jdbc.naming.GenericNamingResourcesFactory.setProperty(Object, String, String) invokes inefficient new Long(String) constructor; use Long.valueOf(String) instead  At GenericNamingResourcesFactory.java:[line 131]
M V DP: org.apache.jasper.JspC.initClassLoader() creates a java.net.URLClassLoader classloader, which should be performed within a doPrivileged block  At JspC.java:[line 1584]
M V EI2: org.apache.jasper.JspC.setArgs(String[]) may expose internal representation by storing an externally mutable object into JspC.args  At JspC.java:[line 297]
H I Dm: Found reliance on default encoding in org.apache.jasper.JspC.initServletContext(ClassLoader): new java.io.PrintWriter(OutputStream)  At JspC.java:[line 1481]
H I Dm: Found reliance on default encoding in org.apache.jasper.JspC.openWebxmlReader(File): new java.io.InputStreamReader(InputStream)  At JspC.java:[line 1664]
H I Dm: Found reliance on default encoding in org.apache.jasper.JspC.openWebxmlWriter(File): new java.io.OutputStreamWriter(OutputStream)  At JspC.java:[line 1675]
M B RV: Exceptional return value of java.io.File.delete() ignored in org.apache.jasper.compiler.JDTCompiler.generateClass(String[])  At JDTCompiler.java:[line 444]
H P Bx: Primitive boxed just to call toString in org.apache.catalina.filters.RequestDumperFilter.doFilter(ServletRequest, ServletResponse, FilterChain)  At RequestDumperFilter.java:[line 111]
M V EI2: new org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl(CompilationUnitDeclaration[], ReferenceBinding[], boolean, BaseProcessingEnvImpl) may expose internal representation by storing an externally mutable object into RoundEnvImpl._units  At RoundEnvImpl.java:[line 51]
M V EI2: new org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl(CompilationUnitDeclaration[], ReferenceBinding[], boolean, BaseProcessingEnvImpl) may expose internal representation by storing an externally mutable object into RoundEnvImpl._binaryTypes  At RoundEnvImpl.java:[line 65]
M V EI: org.eclipse.jdt.internal.compiler.ast.NullLiteral.source() may expose internal representation by returning NullLiteral.source  At NullLiteral.java:[line 64]
H D ST: Write to static field org.apache.tomcat.util.buf.StringCache.cacheSize from instance method org.apache.tomcat.util.buf.StringCache.setCacheSize(int)  At StringCache.java:[line 129]
H D ST: Write to static field org.apache.tomcat.util.buf.StringCache.byteEnabled from instance method org.apache.tomcat.util.buf.StringCache.setByteEnabled(boolean)  At StringCache.java:[line 145]
H D ST: Write to static field org.apache.tomcat.util.buf.StringCache.charEnabled from instance method org.apache.tomcat.util.buf.StringCache.setCharEnabled(boolean)  At StringCache.java:[line 161]
H D ST: Write to static field org.apache.tomcat.util.buf.StringCache.trainThreshold from instance method org.apache.tomcat.util.buf.StringCache.setTrainThreshold(int)  At StringCache.java:[line 177]
H D ST: Write to static field org.apache.tomcat.util.buf.StringCache.hitCount from instance method org.apache.tomcat.util.buf.StringCache.reset()  At StringCache.java:[line 201]
H D ST: Write to static field org.apache.tomcat.util.buf.StringCache.accessCount from instance method org.apache.tomcat.util.buf.StringCache.reset()  At StringCache.java:[line 202]
M D RCN: Redundant nullcheck of valve, which is known to be non-null in org.apache.catalina.mbeans.ContainerMBean.addValve(String)  Redundant null check at ContainerMBean.java:[line 157]
M D DB: org.apache.jasper.runtime.PageContextImpl.release() uses the same code for two branches  At PageContextImpl.java:[line 176]
M D SF: Switch statement found in org.apache.tomcat.util.http.LegacyCookieProcessor.processCookieHeader(byte[], int, int, ServerCookies) where one case falls through to the next case  At LegacyCookieProcessor.java:[lines 574-578]
M V EI: org.eclipse.jdt.internal.compiler.ast.FalseLiteral.source() may expose internal representation by returning FalseLiteral.source  At FalseLiteral.java:[line 66]
M D REC: Exception is caught when Exception is not thrown in org.apache.tomcat.websocket.AsyncChannelWrapperSecure$ReadTask.run()  At AsyncChannelWrapperSecure.java:[line 337]
M D BC: Unchecked/unconfirmed cast from java.net.Socket to javax.net.ssl.SSLSocket in org.apache.tomcat.util.net.jsse.JSSEImplementation.getSSLSupport(Socket)  At JSSEImplementation.java:[line 59]
M D ICAST: Integral division result cast to double or float in org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor.sendMessage(Member[], ChannelMessage, InterceptorPayload)  At ThroughputInterceptor.java:[line 77]
M D ICAST: Integral division result cast to double or float in org.apache.catalina.tribes.group.interceptors.ThroughputInterceptor.report(double)  At ThroughputInterceptor.java:[line 100]
H I Dm: Found reliance on default encoding in org.apache.catalina.ssi.SSIExec.process(SSIMediator, String, String[], String[], PrintWriter): new java.io.InputStreamReader(InputStream)  At SSIExec.java:[line 62]
M V EI2: compressionFilters.CompressionResponseStream.setCompressionMimeTypes(String[]) may expose internal representation by storing an externally mutable object into CompressionResponseStream.compressionMimeTypes  At CompressionResponseStream.java:[line 145]
M B RC: Suspicious comparison of Boolean references in async.Async0.service(HttpServletRequest, HttpServletResponse)  At Async0.java:[line 38]
M D SF: Switch statement found in jsp2.examples.simpletag.ShuffleSimpleTag.doTag() where default case is missing  At ShuffleSimpleTag.java:[lines 42-71]
M D REC: Exception is caught when Exception is not thrown in org.apache.catalina.ant.AbstractCatalinaTask.execute(String, InputStream, String, long)  At AbstractCatalinaTask.java:[line 287]
M B Nm: The class name org.apache.naming.java.javaURLContextFactory doesn't start with an upper case letter  At javaURLContextFactory.java:[lines 50-117]
M D NP: Load of known null value in javax.servlet.jsp.el.ScopedAttributeELResolver.getValue(ELContext, Object, Object)  At ScopedAttributeELResolver.java:[line 51]
M D NP: Load of known null value in javax.servlet.jsp.el.ScopedAttributeELResolver.getType(ELContext, Object, Object)  At ScopedAttributeELResolver.java:[line 96]
M D NP: Load of known null value in javax.servlet.jsp.el.ScopedAttributeELResolver.setValue(ELContext, Object, Object, Object)  At ScopedAttributeELResolver.java:[line 111]
M D NP: Load of known null value in javax.servlet.jsp.el.ScopedAttributeELResolver.isReadOnly(ELContext, Object, Object)  At ScopedAttributeELResolver.java:[line 133]
M P Bx: org.apache.taglibs.standard.tag.common.sql.UpdateTagSupport.doEndTag() invokes inefficient new Integer(int) constructor; use Integer.valueOf(int) instead  At UpdateTagSupport.java:[line 173]
M B Se: The field org.apache.jasper.servlet.JspServlet.options is transient but isn't set by deserialization  In JspServlet.java
M V EI2: new org.apache.el.MethodExpressionImpl(String, Node, FunctionMapper, VariableMapper, Class, Class[]) may expose internal representation by storing an externally mutable object into MethodExpressionImpl.paramTypes  At MethodExpressionImpl.java:[line 104]
M D REC: Exception is caught when Exception is not thrown in org.apache.catalina.ant.jmx.JMXAccessorConditionBase.accessJMXValue()  At JMXAccessorConditionBase.java:[line 175]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.TryStatement.generateCode(BlockScope, CodeStream) where one case falls through to the next case  At TryStatement.java:[lines 711-714]
M D SF: Switch statement found in org.eclipse.jdt.internal.compiler.ast.TryStatement.generateCode(BlockScope, CodeStream) where default case is missing  At TryStatement.java:[lines 630-648]
M S SQL: A prepared statement is generated from a nonconstant String in org.apache.catalina.session.JDBCStore.load(String)   At JDBCStore.java:[line 597]
M S SQL: A prepared statement is generated from a nonconstant String in org.apache.catalina.session.JDBCStore.save(Session)   At JDBCStore.java:[line 798]
M P SIC: Should org.apache.tomcat.jdbc.pool.interceptor.StatementDecoratorInterceptor$ResultSetProxy be a _static_ inner class?  At StatementDecoratorInterceptor.java:[lines 287-304]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.parser.Scanner.scanningFloatLiteral  At Scanner.java:[line 72]
M D UrF: Unread public/protected field: org.apache.taglibs.standard.tlv.JstlBaseTLV.failed  At JstlBaseTLV.java:[line 253]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.parser.Scanner.insideRecovery  At Scanner.java:[line 195]
M P SIC: Should org.apache.catalina.valves.ExtendedAccessLogValve$RequestAttributeElement be a _static_ inner class?  At ExtendedAccessLogValve.java:[lines 357-365]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.CompilationResult.hasAnnotations  At CompilationResult.java:[line 67]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.modifiersSourceStart  In AbstractMethodDeclaration.java
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.ast.JavadocAllocationExpression.tagSourceStart  In JavadocAllocationExpression.java
M D UuF: Unused public or protected field: org.apache.tomcat.jni.Sockaddr.pool  In Sockaddr.java
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.atime  In FileInfo.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ClassFile.isNestedType  At ClassFile.java:[line 276]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.ast.JavadocAllocationExpression.tagSourceEnd  In JavadocAllocationExpression.java
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.filetype  In FileInfo.java
M P SIC: Should org.apache.catalina.valves.ExtendedAccessLogValve$RequestHeaderElement be a _static_ inner class?  At ExtendedAccessLogValve.java:[lines 264-271]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.SwitchStatement.explicitDeclarations  At Parser.java:[line 8600]
M P SIC: Should org.apache.catalina.valves.ExtendedAccessLogValve$CookieElement be a _static_ inner class?  At ExtendedAccessLogValve.java:[lines 305-317]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.group  In FileInfo.java
M P SIC: Should org.eclipse.jdt.internal.compiler.ast.FunctionalExpression$VisibilityInspector be a _static_ inner class?  At FunctionalExpression.java:[lines 217-257]
M P SS: Unread field: org.apache.naming.factory.SendMailFactory.DataSourceClassName; should this field be static?  At SendMailFactory.java:[line 79]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.codegen.AnnotationContext.wildcard  At TypeReference.java:[line 161]
M P SIC: Should org.apache.jasper.xmlparser.XMLEncodingDetector$RewindableInputStream be a _static_ inner class?  At XMLEncodingDetector.java:[lines 1025-1157]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.mtime  In FileInfo.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.parser.RecoveredMethod.discardBody  At RecoveredMethod.java:[line 58]
M P SS: Unread field: compressionFilters.CompressionFilter.minBuffer; should this field be static?  At CompressionFilter.java:[line 63]
M P SS: Unread field: org.apache.jasper.compiler.PageInfo.defaultLanguage; should this field be static?  At PageInfo.java:[line 52]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.csize  In FileInfo.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall.typeArgumentsSourceStart  At Parser.java:[line 4116]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.localIndex  In StackMapFrame.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.CompilationResult.totalUnitsKnown  At CompilationResult.java:[line 92]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.tool.EclipseCompiler.diagnosticListener  At EclipseCompiler.java:[line 79]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.pool  In FileInfo.java
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.batch.Main.lineCount0  In Main.java
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.size  In FileInfo.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.ImportReference.declarationEnd  At RecoveredImport.java:[line 54]
M P SIC: Should org.eclipse.jdt.internal.compiler.ast.AllocationExpression$ResolutionState be a _static_ inner class?  At AllocationExpression.java:[lines 94-102]
M D UrF: Unread public/protected field: org.apache.el.parser.ELParserTokenManager.debugStream  At ELParserTokenManager.java:[line 13]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.fname  In FileInfo.java
M D UuF: Unused public or protected field: org.apache.tomcat.jni.Sockaddr.servname  In Sockaddr.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.CompilationResult.qualifiedReferences  At CompilationUnitScope.java:[line 785]
M P SIC: Should org.apache.tomcat.util.net.SecureNio2Channel$GatherState be a _static_ inner class?  At SecureNio2Channel.java:[lines 871-881]
M P SIC: Should org.apache.catalina.valves.ExtendedAccessLogValve$RequestParameterElement be a _static_ inner class?  At ExtendedAccessLogValve.java:[lines 390-412]
M P UrF: Unread field: org.apache.el.parser.ELParserTokenManager.jjimageLen  At ELParserTokenManager.java:[line 1999]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.protection  In FileInfo.java
M P SIC: Should org.eclipse.jdt.internal.compiler.lookup.Scope$MethodClashException be a _static_ inner class?  At Scope.java:[line 2324]
M P SIC: Should org.apache.tomcat.util.net.AprEndpoint$SocketTimeouts be a _static_ inner class?  At AprEndpoint.java:[lines 1159-1205]
M P SS: Unread field: org.apache.taglibs.standard.tlv.JstlBaseTLV.JSP; should this field be static?  At JstlBaseTLV.java:[line 80]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferredReturnType  At AllocationExpression.java:[line 585]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.lookup.ProblemBinding.searchType  At ProblemBinding.java:[line 35]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.Sockaddr.next  In Sockaddr.java
M P UrF: Unread field: org.apache.el.parser.ELParserTokenManager.lengthOfMatch  At ELParserTokenManager.java:[line 2085]
M P SS: Unread field: org.apache.tomcat.util.buf.UEncoder.ENCODING; should this field be static?  At UEncoder.java:[line 60]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.CompilationResult.checkSecondaryTypes  At CompilationResult.java:[line 78]
M P UrF: Unread field: org.eclipse.jdt.internal.compiler.ast.TypeReference$AnnotationCollector.annotationsOnDimensions  At TypeReference.java:[line 144]
M P UrF: Unread field: org.eclipse.jdt.internal.compiler.ast.TypeReference$AnnotationCollector.dimensions  At TypeReference.java:[line 150]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.tagBits  In StackMapFrame.java
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend.tagSourceStart  In JavadocMessageSend.java
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.nlink  In FileInfo.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.parser.AbstractCommentParser.complianceLevel  At AbstractCommentParser.java:[line 116]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.endPart1Position  At Parser.java:[line 12432]
M P UrF: Unread field: org.eclipse.jdt.internal.compiler.lookup.InferenceContext18$Solution.resolvedType  At InferenceContext18.java:[line 226]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.ctime  In FileInfo.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.endPart2Position  At Parser.java:[line 12433]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.inode  In FileInfo.java
M D UrF: Unread public/protected field: org.apache.tomcat.jdbc.pool.MultiLockFairBlockingQueue$ItemFuture.canceled  At MultiLockFairBlockingQueue.java:[line 439]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.codegen.CodeStream.preserveUnusedLocals  At CodeStream.java:[line 6690]
M P SS: Unread field: org.apache.catalina.connector.InputBuffer.INITIAL_STATE; should this field be static?  At InputBuffer.java:[line 65]
M P SS: Unread field: org.apache.catalina.valves.CometConnectionManagerValve.cometRequestsAttribute; should this field be static?  At CometConnectionManagerValve.java:[line 74]
M P SIC: Should org.apache.commons.daemon.support.DaemonWrapper$Invoker be a _static_ inner class?  At DaemonWrapper.java:[lines 189-270]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.ast.JavadocArrayQualifiedTypeReference.tagSourceEnd  In JavadocArrayQualifiedTypeReference.java
M P SIC: Should org.apache.catalina.valves.ExtendedAccessLogValve$ResponseAllHeaderElement be a _static_ inner class?  At ExtendedAccessLogValve.java:[lines 326-351]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.valid  In FileInfo.java
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.lookup.MethodScope.isPropagatingInnerClassEmulation  In MethodScope.java
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.device  In FileInfo.java
M D UrF: Unread public/protected field: org.apache.tomcat.jdbc.pool.FairBlockingQueue$ItemFuture.canceled  At FairBlockingQueue.java:[line 442]
M P SS: Unread field: org.apache.catalina.connector.InputBuffer.CHAR_STATE; should this field be static?  At InputBuffer.java:[line 66]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.Sockaddr.hostname  In Sockaddr.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.CompilationResult.simpleNameReferences  At CompilationUnitScope.java:[line 791]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.ast.JavadocArrayQualifiedTypeReference.tagSourceStart  In JavadocArrayQualifiedTypeReference.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.IntLiteral.value  At IntLiteral.java:[line 63]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference.tagSourceStart  At JavadocParser.java:[line 193]
M P SS: Unread field: org.apache.catalina.connector.InputBuffer.BYTE_STATE; should this field be static?  At InputBuffer.java:[line 67]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.parser.TypeConverter.problemReporter  At TypeConverter.java:[line 43]
M P SIC: Should org.apache.catalina.valves.ExtendedAccessLogValve$SessionAttributeElement be a _static_ inner class?  At ExtendedAccessLogValve.java:[lines 371-384]
M P SS: Unread field: compressionFilters.CompressionFilter.minThreshold; should this field be static?  At CompressionFilter.java:[line 53]
M P UrF: Unread field: org.apache.tomcat.jdbc.pool.interceptor.StatementCache$CachedStatement.cached  At StatementCache.java:[line 227]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.CoverageTestId  In UnconditionalFlowInfo.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference.tagSourceEnd  At JavadocParser.java:[line 194]
M P SS: Unread field: org.apache.juli.AsyncFileHandler$LoggerThread.run; should this field be static?  At AsyncFileHandler.java:[line 135]
M P SIC: Should org.apache.catalina.valves.ExtendedAccessLogValve$ResponseHeaderElement be a _static_ inner class?  At ExtendedAccessLogValve.java:[lines 277-285]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall.implicitArguments  In ExplicitConstructorCall.java
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.name  In FileInfo.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.impl.CompilerOptions.intendedDefaultNonNullness  At CompilerOptions.java:[line 1333]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.CompilationResult.unitIndex  At CompilationResult.java:[line 91]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.comments  In CompilationUnitDeclaration.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.JavadocSingleTypeReference.packageBinding  At JavadocSingleTypeReference.java:[line 69]
M P SIC: Should websocket.drawboard.Room$Player be a _static_ inner class?  At Room.java:[lines 407-488]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.CompilationResult.hasInconsistentToplevelHierarchies  At CompilationResult.java:[line 75]
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.filehand  In FileInfo.java
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.parser.AbstractCommentParser.javadocTextStart  At AbstractCommentParser.java:[line 171]
M P UrF: Unread field: org.eclipse.jdt.internal.compiler.lookup.InferenceContext18$Solution.method  At InferenceContext18.java:[line 225]
M P SIC: Should org.apache.catalina.valves.ExtendedAccessLogValve$ServletContextElement be a _static_ inner class?  At ExtendedAccessLogValve.java:[lines 291-299]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.LambdaExpression.hasParentheses  At Parser.java:[line 7962]
M D UuF: Unused public or protected field: org.eclipse.jdt.internal.compiler.ast.JavadocMessageSend.tagSourceEnd  In JavadocMessageSend.java
M D UuF: Unused public or protected field: org.apache.tomcat.jni.FileInfo.user  In FileInfo.java
M P SIC: Should org.apache.tomcat.util.net.AprEndpoint$SocketList be a _static_ inner class?  At AprEndpoint.java:[lines 1221-1289]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.ast.JavadocQualifiedTypeReference.packageBinding  At JavadocQualifiedTypeReference.java:[line 54]
M P SS: Unread field: org.apache.catalina.session.JDBCStore.threadName; should this field be static?  At JDBCStore.java:[line 70]
M D UrF: Unread public/protected field: org.eclipse.jdt.internal.compiler.CompilationResult.rootReferences  At CompilationUnitScope.java:[line 797]
M C MF: Field NotificationInfo.info masks field in superclass org.apache.tomcat.util.modeler.FeatureInfo  In NotificationInfo.java
M V MS: org.eclipse.jdt.internal.compiler.util.SuffixConstants.SUFFIX_class is a mutable array  At SuffixConstants.java:[line 24]
M V MS: org.eclipse.jdt.internal.compiler.util.SuffixConstants.SUFFIX_CLASS is a mutable array  At SuffixConstants.java:[line 25]
M V MS: org.eclipse.jdt.internal.compiler.util.SuffixConstants.SUFFIX_java is a mutable array  At SuffixConstants.java:[line 26]
M V MS: org.eclipse.jdt.internal.compiler.util.SuffixConstants.SUFFIX_JAVA should be moved out of an interface and made package protected  At SuffixConstants.java:[line 27]
M V MS: org.apache.tomcat.jdbc.pool.interceptor.AbstractCreateStatementInterceptor.STATEMENT_TYPES should be package protected  At AbstractCreateStatementInterceptor.java:[line 39]
M V MS: org.apache.tomcat.jdbc.pool.interceptor.AbstractCreateStatementInterceptor.EXECUTE_TYPES should be package protected  At AbstractCreateStatementInterceptor.java:[line 47]
M V MS: org.apache.el.parser.ELParserConstants.tokenImage should be moved out of an interface and made package protected  At ELParserConstants.java:[line 136]
M V MS: org.apache.tomcat.jni.Library.TCN_MAJOR_VERSION isn't final and can't be protected from malicious code   At Library.java:[line 99]
M V MS: org.apache.tomcat.jni.Library.TCN_MINOR_VERSION isn't final and can't be protected from malicious code   At Library.java:[line 101]
M V MS: org.apache.tomcat.jni.Library.TCN_PATCH_VERSION isn't final and can't be protected from malicious code   At Library.java:[line 103]
M V MS: org.apache.tomcat.jni.Library.APR_MAJOR_VERSION isn't final and can't be protected from malicious code   At Library.java:[line 107]
M V MS: org.apache.tomcat.jni.Library.APR_MINOR_VERSION isn't final and can't be protected from malicious code   At Library.java:[line 109]
M V MS: org.apache.tomcat.jni.Library.APR_PATCH_VERSION isn't final and can't be protected from malicious code   At Library.java:[line 111]
M V MS: org.apache.tomcat.jni.Library.APR_HAVE_IPV6 isn't final and can't be protected from malicious code   At Library.java:[line 121]
M V MS: org.apache.tomcat.jni.Library.APR_HAS_THREADS should be package protected  At Library.java:[line 123]
M V MS: org.apache.tomcat.jni.Library.APR_HAS_SENDFILE isn't final and can't be protected from malicious code   At Library.java:[line 124]
M V MS: org.apache.tomcat.jni.Library.APR_HAS_RANDOM isn't final and can't be protected from malicious code   At Library.java:[line 127]
M V MS: org.apache.tomcat.jni.Library.APR_HAS_SO_ACCEPTFILTER isn't final and can't be protected from malicious code   At Library.java:[line 130]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.SyntheticName is a mutable array  At AttributeNamesConstants.java:[line 19]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.ConstantValueName is a mutable array  At AttributeNamesConstants.java:[line 20]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.LineNumberTableName is a mutable array  At AttributeNamesConstants.java:[line 21]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.LocalVariableTableName is a mutable array  At AttributeNamesConstants.java:[line 22]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.InnerClassName is a mutable array  At AttributeNamesConstants.java:[line 23]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.CodeName is a mutable array  At AttributeNamesConstants.java:[line 24]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.ExceptionsName is a mutable array  At AttributeNamesConstants.java:[line 25]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.SourceName is a mutable array  At AttributeNamesConstants.java:[line 26]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.DeprecatedName is a mutable array  At AttributeNamesConstants.java:[line 27]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.SignatureName is a mutable array  At AttributeNamesConstants.java:[line 28]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.LocalVariableTypeTableName is a mutable array  At AttributeNamesConstants.java:[line 29]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.EnclosingMethodName is a mutable array  At AttributeNamesConstants.java:[line 30]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.AnnotationDefaultName is a mutable array  At AttributeNamesConstants.java:[line 31]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.RuntimeInvisibleAnnotationsName is a mutable array  At AttributeNamesConstants.java:[line 32]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.RuntimeVisibleAnnotationsName is a mutable array  At AttributeNamesConstants.java:[line 33]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.RuntimeInvisibleParameterAnnotationsName is a mutable array  At AttributeNamesConstants.java:[line 34]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.RuntimeVisibleParameterAnnotationsName is a mutable array  At AttributeNamesConstants.java:[line 35]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.StackMapTableName is a mutable array  At AttributeNamesConstants.java:[line 36]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.InconsistentHierarchy is a mutable array  At AttributeNamesConstants.java:[line 37]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.VarargsName is a mutable array  At AttributeNamesConstants.java:[line 38]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.StackMapName is a mutable array  At AttributeNamesConstants.java:[line 39]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.MissingTypesName is a mutable array  At AttributeNamesConstants.java:[line 40]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.BootstrapMethodsName is a mutable array  At AttributeNamesConstants.java:[line 41]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.RuntimeVisibleTypeAnnotationsName is a mutable array  At AttributeNamesConstants.java:[line 43]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.RuntimeInvisibleTypeAnnotationsName is a mutable array  At AttributeNamesConstants.java:[line 44]
M V MS: org.eclipse.jdt.internal.compiler.codegen.AttributeNamesConstants.MethodParametersName is a mutable array  At AttributeNamesConstants.java:[line 46]
H V MS: org.eclipse.jdt.internal.compiler.lookup.Binding.ANY_EXCEPTION is a mutable array  At Binding.java:[line 51]
H V MS: org.apache.tomcat.util.net.Nio2Channel.emptyBuf isn't final but should be  At Nio2Channel.java:[line 38]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_DEPRECATED should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 24]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_PARAM should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 25]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_RETURN is a mutable array  At JavadocTagConstants.java:[line 26]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_THROWS should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 27]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_EXCEPTION should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 28]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_SEE should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 29]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_LINK should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 30]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_LINKPLAIN should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 31]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_INHERITDOC should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 32]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_VALUE should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 33]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_AUTHOR should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 34]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_CODE should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 35]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_DOC_ROOT should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 36]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_LITERAL should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 37]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_SERIAL should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 38]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_SERIAL_DATA should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 39]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_SERIAL_FIELD should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 40]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_SINCE should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 41]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_VERSION should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 42]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_CATEGORY should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 43]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.TAG_NAMES should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 92]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.HREF_TAG should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 129]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.BLOCK_TAGS should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 133]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.INLINE_TAGS should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 153]
M V MS: org.eclipse.jdt.internal.compiler.parser.JavadocTagConstants.JAVADOC_TAG_TYPE should be moved out of an interface and made package protected  At JavadocTagConstants.java:[line 181]
M V MS: org.apache.coyote.http11.Constants.SERVER_BYTES should be package protected  At Constants.java:[line 54]
M V MS: org.apache.coyote.http11.Constants.CLOSE_BYTES should be package protected  At Constants.java:[line 127]
M V MS: org.apache.coyote.http11.Constants.KEEPALIVE_BYTES should be package protected  At Constants.java:[line 130]
M V MS: org.apache.coyote.http11.Constants.ACK_BYTES should be package protected  At Constants.java:[line 133]
M V MS: org.apache.coyote.http11.Constants._200_BYTES should be package protected  At Constants.java:[line 136]
M V MS: org.apache.coyote.http11.Constants._400_BYTES should be package protected  At Constants.java:[line 138]
M V MS: org.apache.coyote.http11.Constants._404_BYTES should be package protected  At Constants.java:[line 140]
M V MS: org.apache.coyote.http11.Constants.HTTP_11_BYTES should be package protected  At Constants.java:[line 184]
M V MS: org.apache.catalina.util.Strftime.translate is a mutable collection which should be package protected  At Strftime.java:[line 52]
H V MS: org.apache.tomcat.util.net.NioChannel.emptyBuf isn't final but should be  At NioChannel.java:[line 43]
M V MS: org.apache.el.parser.ELParserTreeConstants.jjtNodeName should be moved out of an interface and made package protected  At ELParserTreeConstants.java:[line 51]
H V MS: org.apache.tomcat.util.bcel.Constants.CONSTANT_NAMES is a mutable array  At Constants.java:[line 90]
M V MS: org.eclipse.jdt.internal.compiler.lookup.BaseTypeBinding.CONVERSIONS should be package protected  At BaseTypeBinding.java:[line 28]
M V MS: org.apache.tomcat.dbcp.dbcp2.Utils.DISCONNECTION_SQL_CODES is a mutable collection which should be package protected  At Utils.java:[line 58]
M V MS: org.apache.catalina.tribes.Member.SHUTDOWN_PAYLOAD is a mutable array  At Member.java:[line 36]
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_unresolvedProblem isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_unresolvedProblems isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_request isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_loadBinary isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_process isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_write isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_done isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_units isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_unit isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_internalError isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_beginningToCompile isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.compilation_processing isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.output_isFile isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.output_notValidAll isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.output_notValid isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.problem_noSourceInformation isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.problem_atLine isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.abort_invalidAttribute isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.abort_invalidExceptionAttribute isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.abort_invalidOpcode isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.abort_missingCode isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.abort_againstSourceModel isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_incorrectPath isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_moveFiles isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_syntaxRecovery isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_regularParse isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_missingFile isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_corruptedFile isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_endOfFile isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_endOfConstructor isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_endOfMethod isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.parser_endOfInitializer isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.ast_missingCode isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.constant_cannotCastedInto isn't final but should be  In Messages.java
H V MS: org.eclipse.jdt.internal.compiler.util.Messages.constant_cannotConvertedTo isn't final but should be  In Messages.java
M V MS: org.apache.el.parser.ELParserTokenManager.jjstrLiteralImages should be package protected  At ELParserTokenManager.java:[line 1865]
M V MS: org.apache.el.parser.ELParserTokenManager.jjnewLexState should be package protected  At ELParserTokenManager.java:[line 1883]
M V MS: org.apache.tomcat.util.http.fileupload.MultipartStream.HEADER_SEPARATOR should be package protected  At MultipartStream.java:[line 186]
M V MS: org.apache.tomcat.util.http.fileupload.MultipartStream.FIELD_SEPARATOR should be package protected  At MultipartStream.java:[line 192]
M V MS: org.apache.tomcat.util.http.fileupload.MultipartStream.STREAM_TERMINATOR should be package protected  At MultipartStream.java:[line 198]
M V MS: org.apache.tomcat.util.http.fileupload.MultipartStream.BOUNDARY_PREFIX should be package protected  At MultipartStream.java:[line 203]
M V MS: org.eclipse.jdt.internal.compiler.impl.CompilerOptions.tolerateIllegalAmbiguousVarargsInvocation isn't final and can't be protected from malicious code   In CompilerOptions.java
M V MS: org.eclipse.jdt.internal.compiler.ast.OperatorExpression.OperatorSignatures should be both final and package protected  At OperatorExpression.java:[line 20]
M V MS: org.apache.catalina.session.StandardSession.excludedAttributes should be package protected  At StandardSession.java:[line 168]
H V MS: org.apache.tomcat.jdbc.pool.PoolProperties.poolCounter isn't final but should be  At PoolProperties.java:[line 40]
M V MS: org.apache.catalina.tribes.membership.MemberImpl.TRIBES_MBR_BEGIN should be package protected  At MemberImpl.java:[line 44]
M V MS: org.apache.catalina.tribes.membership.MemberImpl.TRIBES_MBR_END should be package protected  At MemberImpl.java:[line 45]
M V MS: org.apache.catalina.connector.Connector.replacements is a mutable collection which should be package protected  At Connector.java:[line 241]
M V MS: org.apache.tomcat.util.digester.Digester.source should be both final and package protected  At Digester.java:[line 85]
H V MS: org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.samProblemBinding isn't final but should be  At ReferenceBinding.java:[line 98]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Append should be package protected  At ConstantPool.java:[line 61]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ArrayCopy should be package protected  At ConstantPool.java:[line 64]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ArrayCopySignature should be package protected  At ConstantPool.java:[line 65]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.booleanBooleanSignature should be package protected  At ConstantPool.java:[line 68]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.BooleanConstrSignature should be package protected  At ConstantPool.java:[line 69]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.BOOLEANVALUE_BOOLEAN_METHOD_NAME should be package protected  At ConstantPool.java:[line 70]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.BOOLEANVALUE_BOOLEAN_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 71]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.byteByteSignature should be package protected  At ConstantPool.java:[line 72]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ByteConstrSignature should be package protected  At ConstantPool.java:[line 73]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.BYTEVALUE_BYTE_METHOD_NAME should be package protected  At ConstantPool.java:[line 74]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.BYTEVALUE_BYTE_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 75]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.charCharacterSignature should be package protected  At ConstantPool.java:[line 76]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.CharConstrSignature should be package protected  At ConstantPool.java:[line 77]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.CHARVALUE_CHARACTER_METHOD_NAME should be package protected  At ConstantPool.java:[line 78]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.CHARVALUE_CHARACTER_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 79]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Clinit is a mutable array  At ConstantPool.java:[line 80]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.DefaultConstructorSignature should be package protected  At ConstantPool.java:[line 81]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ClinitSignature is a mutable array  At ConstantPool.java:[line 82]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Close is a mutable array  At ConstantPool.java:[line 83]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.CloseSignature should be package protected  At ConstantPool.java:[line 84]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.DesiredAssertionStatus should be package protected  At ConstantPool.java:[line 85]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.DesiredAssertionStatusSignature should be package protected  At ConstantPool.java:[line 86]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.DoubleConstrSignature should be package protected  At ConstantPool.java:[line 87]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.doubleDoubleSignature should be package protected  At ConstantPool.java:[line 88]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.DOUBLEVALUE_DOUBLE_METHOD_NAME should be package protected  At ConstantPool.java:[line 89]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.DOUBLEVALUE_DOUBLE_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 90]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.EnumName is a mutable array  At ConstantPool.java:[line 91]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.EnumOrdinal is a mutable array  At ConstantPool.java:[line 92]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.FloatConstrSignature should be package protected  At ConstantPool.java:[line 95]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.floatFloatSignature should be package protected  At ConstantPool.java:[line 96]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.FLOATVALUE_FLOAT_METHOD_NAME should be package protected  At ConstantPool.java:[line 97]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.FLOATVALUE_FLOAT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 98]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ForName should be package protected  At ConstantPool.java:[line 99]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ForNameSignature should be package protected  At ConstantPool.java:[line 100]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_BOOLEAN_METHOD_NAME should be package protected  At ConstantPool.java:[line 101]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_BOOLEAN_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 102]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_BYTE_METHOD_NAME should be package protected  At ConstantPool.java:[line 103]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_BYTE_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 104]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_CHAR_METHOD_NAME should be package protected  At ConstantPool.java:[line 105]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_CHAR_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 106]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_DOUBLE_METHOD_NAME should be package protected  At ConstantPool.java:[line 107]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_DOUBLE_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 108]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_FLOAT_METHOD_NAME should be package protected  At ConstantPool.java:[line 109]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_FLOAT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 110]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_INT_METHOD_NAME should be package protected  At ConstantPool.java:[line 111]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_INT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 112]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_LONG_METHOD_NAME should be package protected  At ConstantPool.java:[line 113]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_LONG_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 114]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_OBJECT_METHOD_NAME should be package protected  At ConstantPool.java:[line 115]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_OBJECT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 116]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_SHORT_METHOD_NAME should be package protected  At ConstantPool.java:[line 117]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GET_SHORT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 118]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetClass should be package protected  At ConstantPool.java:[line 119]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetClassSignature should be package protected  At ConstantPool.java:[line 120]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GETDECLAREDCONSTRUCTOR_NAME should be package protected  At ConstantPool.java:[line 125]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GETDECLAREDCONSTRUCTOR_SIGNATURE should be package protected  At ConstantPool.java:[line 126]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GETDECLAREDFIELD_NAME should be package protected  At ConstantPool.java:[line 128]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GETDECLAREDFIELD_SIGNATURE should be package protected  At ConstantPool.java:[line 129]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GETDECLAREDMETHOD_NAME should be package protected  At ConstantPool.java:[line 130]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GETDECLAREDMETHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 131]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetMessage should be package protected  At ConstantPool.java:[line 132]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetMessageSignature should be package protected  At ConstantPool.java:[line 133]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.HasNext should be package protected  At ConstantPool.java:[line 134]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.HasNextSignature should be package protected  At ConstantPool.java:[line 135]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Init is a mutable array  At ConstantPool.java:[line 136]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.IntConstrSignature should be package protected  At ConstantPool.java:[line 137]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ITERATOR_NAME should be package protected  At ConstantPool.java:[line 138]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ITERATOR_SIGNATURE should be package protected  At ConstantPool.java:[line 139]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Intern should be package protected  At ConstantPool.java:[line 140]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.InternSignature should be package protected  At ConstantPool.java:[line 141]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.IntIntegerSignature should be package protected  At ConstantPool.java:[line 142]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.INTVALUE_INTEGER_METHOD_NAME should be package protected  At ConstantPool.java:[line 143]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.INTVALUE_INTEGER_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 144]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.INVOKE_METHOD_METHOD_NAME should be package protected  At ConstantPool.java:[line 145]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.INVOKE_METHOD_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 146]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.IllegalArgumentExceptionConstructorSignature should be package protected  At ConstantPool.java:[line 149]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangAssertionErrorConstantPoolName should be package protected  At ConstantPool.java:[line 152]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangBooleanConstantPoolName should be package protected  At ConstantPool.java:[line 153]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangByteConstantPoolName should be package protected  At ConstantPool.java:[line 154]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangCharacterConstantPoolName should be package protected  At ConstantPool.java:[line 155]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangClassConstantPoolName is a mutable array  At ConstantPool.java:[line 156]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangClassNotFoundExceptionConstantPoolName is a mutable array  At ConstantPool.java:[line 157]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangClassSignature should be package protected  At ConstantPool.java:[line 158]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangDoubleConstantPoolName should be package protected  At ConstantPool.java:[line 159]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangEnumConstantPoolName should be package protected  At ConstantPool.java:[line 160]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangErrorConstantPoolName should be package protected  At ConstantPool.java:[line 161]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangFloatConstantPoolName should be package protected  At ConstantPool.java:[line 163]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangIntegerConstantPoolName should be package protected  At ConstantPool.java:[line 164]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangLongConstantPoolName should be package protected  At ConstantPool.java:[line 165]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangNoClassDefFoundErrorConstantPoolName should be package protected  At ConstantPool.java:[line 166]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangNoSuchFieldErrorConstantPoolName is a mutable array  At ConstantPool.java:[line 167]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangObjectConstantPoolName is a mutable array  At ConstantPool.java:[line 168]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVALANGREFLECTACCESSIBLEOBJECT_CONSTANTPOOLNAME should be package protected  At ConstantPool.java:[line 169]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVALANGREFLECTARRAY_CONSTANTPOOLNAME should be package protected  At ConstantPool.java:[line 170]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangReflectConstructorConstantPoolName should be package protected  At ConstantPool.java:[line 171]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangReflectConstructorNewInstanceSignature should be package protected  At ConstantPool.java:[line 172]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVALANGREFLECTFIELD_CONSTANTPOOLNAME should be package protected  At ConstantPool.java:[line 173]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVALANGREFLECTMETHOD_CONSTANTPOOLNAME should be package protected  At ConstantPool.java:[line 174]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangShortConstantPoolName should be package protected  At ConstantPool.java:[line 175]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangStringBufferConstantPoolName should be package protected  At ConstantPool.java:[line 176]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangStringBuilderConstantPoolName should be package protected  At ConstantPool.java:[line 177]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangStringConstantPoolName is a mutable array  At ConstantPool.java:[line 178]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangStringSignature is a mutable array  At ConstantPool.java:[line 179]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangSystemConstantPoolName should be package protected  At ConstantPool.java:[line 181]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangThrowableConstantPoolName should be package protected  At ConstantPool.java:[line 182]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangIllegalArgumentExceptionConstantPoolName should be package protected  At ConstantPool.java:[line 183]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangVoidConstantPoolName should be package protected  At ConstantPool.java:[line 184]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaUtilIteratorConstantPoolName should be package protected  At ConstantPool.java:[line 185]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.LongConstrSignature should be package protected  At ConstantPool.java:[line 186]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.longLongSignature should be package protected  At ConstantPool.java:[line 187]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.LONGVALUE_LONG_METHOD_NAME should be package protected  At ConstantPool.java:[line 188]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.LONGVALUE_LONG_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 189]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Name is a mutable array  At ConstantPool.java:[line 190]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.NewInstance should be package protected  At ConstantPool.java:[line 191]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.NewInstanceSignature should be package protected  At ConstantPool.java:[line 192]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Next should be package protected  At ConstantPool.java:[line 193]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.NextSignature should be package protected  At ConstantPool.java:[line 194]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ObjectConstrSignature should be package protected  At ConstantPool.java:[line 195]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Ordinal should be package protected  At ConstantPool.java:[line 197]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.OrdinalSignature should be package protected  At ConstantPool.java:[line 198]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_BOOLEAN_METHOD_NAME should be package protected  At ConstantPool.java:[line 200]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_BOOLEAN_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 201]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_BYTE_METHOD_NAME should be package protected  At ConstantPool.java:[line 202]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_BYTE_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 203]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_CHAR_METHOD_NAME should be package protected  At ConstantPool.java:[line 204]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_CHAR_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 205]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_DOUBLE_METHOD_NAME should be package protected  At ConstantPool.java:[line 206]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_DOUBLE_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 207]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_FLOAT_METHOD_NAME should be package protected  At ConstantPool.java:[line 208]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_FLOAT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 209]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_INT_METHOD_NAME should be package protected  At ConstantPool.java:[line 210]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_INT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 211]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_LONG_METHOD_NAME should be package protected  At ConstantPool.java:[line 212]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_LONG_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 213]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_OBJECT_METHOD_NAME should be package protected  At ConstantPool.java:[line 214]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_OBJECT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 215]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_SHORT_METHOD_NAME should be package protected  At ConstantPool.java:[line 216]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SET_SHORT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 217]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SETACCESSIBLE_NAME should be package protected  At ConstantPool.java:[line 218]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SETACCESSIBLE_SIGNATURE should be package protected  At ConstantPool.java:[line 219]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ShortConstrSignature should be package protected  At ConstantPool.java:[line 220]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.shortShortSignature should be package protected  At ConstantPool.java:[line 221]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SHORTVALUE_SHORT_METHOD_NAME should be package protected  At ConstantPool.java:[line 222]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.SHORTVALUE_SHORT_METHOD_SIGNATURE should be package protected  At ConstantPool.java:[line 223]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBufferAppendBooleanSignature should be package protected  At ConstantPool.java:[line 224]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBufferAppendCharSignature should be package protected  At ConstantPool.java:[line 225]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBufferAppendDoubleSignature should be package protected  At ConstantPool.java:[line 226]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBufferAppendFloatSignature should be package protected  At ConstantPool.java:[line 227]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBufferAppendIntSignature should be package protected  At ConstantPool.java:[line 228]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBufferAppendLongSignature should be package protected  At ConstantPool.java:[line 229]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBufferAppendObjectSignature should be package protected  At ConstantPool.java:[line 230]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBufferAppendStringSignature should be package protected  At ConstantPool.java:[line 231]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBuilderAppendBooleanSignature should be package protected  At ConstantPool.java:[line 232]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBuilderAppendCharSignature should be package protected  At ConstantPool.java:[line 233]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBuilderAppendDoubleSignature should be package protected  At ConstantPool.java:[line 234]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBuilderAppendFloatSignature should be package protected  At ConstantPool.java:[line 235]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBuilderAppendIntSignature should be package protected  At ConstantPool.java:[line 236]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBuilderAppendLongSignature should be package protected  At ConstantPool.java:[line 237]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBuilderAppendObjectSignature should be package protected  At ConstantPool.java:[line 238]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringBuilderAppendStringSignature should be package protected  At ConstantPool.java:[line 239]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.StringConstructorSignature should be package protected  At ConstantPool.java:[line 240]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.This is a mutable array  At ConstantPool.java:[line 241]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ToString should be package protected  At ConstantPool.java:[line 242]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ToStringSignature should be package protected  At ConstantPool.java:[line 243]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.TYPE should be package protected  At ConstantPool.java:[line 244]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ValueOf is a mutable array  At ConstantPool.java:[line 245]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ValueOfBooleanSignature should be package protected  At ConstantPool.java:[line 246]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ValueOfCharSignature should be package protected  At ConstantPool.java:[line 247]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ValueOfDoubleSignature should be package protected  At ConstantPool.java:[line 248]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ValueOfFloatSignature should be package protected  At ConstantPool.java:[line 249]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ValueOfIntSignature should be package protected  At ConstantPool.java:[line 250]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ValueOfLongSignature should be package protected  At ConstantPool.java:[line 251]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ValueOfObjectSignature should be package protected  At ConstantPool.java:[line 252]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ValueOfStringClassSignature should be package protected  At ConstantPool.java:[line 253]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_ANNOTATION_DOCUMENTED is a mutable array  At ConstantPool.java:[line 254]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_ANNOTATION_ELEMENTTYPE is a mutable array  At ConstantPool.java:[line 255]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_ANNOTATION_RETENTION is a mutable array  At ConstantPool.java:[line 256]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_ANNOTATION_RETENTIONPOLICY is a mutable array  At ConstantPool.java:[line 257]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_ANNOTATION_TARGET is a mutable array  At ConstantPool.java:[line 258]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_DEPRECATED is a mutable array  At ConstantPool.java:[line 259]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_ANNOTATION_INHERITED is a mutable array  At ConstantPool.java:[line 260]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_SAFEVARARGS is a mutable array  At ConstantPool.java:[line 262]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_INVOKE_METHODHANDLE_POLYMORPHICSIGNATURE is a mutable array  At ConstantPool.java:[line 264]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.METAFACTORY is a mutable array  At ConstantPool.java:[line 266]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_METAFACTORY_SIGNATURE is a mutable array  At ConstantPool.java:[line 267]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.ALTMETAFACTORY is a mutable array  At ConstantPool.java:[line 268]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_ALTMETAFACTORY_SIGNATURE is a mutable array  At ConstantPool.java:[line 269]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JavaLangInvokeSerializedLambdaConstantPoolName should be package protected  At ConstantPool.java:[line 272]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetImplMethodName should be package protected  At ConstantPool.java:[line 273]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetImplMethodNameSignature should be package protected  At ConstantPool.java:[line 274]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetImplMethodKind should be package protected  At ConstantPool.java:[line 275]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetImplMethodKindSignature should be package protected  At ConstantPool.java:[line 276]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetFunctionalInterfaceClass should be package protected  At ConstantPool.java:[line 277]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetFunctionalInterfaceClassSignature should be package protected  At ConstantPool.java:[line 278]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetFunctionalInterfaceMethodName should be package protected  At ConstantPool.java:[line 279]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetFunctionalInterfaceMethodNameSignature should be package protected  At ConstantPool.java:[line 280]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetFunctionalInterfaceMethodSignature should be package protected  At ConstantPool.java:[line 281]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetFunctionalInterfaceMethodSignatureSignature should be package protected  At ConstantPool.java:[line 282]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetImplClass should be package protected  At ConstantPool.java:[line 283]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetImplClassSignature should be package protected  At ConstantPool.java:[line 284]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetImplMethodSignature should be package protected  At ConstantPool.java:[line 285]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetImplMethodSignatureSignature should be package protected  At ConstantPool.java:[line 286]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetCapturedArg should be package protected  At ConstantPool.java:[line 287]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.GetCapturedArgSignature should be package protected  At ConstantPool.java:[line 288]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.JAVA_LANG_ANNOTATION_REPEATABLE is a mutable array  At ConstantPool.java:[line 290]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.HashCode should be package protected  At ConstantPool.java:[line 292]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.HashCodeSignature should be package protected  At ConstantPool.java:[line 293]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Equals should be package protected  At ConstantPool.java:[line 294]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.EqualsSignature should be package protected  At ConstantPool.java:[line 295]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.AddSuppressed should be package protected  At ConstantPool.java:[line 296]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.AddSuppressedSignature should be package protected  At ConstantPool.java:[line 297]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.Clone should be package protected  At ConstantPool.java:[line 298]
M V MS: org.eclipse.jdt.internal.compiler.codegen.ConstantPool.CloneSignature should be package protected  At ConstantPool.java:[line 299]
H V MS: org.eclipse.jdt.internal.compiler.ast.FakedTrackingVariable.TEST_372319 isn't final but should be  At FakedTrackingVariable.java:[line 77]
H V MS: org.eclipse.jdt.internal.compiler.ast.FunctionalExpression.silentErrorHandlingPolicy isn't final but should be  At FunctionalExpression.java:[line 66]
M V MS: org.apache.tomcat.jdbc.pool.DataSourceFactory.ALL_PROPERTIES should be package protected  At DataSourceFactory.java:[line 132]
M V MS: org.apache.catalina.core.StandardWrapper.DEFAULT_SERVLET_METHODS should be package protected  At StandardWrapper.java:[line 85]
M V MS: org.apache.catalina.core.StandardWrapper.classType should be both final and package protected  At StandardWrapper.java:[line 275]
H V MS: org.eclipse.jdt.internal.compiler.apt.model.Factory.EMPTY_ANNOTATION_MIRRORS isn't final but should be  At Factory.java:[line 75]
M V MS: org.eclipse.jdt.internal.compiler.problem.ProblemHandler.NoArgument should be package protected  At ProblemHandler.java:[line 36]
M V MS: org.eclipse.jdt.internal.compiler.parser.Scanner.TAG_PREFIX should be package protected  At Scanner.java:[line 162]
M V MS: org.eclipse.jdt.internal.compiler.parser.Scanner.IDENTITY_COMPARISON_TAG should be package protected  At Scanner.java:[line 168]
M V MS: org.eclipse.jdt.internal.compiler.parser.RecoveryScanner.FAKE_IDENTIFIER is a mutable array  At RecoveryScanner.java:[line 18]
M V MS: org.eclipse.jdt.internal.compiler.ast.CombinedBinaryExpression.defaultArityMaxStartingValue isn't final but should be  At CombinedBinaryExpression.java:[line 86]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.FALL_THROUGH_TAG should be package protected  At Parser.java:[line 162]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.CASES_OMITTED_TAG should be package protected  At Parser.java:[line 163]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.asb should be package protected  At Parser.java:[line 165]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.asr is a mutable array  At Parser.java:[line 166]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.base_action should be package protected  At Parser.java:[line 169]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.check_table should be package protected  At Parser.java:[line 172]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.in_symb should be package protected  At Parser.java:[line 184]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.lhs is a mutable array  At Scanner.java:[line 4252]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.name is a mutable array  At Scanner.java:[line 4252]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.nasb should be package protected  At Parser.java:[line 189]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.nasr is a mutable array  At Parser.java:[line 190]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.non_terminal_index is a mutable array  At Scanner.java:[line 4252]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.readableName is a mutable array  At Parser.java:[line 194]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.rhs is a mutable array  At Parser.java:[line 196]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.reverse_index is a mutable array  At Parser.java:[line 198]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.recovery_templates_index is a mutable array  At Parser.java:[line 199]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.recovery_templates is a mutable array  At Parser.java:[line 200]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.statements_recovery_filter should be package protected  At Parser.java:[line 201]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.rules_compliance is a mutable array  At Parser.java:[line 203]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.scope_la is a mutable array  At Parser.java:[line 207]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.scope_lhs is a mutable array  At Parser.java:[line 208]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.scope_prefix is a mutable array  At Parser.java:[line 210]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.scope_rhs is a mutable array  At Parser.java:[line 211]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.scope_state is a mutable array  At Parser.java:[line 212]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.scope_state_set is a mutable array  At Parser.java:[line 214]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.scope_suffix is a mutable array  At Parser.java:[line 215]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.term_action should be package protected  At Parser.java:[line 221]
M V MS: org.eclipse.jdt.internal.compiler.parser.Parser.term_check should be package protected  At Parser.java:[line 222]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.terminal_index is a mutable array  At Parser.java:[line 224]
H V MS: org.eclipse.jdt.internal.compiler.parser.Parser.VERBOSE_RECOVERY isn't final but should be  At Parser.java:[line 227]
H V MS: org.eclipse.jdt.internal.compiler.Compiler.DEBUG isn't final but should be  At Compiler.java:[line 48]
H V MS: org.eclipse.jdt.internal.compiler.Compiler.DebugRequestor isn't final but should be  At Compiler.java:[line 64]
H V MS: org.eclipse.jdt.internal.compiler.apt.util.Util.LINE_SEPARATOR isn't final but should be  At Util.java:[line 32]
M V MS: org.apache.coyote.ajp.AbstractAjpProcessor.endMessageArray should be package protected  At AbstractAjpProcessor.java:[line 97]
M V MS: org.apache.coyote.ajp.AbstractAjpProcessor.endAndCloseMessageArray should be package protected  At AbstractAjpProcessor.java:[line 107]
M V MS: org.apache.coyote.ajp.AbstractAjpProcessor.flushMessageArray should be package protected  At AbstractAjpProcessor.java:[line 118]
M V MS: org.apache.coyote.ajp.AbstractAjpProcessor.pongMessageArray should be package protected  At AbstractAjpProcessor.java:[line 127]
H V MS: org.eclipse.jdt.internal.compiler.tool.Util.LINE_SEPARATOR isn't final but should be  At Util.java:[line 32]
M V MS: org.apache.coyote.http11.AbstractInputBuffer.HTTP_TOKEN_CHAR should be package protected  At AbstractInputBuffer.java:[line 33]
M V MS: org.apache.tomcat.util.net.AprEndpoint.SSL_PROTO_ALL is a mutable collection which should be package protected  At AprEndpoint.java:[line 72]
M V MS: org.apache.el.util.ReflectionUtil.PRIMITIVE_NAMES should be package protected  At ReflectionUtil.java:[line 41]
M V MS: org.apache.el.util.ReflectionUtil.PRIMITIVES should be package protected  At ReflectionUtil.java:[line 44]
M V MS: org.apache.catalina.tribes.group.GroupChannel$HeartbeatThread.counter should be package protected  At GroupChannel.java:[line 671]
M V MS: org.apache.tomcat.jdbc.pool.interceptor.AbstractQueryReport.constructors should be package protected  At AbstractQueryReport.java:[line 49]
M V MS: org.apache.catalina.tribes.group.interceptors.TcpFailureDetector.TCP_FAIL_DETECT should be package protected  At TcpFailureDetector.java:[line 68]
M V MS: org.apache.catalina.servlets.DefaultServlet.FULL is a mutable collection which should be package protected  At DefaultServlet.java:[line 140]
M V MS: org.apache.tomcat.jdbc.pool.interceptor.StatementDecoratorInterceptor.constructors should be package protected  At StatementDecoratorInterceptor.java:[line 48]
M V MS: org.apache.tomcat.jdbc.pool.interceptor.StatementDecoratorInterceptor.resultSetConstructor should be package protected  At StatementDecoratorInterceptor.java:[line 53]
M V MS: org.apache.catalina.filters.CorsFilter.SIMPLE_HTTP_REQUEST_CONTENT_TYPE_VALUES is a mutable collection which should be package protected  At CorsFilter.java:[line 1141]
H V MS: org.apache.catalina.storeconfig.ConnectorStoreAppender.replacements isn't final but should be  At ConnectorStoreAppender.java:[line 44]
H V MS: org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReport.perPoolStats isn't final but should be  At SlowQueryReport.java:[line 51]
M V MS: org.apache.tomcat.jdbc.pool.interceptor.StatementCache.ALL_TYPES should be package protected  At StatementCache.java:[line 35]
M V MS: org.apache.tomcat.jdbc.pool.interceptor.StatementCache.CALLABLE_TYPE should be package protected  At StatementCache.java:[line 36]
M V MS: org.apache.tomcat.jdbc.pool.interceptor.StatementCache.PREPARED_TYPE should be package protected  At StatementCache.java:[line 37]
M V MS: org.apache.tomcat.dbcp.dbcp2.PoolingDriver.pools is a mutable collection which should be package protected  At PoolingDriver.java:[line 53]
M V MS: org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator.COORD_HEADER should be package protected  At NonBlockingCoordinator.java:[line 133]
M V MS: org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator.COORD_REQUEST should be package protected  At NonBlockingCoordinator.java:[line 137]
M V MS: org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator.COORD_CONF should be package protected  At NonBlockingCoordinator.java:[line 141]
M V MS: org.apache.catalina.tribes.group.interceptors.NonBlockingCoordinator.COORD_ALIVE should be package protected  At NonBlockingCoordinator.java:[line 146]
M V MS: org.apache.catalina.core.AprLifecycleListener.SSLEngine should be package protected  At AprLifecycleListener.java:[line 76]
M V MS: org.apache.catalina.core.AprLifecycleListener.FIPSMode should be package protected  At AprLifecycleListener.java:[line 77]
M V MS: org.apache.catalina.core.AprLifecycleListener.SSLRandomSeed should be package protected  At AprLifecycleListener.java:[line 78]
M V MS: org.apache.catalina.core.AprLifecycleListener.sslInitialized should be package protected  At AprLifecycleListener.java:[line 79]
M V MS: org.apache.catalina.core.AprLifecycleListener.aprInitialized should be package protected  At AprLifecycleListener.java:[line 80]
M V MS: org.apache.catalina.core.AprLifecycleListener.aprAvailable should be package protected  At AprLifecycleListener.java:[line 81]
M V MS: org.apache.catalina.core.AprLifecycleListener.fipsModeActive should be package protected  At AprLifecycleListener.java:[line 82]
M V MS: org.apache.catalina.startup.ContextConfig.deploymentCount should be package protected  At ContextConfig.java:[line 156]
H V MS: org.apache.catalina.storeconfig.StoreLoader.digester isn't final but should be  At StoreLoader.java:[line 81]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA is a mutable array  At ConstantPool.java:[line 147]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVAX should be moved out of an interface and made package protected  At TypeConstants.java:[line 32]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.LANG is a mutable array  At ConstantPool.java:[line 147]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.IO should be moved out of an interface and made package protected  At TypeConstants.java:[line 34]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UTIL should be moved out of an interface and made package protected  At TypeConstants.java:[line 35]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ZIP should be moved out of an interface and made package protected  At TypeConstants.java:[line 36]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ANNOTATION should be moved out of an interface and made package protected  At TypeConstants.java:[line 37]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.REFLECT is a mutable array  At ConstantPool.java:[line 147]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.LENGTH should be moved out of an interface and made package protected  At ArrayBinding.java:[line 38]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CLONE is a mutable array  At TypeConstants.java:[line 40]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.EQUALS should be moved out of an interface and made package protected  At TypeConstants.java:[line 41]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.GETCLASS should be moved out of an interface and made package protected  At TypeConstants.java:[line 42]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.HASHCODE should be moved out of an interface and made package protected  At TypeConstants.java:[line 43]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.OBJECT is a mutable array  At TypeConstants.java:[line 44]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.MAIN should be moved out of an interface and made package protected  At TypeConstants.java:[line 45]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SERIALVERSIONUID is a mutable array  At TypeConstants.java:[line 46]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SERIALPERSISTENTFIELDS is a mutable array  At TypeConstants.java:[line 47]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.READRESOLVE is a mutable array  At TypeConstants.java:[line 48]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WRITEREPLACE is a mutable array  At TypeConstants.java:[line 49]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.READOBJECT is a mutable array  At TypeConstants.java:[line 50]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WRITEOBJECT is a mutable array  At TypeConstants.java:[line 51]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CharArray_JAVA_LANG_OBJECT is a mutable array  At TypeConstants.java:[line 52]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CharArray_JAVA_LANG_ENUM is a mutable array  At TypeConstants.java:[line 53]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CharArray_JAVA_LANG_ANNOTATION_ANNOTATION is a mutable array  At TypeConstants.java:[line 54]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CharArray_JAVA_IO_OBJECTINPUTSTREAM is a mutable array  At TypeConstants.java:[line 55]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CharArray_JAVA_IO_OBJECTOUTPUTSTREAM is a mutable array  At TypeConstants.java:[line 56]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CharArray_JAVA_IO_OBJECTSTREAMFIELD is a mutable array  At TypeConstants.java:[line 57]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ANONYM_PREFIX should be moved out of an interface and made package protected  At TypeConstants.java:[line 58]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ANONYM_SUFFIX should be moved out of an interface and made package protected  At TypeConstants.java:[line 59]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WILDCARD_NAME is a mutable array  At TypeConstants.java:[line 60]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WILDCARD_SUPER is a mutable array  At TypeConstants.java:[line 61]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WILDCARD_EXTENDS is a mutable array  At TypeConstants.java:[line 62]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WILDCARD_MINUS should be moved out of an interface and made package protected  At TypeConstants.java:[line 63]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WILDCARD_STAR should be moved out of an interface and made package protected  At TypeConstants.java:[line 64]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WILDCARD_PLUS should be moved out of an interface and made package protected  At TypeConstants.java:[line 65]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WILDCARD_CAPTURE_NAME_PREFIX should be moved out of an interface and made package protected  At TypeConstants.java:[line 66]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WILDCARD_CAPTURE_NAME_SUFFIX should be moved out of an interface and made package protected  At TypeConstants.java:[line 67]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.WILDCARD_CAPTURE should be moved out of an interface and made package protected  At TypeConstants.java:[line 68]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CAPTURE18 should be moved out of an interface and made package protected  At TypeConstants.java:[line 69]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.BYTE should be moved out of an interface and made package protected  At TypeBinding.java:[line 70]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SHORT should be moved out of an interface and made package protected  At TypeBinding.java:[line 73]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.INT should be moved out of an interface and made package protected  At TypeBinding.java:[line 67]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.LONG should be moved out of an interface and made package protected  At TypeBinding.java:[line 79]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.FLOAT should be moved out of an interface and made package protected  At TypeBinding.java:[line 82]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DOUBLE should be moved out of an interface and made package protected  At TypeBinding.java:[line 85]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CHAR should be moved out of an interface and made package protected  At TypeBinding.java:[line 76]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.BOOLEAN should be moved out of an interface and made package protected  At TypeBinding.java:[line 88]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.NULL should be moved out of an interface and made package protected  At TypeConstants.java:[line 78]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.VOID should be moved out of an interface and made package protected  At TypeConstants.java:[line 79]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.VALUE is a mutable array  At TypeConstants.java:[line 80]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.VALUES is a mutable array  At TypeConstants.java:[line 81]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.VALUEOF is a mutable array  At TypeConstants.java:[line 82]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_SOURCE is a mutable array  At TypeConstants.java:[line 83]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_CLASS is a mutable array  At TypeConstants.java:[line 84]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_RUNTIME is a mutable array  At TypeConstants.java:[line 85]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.TYPE is a mutable array  At TypeConstants.java:[line 88]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_FIELD is a mutable array  At TypeConstants.java:[line 89]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_METHOD is a mutable array  At TypeConstants.java:[line 90]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_PARAMETER is a mutable array  At TypeConstants.java:[line 91]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_CONSTRUCTOR is a mutable array  At TypeConstants.java:[line 92]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_LOCAL_VARIABLE is a mutable array  At TypeConstants.java:[line 93]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_ANNOTATION_TYPE is a mutable array  At TypeConstants.java:[line 94]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.UPPER_PACKAGE is a mutable array  At TypeConstants.java:[line 95]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ANONYMOUS_METHOD is a mutable array  At ReferenceBinding.java:[line 98]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DESERIALIZE_LAMBDA should be moved out of an interface and made package protected  At TypeConstants.java:[line 97]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.LAMBDA_TYPE is a mutable array  At TypeConstants.java:[line 98]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.TYPE_USE_TARGET is a mutable array  At TypeConstants.java:[line 101]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.TYPE_PARAMETER_TARGET is a mutable array  At TypeConstants.java:[line 102]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ORG should be moved out of an interface and made package protected  At TypeConstants.java:[line 105]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ECLIPSE should be moved out of an interface and made package protected  At TypeConstants.java:[line 106]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CORE should be moved out of an interface and made package protected  At TypeConstants.java:[line 107]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.RUNTIME should be moved out of an interface and made package protected  At TypeConstants.java:[line 108]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.APACHE should be moved out of an interface and made package protected  At TypeConstants.java:[line 109]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.COMMONS should be moved out of an interface and made package protected  At TypeConstants.java:[line 110]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.LANG3 should be moved out of an interface and made package protected  At TypeConstants.java:[line 111]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.COM should be moved out of an interface and made package protected  At TypeConstants.java:[line 112]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.GOOGLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 113]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JDT should be moved out of an interface and made package protected  At TypeConstants.java:[line 114]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.INTERNAL should be moved out of an interface and made package protected  At TypeConstants.java:[line 115]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.COMPILER should be moved out of an interface and made package protected  At TypeConstants.java:[line 116]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.LOOKUP should be moved out of an interface and made package protected  At TypeConstants.java:[line 117]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.TYPEBINDING should be moved out of an interface and made package protected  At TypeConstants.java:[line 118]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DOM should be moved out of an interface and made package protected  At TypeConstants.java:[line 119]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ITYPEBINDING should be moved out of an interface and made package protected  At TypeConstants.java:[line 120]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG should be moved out of an interface and made package protected  At TypeConstants.java:[line 123]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ANNOTATION_ANNOTATION should be moved out of an interface and made package protected  At TypeConstants.java:[line 125]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ASSERTIONERROR should be moved out of an interface and made package protected  At TypeConstants.java:[line 126]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_CLASS is a mutable array  At TypeConstants.java:[line 127]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_CLASSNOTFOUNDEXCEPTION should be moved out of an interface and made package protected  At TypeConstants.java:[line 128]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_CLONEABLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 129]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ENUM should be moved out of an interface and made package protected  At TypeConstants.java:[line 130]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_EXCEPTION should be moved out of an interface and made package protected  At TypeConstants.java:[line 131]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ERROR should be moved out of an interface and made package protected  At TypeConstants.java:[line 132]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ILLEGALARGUMENTEXCEPTION should be moved out of an interface and made package protected  At TypeConstants.java:[line 133]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ITERABLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 134]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_NOCLASSDEFERROR should be moved out of an interface and made package protected  At TypeConstants.java:[line 135]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_OBJECT is a mutable array  At TypeConstants.java:[line 136]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_STRING should be moved out of an interface and made package protected  At TypeConstants.java:[line 137]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_STRINGBUFFER should be moved out of an interface and made package protected  At TypeConstants.java:[line 138]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_STRINGBUILDER should be moved out of an interface and made package protected  At TypeConstants.java:[line 139]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_SYSTEM should be moved out of an interface and made package protected  At TypeConstants.java:[line 140]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_RUNTIMEEXCEPTION should be moved out of an interface and made package protected  At TypeConstants.java:[line 141]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_THROWABLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 142]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_REFLECT_CONSTRUCTOR should be moved out of an interface and made package protected  At TypeConstants.java:[line 143]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_PRINTSTREAM should be moved out of an interface and made package protected  At TypeConstants.java:[line 144]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_SERIALIZABLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 145]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_BYTE should be moved out of an interface and made package protected  At TypeConstants.java:[line 146]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_SHORT should be moved out of an interface and made package protected  At TypeConstants.java:[line 147]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_CHARACTER should be moved out of an interface and made package protected  At TypeConstants.java:[line 148]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_INTEGER should be moved out of an interface and made package protected  At TypeConstants.java:[line 149]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_LONG should be moved out of an interface and made package protected  At TypeConstants.java:[line 150]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_FLOAT should be moved out of an interface and made package protected  At TypeConstants.java:[line 151]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_DOUBLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 152]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_BOOLEAN should be moved out of an interface and made package protected  At TypeConstants.java:[line 153]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_VOID is a mutable array  At TypeConstants.java:[line 154]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_UTIL_COLLECTION should be moved out of an interface and made package protected  At TypeConstants.java:[line 155]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_UTIL_ITERATOR should be moved out of an interface and made package protected  At TypeConstants.java:[line 156]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_UTIL_OBJECTS should be moved out of an interface and made package protected  At TypeConstants.java:[line 157]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_DEPRECATED is a mutable array  At TypeConstants.java:[line 158]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ANNOTATION_DOCUMENTED should be moved out of an interface and made package protected  At TypeConstants.java:[line 159]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ANNOTATION_INHERITED should be moved out of an interface and made package protected  At TypeConstants.java:[line 160]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ANNOTATION_REPEATABLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 161]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_OVERRIDE should be moved out of an interface and made package protected  At TypeConstants.java:[line 162]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_FUNCTIONAL_INTERFACE should be moved out of an interface and made package protected  At TypeConstants.java:[line 163]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ANNOTATION_RETENTION should be moved out of an interface and made package protected  At TypeConstants.java:[line 164]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_SUPPRESSWARNINGS should be moved out of an interface and made package protected  At TypeConstants.java:[line 165]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ANNOTATION_TARGET should be moved out of an interface and made package protected  At TypeConstants.java:[line 166]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ANNOTATION_RETENTIONPOLICY should be moved out of an interface and made package protected  At TypeConstants.java:[line 167]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_ANNOTATION_ELEMENTTYPE should be moved out of an interface and made package protected  At TypeConstants.java:[line 168]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_REFLECT_FIELD should be moved out of an interface and made package protected  At TypeConstants.java:[line 169]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_REFLECT_METHOD should be moved out of an interface and made package protected  At TypeConstants.java:[line 170]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_CLOSEABLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 171]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_OBJECTSTREAMEXCEPTION should be moved out of an interface and made package protected  At TypeConstants.java:[line 172]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_EXTERNALIZABLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 173]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_IOEXCEPTION should be moved out of an interface and made package protected  At TypeConstants.java:[line 174]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_OBJECTOUTPUTSTREAM is a mutable array  At TypeConstants.java:[line 175]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_OBJECTINPUTSTREAM is a mutable array  At TypeConstants.java:[line 176]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_NIO_FILE_FILES is a mutable array  At TypeConstants.java:[line 177]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVAX_RMI_CORBA_STUB is a mutable array  At TypeConstants.java:[line 179]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_SAFEVARARGS should be moved out of an interface and made package protected  At TypeConstants.java:[line 185]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.INVOKE should be moved out of an interface and made package protected  At TypeConstants.java:[line 186]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_INVOKE_METHODHANDLE_POLYMORPHICSIGNATURE should be moved out of an interface and made package protected  At TypeConstants.java:[line 187]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_INVOKE_METHODHANDLE_$_POLYMORPHICSIGNATURE should be moved out of an interface and made package protected  At TypeConstants.java:[line 194]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY should be moved out of an interface and made package protected  At TypeConstants.java:[line 200]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_INVOKE_SERIALIZEDLAMBDA should be moved out of an interface and made package protected  At TypeConstants.java:[line 201]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_INVOKE_METHODHANDLES should be moved out of an interface and made package protected  At TypeConstants.java:[line 202]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_LANG_AUTOCLOSEABLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 203]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CLOSE is a mutable array  At TypeConstants.java:[line 204]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.GUAVA_CLOSEABLES should be moved out of an interface and made package protected  At TypeConstants.java:[line 216]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.APACHE_IOUTILS should be moved out of an interface and made package protected  At TypeConstants.java:[line 217]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.APACHE_DBUTILS should be moved out of an interface and made package protected  At TypeConstants.java:[line 218]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CLOSE_QUIETLY should be moved out of an interface and made package protected  At TypeConstants.java:[line 219]
H V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.closeMethods is a mutable array  At TypeConstants.java:[line 220]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_WRAPPER_CLOSEABLES should be moved out of an interface and made package protected  At TypeConstants.java:[line 232]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_UTIL_ZIP_WRAPPER_CLOSEABLES should be moved out of an interface and made package protected  At TypeConstants.java:[line 254]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.OTHER_WRAPPER_CLOSEABLES should be moved out of an interface and made package protected  At TypeConstants.java:[line 268]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVA_IO_RESOURCE_FREE_CLOSEABLES should be moved out of an interface and made package protected  At TypeConstants.java:[line 275]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.RESOURCE_FREE_CLOSEABLE_STREAM should be moved out of an interface and made package protected  At TypeConstants.java:[line 284]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ASSERT_CLASS should be moved out of an interface and made package protected  At TypeConstants.java:[line 289]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ORG_ECLIPSE_CORE_RUNTIME_ASSERT should be moved out of an interface and made package protected  At TypeConstants.java:[line 290]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.IS_NOTNULL is a mutable array  At TypeConstants.java:[line 292]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JUNIT should be moved out of an interface and made package protected  At TypeConstants.java:[line 294]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.FRAMEWORK should be moved out of an interface and made package protected  At TypeConstants.java:[line 295]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JUNIT_FRAMEWORK_ASSERT should be moved out of an interface and made package protected  At TypeConstants.java:[line 296]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ORG_JUNIT_ASSERT should be moved out of an interface and made package protected  At TypeConstants.java:[line 297]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ASSERT_NULL is a mutable array  At TypeConstants.java:[line 299]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ASSERT_NOTNULL is a mutable array  At TypeConstants.java:[line 300]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ASSERT_TRUE is a mutable array  At TypeConstants.java:[line 301]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ASSERT_FALSE is a mutable array  At TypeConstants.java:[line 302]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.VALIDATE_CLASS should be moved out of an interface and made package protected  At TypeConstants.java:[line 304]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ORG_APACHE_COMMONS_LANG_VALIDATE should be moved out of an interface and made package protected  At TypeConstants.java:[line 305]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ORG_APACHE_COMMONS_LANG3_VALIDATE should be moved out of an interface and made package protected  At TypeConstants.java:[line 306]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ORG_ECLIPSE_JDT_INTERNAL_COMPILER_LOOKUP_TYPEBINDING should be moved out of an interface and made package protected  At TypeConstants.java:[line 307]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.ORG_ECLIPSE_JDT_CORE_DOM_ITYPEBINDING should be moved out of an interface and made package protected  At TypeConstants.java:[line 308]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.IS_TRUE is a mutable array  At TypeConstants.java:[line 311]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.NOT_NULL is a mutable array  At TypeConstants.java:[line 312]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.COM_GOOGLE_COMMON_BASE_PRECONDITIONS should be moved out of an interface and made package protected  At TypeConstants.java:[line 314]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CHECK_NOT_NULL is a mutable array  At TypeConstants.java:[line 317]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CHECK_ARGUMENT is a mutable array  At TypeConstants.java:[line 318]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CHECK_STATE is a mutable array  At TypeConstants.java:[line 319]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.REQUIRE_NON_NULL is a mutable array  At TypeConstants.java:[line 322]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.INJECT_PACKAGE should be moved out of an interface and made package protected  At TypeConstants.java:[line 325]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.INJECT_TYPE should be moved out of an interface and made package protected  At TypeConstants.java:[line 326]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.JAVAX_ANNOTATION_INJECT_INJECT should be moved out of an interface and made package protected  At TypeConstants.java:[line 327]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.COM_GOOGLE_INJECT_INJECT should be moved out of an interface and made package protected  At TypeConstants.java:[line 328]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.OPTIONAL is a mutable array  At TypeConstants.java:[line 330]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.INIT is a mutable array  At TypeConstants.java:[line 343]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.CLINIT is a mutable array  At TypeConstants.java:[line 344]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SYNTHETIC_SWITCH_ENUM_TABLE should be moved out of an interface and made package protected  At TypeConstants.java:[line 345]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SYNTHETIC_ENUM_VALUES should be moved out of an interface and made package protected  At TypeConstants.java:[line 346]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SYNTHETIC_ASSERT_DISABLED should be moved out of an interface and made package protected  At TypeConstants.java:[line 347]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SYNTHETIC_CLASS should be moved out of an interface and made package protected  At TypeConstants.java:[line 348]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SYNTHETIC_OUTER_LOCAL_PREFIX should be moved out of an interface and made package protected  At TypeConstants.java:[line 349]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SYNTHETIC_ENCLOSING_INSTANCE_PREFIX is a mutable array  At TypeConstants.java:[line 350]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SYNTHETIC_ACCESS_METHOD_PREFIX should be moved out of an interface and made package protected  At TypeConstants.java:[line 351]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SYNTHETIC_ENUM_CONSTANT_INITIALIZATION_METHOD_PREFIX should be moved out of an interface and made package protected  At TypeConstants.java:[line 352]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.SYNTHETIC_STATIC_FACTORY should be moved out of an interface and made package protected  At TypeConstants.java:[line 353]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DEFAULT_LOCATION__PARAMETER is a mutable array  At TypeConstants.java:[line 356]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DEFAULT_LOCATION__RETURN_TYPE is a mutable array  At TypeConstants.java:[line 357]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DEFAULT_LOCATION__FIELD is a mutable array  At TypeConstants.java:[line 358]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DEFAULT_LOCATION__TYPE_ARGUMENT is a mutable array  At TypeConstants.java:[line 359]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DEFAULT_LOCATION__TYPE_PARAMETER is a mutable array  At TypeConstants.java:[line 360]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DEFAULT_LOCATION__TYPE_BOUND is a mutable array  At TypeConstants.java:[line 361]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.DEFAULT_LOCATION__ARRAY_CONTENTS is a mutable array  At TypeConstants.java:[line 362]
M V MS: org.eclipse.jdt.internal.compiler.lookup.TypeConstants.PACKAGE_INFO_NAME is a mutable array  At TypeConstants.java:[line 366]
H V MS: org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReportJmx.mbeans isn't final but should be  At SlowQueryReportJmx.java:[line 67]
H V MS: org.apache.tomcat.jdbc.pool.interceptor.SlowQueryReportJmx.notifySequence isn't final but should be  At SlowQueryReportJmx.java:[line 102]
M V MS: org.apache.jasper.JspC.insertBefore is a mutable collection which should be package protected  At JspC.java:[line 146]
M V MS: org.eclipse.jdt.internal.compiler.parser.ScannerHelper.Bits should be package protected  At ScannerHelper.java:[line 25]
M V MS: org.eclipse.jdt.internal.compiler.parser.ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES is a mutable array  At ScannerHelper.java:[line 47]
M V MS: org.apache.tomcat.util.buf.StringCache.byteEnabled should be package protected  At StringCache.java:[line 43]
M V MS: org.apache.tomcat.util.buf.StringCache.charEnabled should be package protected  At StringCache.java:[line 47]
M V MS: org.apache.tomcat.util.buf.StringCache.trainThreshold should be package protected  At StringCache.java:[line 51]
M V MS: org.apache.tomcat.util.buf.StringCache.cacheSize should be package protected  At StringCache.java:[line 55]
M V MS: org.apache.tomcat.util.buf.StringCache.bcStats is a mutable collection which should be package protected  At StringCache.java:[line 67]
M V MS: org.apache.tomcat.util.buf.StringCache.bcCount should be package protected  At StringCache.java:[line 74]
M V MS: org.apache.tomcat.util.buf.StringCache.bcCache should be package protected  At StringCache.java:[line 80]
M V MS: org.apache.tomcat.util.buf.StringCache.ccStats is a mutable collection which should be package protected  At StringCache.java:[line 86]
M V MS: org.apache.tomcat.util.buf.StringCache.ccCount should be package protected  At StringCache.java:[line 93]
M V MS: org.apache.tomcat.util.buf.StringCache.ccCache should be package protected  At StringCache.java:[line 99]
M V MS: org.apache.tomcat.util.buf.StringCache.accessCount should be package protected  At StringCache.java:[line 105]
M V MS: org.apache.tomcat.util.buf.StringCache.hitCount should be package protected  At StringCache.java:[line 111]
M V MS: org.apache.catalina.tribes.group.interceptors.TcpPingInterceptor.TCP_PING_DATA should be package protected  At TcpPingInterceptor.java:[line 49]
M V MS: org.apache.catalina.tribes.transport.Constants.ACK_DATA is a mutable array  At Constants.java:[line 35]
M V MS: org.apache.catalina.tribes.transport.Constants.FAIL_ACK_DATA is a mutable array  At Constants.java:[line 36]
M V MS: org.apache.catalina.tribes.transport.Constants.ACK_COMMAND is a mutable array  At Constants.java:[line 37]
M V MS: org.apache.catalina.tribes.transport.Constants.FAIL_ACK_COMMAND is a mutable array  At Constants.java:[line 38]
M C Nm: VERY confusing to have methods org.apache.tomcat.util.net.AprEndpoint.setSSLProtocol(String) and org.apache.tomcat.util.net.AbstractEndpoint.setSslProtocol(String)  At AprEndpoint.java:[line 218]
M C Nm: VERY confusing to have methods org.apache.tomcat.util.net.AprEndpoint.getSSLProtocol() and org.apache.tomcat.util.net.AbstractEndpoint.getSslProtocol()  At AprEndpoint.java:[line 217]
M M IS: Inconsistent synchronization of org.apache.coyote.http11.InternalNioOutputBuffer.socket; locked 61% of time  Unsynchronized access at InternalNioOutputBuffer.java:[line 90]
M M IS: Inconsistent synchronization of org.apache.catalina.authenticator.AuthenticatorBase.sessionIdGenerator; locked 85% of time  Unsynchronized access at AuthenticatorBase.java:[line 876]
M M IS: Inconsistent synchronization of org.apache.catalina.tribes.membership.McastServiceImpl.startLevel; locked 85% of time  Unsynchronized access at McastService.java:[line 490]
M M IS: Inconsistent synchronization of org.apache.jasper.el.JasperELResolver.size; locked 77% of time  Unsynchronized access at JasperELResolver.java:[line 109]
M M IS: Inconsistent synchronization of org.apache.jasper.compiler.SmapGenerator.doEmbedded; locked 50% of time  Unsynchronized access at SmapGenerator.java:[line 104]
M M IS: Inconsistent synchronization of org.apache.taglibs.standard.tag.common.core.ChooseTag.subtagGateClosed; locked 75% of time  Unsynchronized access at ChooseTag.java:[line 97]
M M IS: Inconsistent synchronization of org.apache.taglibs.standard.tlv.JstlBaseTLV.messageVector; locked 75% of time  Unsynchronized access at JstlBaseTLV.java:[line 254]
M M IS: Inconsistent synchronization of org.apache.catalina.ha.tcp.ReplicationValve.lastSendTime; locked 60% of time  Unsynchronized access at ReplicationValve.java:[line 215]
M M IS: Inconsistent synchronization of org.apache.catalina.ha.session.DeltaManager.stateTransferCreateSendTime; locked 83% of time  Unsynchronized access at DeltaManager.java:[line 1257]
M M IS: Inconsistent synchronization of org.eclipse.jdt.internal.compiler.ReadManager.readingThreads; locked 50% of time  Unsynchronized access at ReadManager.java:[line 78]
H M MSF: org.apache.catalina.manager.host.HostManagerServlet.engine is a mutable servlet field  Unsynchronized access at HostManagerServlet.java:[line 158]
M M IS: Inconsistent synchronization of org.apache.jasper.servlet.JspServletWrapper.firstTime; locked 60% of time  Unsynchronized access at JspServletWrapper.java:[line 358]
M M IS: Inconsistent synchronization of org.apache.catalina.tribes.transport.nio.NioSender.dataChannel; locked 54% of time  Unsynchronized access at NioSender.java:[line 192]
M M IS: Inconsistent synchronization of org.apache.catalina.tribes.group.ChannelCoordinator.membershipService; locked 64% of time  Unsynchronized access at ChannelCoordinator.java:[line 78]
M M IS: Inconsistent synchronization of org.apache.catalina.realm.LockOutRealm.failedUsers; locked 83% of time  Unsynchronized access at LockOutRealm.java:[line 99]
M M IS: Inconsistent synchronization of org.apache.taglibs.standard.tlv.JstlBaseTLV.tlvType; locked 50% of time  Unsynchronized access at JstlBaseTLV.java:[line 222]
M M IS: Inconsistent synchronization of org.apache.catalina.startup.ContextConfig.ok; locked 88% of time  Unsynchronized access at ContextConfig.java:[line 561]
M M IS: Inconsistent synchronization of org.apache.catalina.session.JDBCStore.dataSourceName; locked 66% of time  Unsynchronized access at JDBCStore.java:[line 457]
M M IS: Inconsistent synchronization of org.apache.catalina.realm.JAASRealm.jaasConfiguration; locked 66% of time  Unsynchronized access at JAASRealm.java:[line 620]
M M IS: Inconsistent synchronization of org.apache.catalina.core.StandardWrapper.servletClass; locked 60% of time  Unsynchronized access at StandardWrapper.java:[line 514]
M M IS: Inconsistent synchronization of org.eclipse.jdt.internal.compiler.ReadManager.units; locked 75% of time  Unsynchronized access at ReadManager.java:[line 78]
M M IS: Inconsistent synchronization of org.apache.catalina.ha.session.DeltaManager.receiverQueue; locked 75% of time  Unsynchronized access at DeltaManager.java:[line 937]
M M IS: Inconsistent synchronization of org.apache.catalina.realm.JNDIRealm.userPatternFormatArray; locked 66% of time  Unsynchronized access at JNDIRealm.java:[line 969]
M M IS: Inconsistent synchronization of org.apache.catalina.tribes.group.interceptors.TcpPingInterceptor.thread; locked 55% of time  Unsynchronized access at TcpPingInterceptor.java:[line 92]
M M IS: Inconsistent synchronization of org.apache.coyote.http11.InternalAprOutputBuffer.socket; locked 60% of time  Unsynchronized access at InternalAprOutputBuffer.java:[line 115]
M M IS: Inconsistent synchronization of org.eclipse.jdt.internal.compiler.ReadManager.nextFileToRead; locked 83% of time  Unsynchronized access at ReadManager.java:[line 150]
M M IS: Inconsistent synchronization of org.apache.jasper.el.JasperELResolver.resolvers; locked 50% of time  Unsynchronized access at JasperELResolver.java:[line 96]
M M IS: Inconsistent synchronization of org.apache.catalina.ha.authenticator.ClusterSingleSignOn.cluster; locked 66% of time  Unsynchronized access at ClusterSingleSignOn.java:[line 64]
M M IS: Inconsistent synchronization of org.apache.catalina.valves.AccessLogValve.encoding; locked 50% of time  Unsynchronized access at AccessLogValve.java:[line 325]
M M IS: Inconsistent synchronization of org.apache.catalina.session.JDBCStore.sessionAppCol; locked 60% of time  Unsynchronized access at JDBCStore.java:[line 336]
M M IS: Inconsistent synchronization of org.apache.catalina.authenticator.SingleSignOn.engine; locked 40% of time  Unsynchronized access at SingleSignOn.java:[line 406]
M M IS: Inconsistent synchronization of org.apache.catalina.session.JDBCStore.sessionIdCol; locked 60% of time  Unsynchronized access at JDBCStore.java:[line 345]
M M IS: Inconsistent synchronization of org.apache.jasper.compiler.JspConfig.defaultDeferedSyntaxAllowedAsLiteral; locked 66% of time  Unsynchronized access at JspConfig.java:[line 337]
M M IS: Inconsistent synchronization of org.apache.catalina.tribes.membership.MemberImpl.dataPkg; locked 81% of time  Unsynchronized access at MemberImpl.java:[line 409]
M M IS: Inconsistent synchronization of org.apache.catalina.tribes.transport.nio.NioSender.writebuf; locked 66% of time  Unsynchronized access at NioSender.java:[line 199]
M M IS: Inconsistent synchronization of org.apache.catalina.core.StandardContext.cookieProcessor; locked 50% of time  Unsynchronized access at StandardContext.java:[line 825]
M M IS: Inconsistent synchronization of org.eclipse.jdt.internal.compiler.ReadManager.caughtException; locked 54% of time  Unsynchronized access at ReadManager.java:[line 79]
M M IS: Inconsistent synchronization of org.apache.catalina.tribes.transport.nio.NioSender.socketChannel; locked 62% of time  Unsynchronized access at NioSender.java:[line 192]
M M IS: Inconsistent synchronization of org.eclipse.jdt.internal.compiler.ProcessTaskManager.processingThread; locked 80% of time  Unsynchronized access at ProcessTaskManager.java:[line 112]
M M IS: Inconsistent synchronization of org.apache.catalina.core.StandardWrapper.unloadDelay; locked 50% of time  Unsynchronized access at StandardWrapper.java:[line 462]
M M IS: Inconsistent synchronization of org.apache.coyote.http11.InternalAprOutputBuffer.wrapper; locked 75% of time  Unsynchronized access at InternalAprOutputBuffer.java:[line 116]
M M IS: Inconsistent synchronization of org.apache.catalina.ha.session.JvmRouteBinderValve.cluster; locked 71% of time  Unsynchronized access at JvmRouteBinderValve.java:[line 260]
M M IS: Inconsistent synchronization of org.apache.catalina.realm.JDBCRealm.roleNameCol; locked 50% of time  Unsynchronized access at JDBCRealm.java:[line 227]
M M IS: Inconsistent synchronization of org.apache.tomcat.util.modeler.Registry.server; locked 57% of time  Unsynchronized access at Registry.java:[line 720]
M M IS: Inconsistent synchronization of org.apache.catalina.core.StandardWrapper.multipartConfigElement; locked 50% of time  Unsynchronized access at StandardWrapper.java:[line 1624]
M M IS: Inconsistent synchronization of org.apache.taglibs.standard.tlv.JstlBaseTLV.config; locked 50% of time  Unsynchronized access at JstlFmtTLV.java:[line 150]
M M IS: Inconsistent synchronization of org.apache.catalina.realm.JAASRealm.configFile; locked 50% of time  Unsynchronized access at JAASRealm.java:[line 184]
M M IS: Inconsistent synchronization of org.apache.catalina.realm.JDBCRealm.userRoleTable; locked 50% of time  Unsynchronized access at JDBCRealm.java:[line 269]
M M IS: Inconsistent synchronization of org.apache.jasper.compiler.JspConfig.defaultIsELIgnored; locked 66% of time  Unsynchronized access at JspConfig.java:[line 334]
M M IS: Inconsistent synchronization of org.apache.catalina.startup.ContextConfig.context; locked 89% of time  Unsynchronized access at ContextConfig.java:[line 464]
M M IS: Inconsistent synchronization of org.apache.taglibs.standard.tlv.JstlBaseTLV.uri; locked 50% of time  Unsynchronized access at JstlBaseTLV.java:[line 222]
M M IS: Inconsistent synchronization of org.apache.catalina.core.StandardWrapper.swallowOutput; locked 85% of time  Unsynchronized access at StandardWrapper.java:[line 461]
